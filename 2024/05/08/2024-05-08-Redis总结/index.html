

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zenith Wang">
  <meta name="keywords" content="">
  
    <meta name="description" content="Redis总结Redis基础问题Redis可以用来做什么一般来说，我用到最多的就是两个：一个是缓存，一个是分布式锁 还有一些其他的应用，比如排行榜、计数器这种的 而至于有人说可以做消息队列、延迟队列啥的我觉得没有必要，因为有专门的东西来做比如RabbitMQ Redis为啥这么快这是一个很老的问题，总的来说一共有三点：  Redis是基于内存的，当然比基于磁盘的MySQL这种数据库快  Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis总结">
<meta property="og:url" content="http://example.com/2024/05/08/2024-05-08-Redis%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Zenith&#39; Blog">
<meta property="og:description" content="Redis总结Redis基础问题Redis可以用来做什么一般来说，我用到最多的就是两个：一个是缓存，一个是分布式锁 还有一些其他的应用，比如排行榜、计数器这种的 而至于有人说可以做消息队列、延迟队列啥的我觉得没有必要，因为有专门的东西来做比如RabbitMQ Redis为啥这么快这是一个很老的问题，总的来说一共有三点：  Redis是基于内存的，当然比基于磁盘的MySQL这种数据库快  Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321174.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321396.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280040314.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280038734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280017411.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280101820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280104063.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280117106.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303665.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302097.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303192.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282307680.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282323846.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282359203.png">
<meta property="article:published_time" content="2024-05-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-28T17:00:05.283Z">
<meta property="article:author" content="Zenith Wang">
<meta property="article:tag" content="个人笔记">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321174.png">
  
  
  
  <title>Redis总结 - Zenith&#39; Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"0iur3vFHYzHVWbfW0ACM22p2-gzGzoHsz","app_key":"Xq6ytGGvYcBfUTC6ZzSnFuPD","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zenith&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-08 00:00" pubdate>
          2024年5月8日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          61 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Redis总结</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h1><h2 id="Redis基础问题"><a href="#Redis基础问题" class="headerlink" title="Redis基础问题"></a>Redis基础问题</h2><h3 id="Redis可以用来做什么"><a href="#Redis可以用来做什么" class="headerlink" title="Redis可以用来做什么"></a>Redis可以用来做什么</h3><p>一般来说，我用到最多的就是两个：一个是<strong>缓存</strong>，一个是<strong>分布式锁</strong></p>
<p>还有一些其他的应用，比如排行榜、计数器这种的</p>
<p>而至于有人说可以做消息队列、延迟队列啥的我觉得没有必要，因为有专门的东西来做比如RabbitMQ</p>
<h3 id="Redis为啥这么快"><a href="#Redis为啥这么快" class="headerlink" title="Redis为啥这么快"></a>Redis为啥这么快</h3><p>这是一个很老的问题，总的来说一共有三点：</p>
<ol>
<li><p>Redis是基于内存的，当然比基于磁盘的MySQL这种数据库快</p>
</li>
<li><p>Redis是单线程的，可以避免线程切换、锁获取释放的时间开销。</p>
<blockquote>
<p>但是我认为这也是高并发场景下的结果，如果并发不高，其实这个开销相比于多线程并行的提升可以忽略掉</p>
</blockquote>
</li>
<li><p>Redis采用的I&#x2F;O是多路复用。多路复用其实就是内核等待I&#x2F;O准备好通知内核来读取，而不是一直等待或者轮询I&#x2F;O是否准备就绪</p>
</li>
</ol>
<blockquote>
<p>如果要问你Redis这么快的主要原因，那么一定是基于内存的，这个相比于磁盘读取的速度快的可不是一星半点！</p>
</blockquote>
<h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>Redis快的一个原因就是IO多路复用，那么到底在什么地方用了呢？多线程又是在什么地方用了呢？</p>
<h3 id="Redis那些地方用了多线程"><a href="#Redis那些地方用了多线程" class="headerlink" title="Redis那些地方用了多线程"></a>Redis那些地方用了多线程</h3><ol>
<li>Redis2.6的时候，加了两个后台线程，一个是<strong>AOF刷盘</strong>，一个是<strong>异步文件关闭</strong></li>
<li>Redis4.0的时候，新增一个后台线程，用于异步释放key。比如调用“unlink key”指令的时候，就是异步释放内存。</li>
</ol>
<blockquote>
<p>也就说说，如果用的时候4.0以上版本，我们释放大key的时候，最好用<code>unlink</code>，而不是同步删除指令<code>del</code></p>
</blockquote>
<ol start="3">
<li>Redis6.0以后，由于发现Redis的瓶颈在于内存和网络IO，而不是CPU，因此在网络IO处开启了多线程，默认是4个，可以修改配置</li>
</ol>
<h3 id="Redis的事件触发机制"><a href="#Redis的事件触发机制" class="headerlink" title="Redis的事件触发机制"></a>Redis的事件触发机制</h3><ul>
<li>首先，Redis的事件驱动模块就是一个无限循环的IO多路复用，它会一直循环如果发现有socket准备好，就会触发相应的事件处理器然后处理。</li>
<li>当事件触发后，就会先执行<code>beforeSleep</code>，然后获取触发的事件并一个一个处理事件，最后执行<code>afterSleep</code>。</li>
</ul>
<blockquote>
<p>比如：当新建事件触发后，就会注册命令请求处理器，<strong>绑定回调函数</strong><code>readQueryFromClient</code>，一旦客户端发起命令请求就会触发该事件，就会先执行<code>beforeSleep</code>，执行<code>readQueryFromClient</code>方法，最后执行<code>afterSleep</code></p>
</blockquote>
<h3 id="Redis6-0之前的单线程模式"><a href="#Redis6-0之前的单线程模式" class="headerlink" title="Redis6.0之前的单线程模式"></a>Redis6.0之前的单线程模式</h3><ul>
<li><p>在单线程模式中，发生命令请求，就会调用<code>readQueryFromClient</code>方法，该方法会读取socket并解析，解析后执行命令，最后会将返回结果写到缓冲区中，但是<strong>并没有写回客户端</strong>！</p>
</li>
<li><p>真正写回客户端，<strong>是在第二次事件触发的<code>beforeSleep</code>后</strong>，才会调用<code>handleClientsWithPendingWrites</code>，写回客户端。</p>
</li>
</ul>
<blockquote>
<p>要注意的是，单线程模式中，从读取socket到最后执行命令写到结果缓冲区，都是主线程通过for循环一个一个处理的</p>
</blockquote>
<h3 id="Redis6-0的多线程"><a href="#Redis6-0的多线程" class="headerlink" title="Redis6.0的多线程"></a>Redis6.0的多线程</h3><p>Redis6.0除了执行命令是主线程做的，从读取socket到解析命令都是IO线程做的，并且从结果缓冲区写回客户端也是IO线程做的。</p>
<ul>
<li>第一次事件触发的时候，由于写缓冲区没有数据，因此<code>beforeSleep</code>不会触发<code>handleClientsWithPendingWrites</code>，那么执行<code>readQueryFromClient</code></li>
<li>在<code>readQueryFromClient</code>中，会先判断是否开启多线程<ul>
<li>如果开启，那么就会将这些socket请求放到pending_read队列中，并标记为pending_read，然后就执行结束，直接进入aferSleep</li>
<li>如果没开启，那么就跟单线程一样，从读取socket到最后把结果写到缓冲区一直由主线程执行完</li>
</ul>
</li>
<li>在afterSleep中，会执行<code>handleClientsWithPendingReadsUsingThreads</code>，如果开启多线程，那么就会分配给多个IO线程让它们去执行<code>readQueryFromClient</code></li>
<li>由于已经标记为pending_read了，那么就会读取socket并解析命令而不是再次放到pending_read队列中，最后标记为pending_command（<strong>如果不标记，就会按照单线程逻辑继续顺序执行到<code>processCommandAndResetClient</code>执行命令</strong>，但是标记后解析完就会直接返回了）</li>
<li>在主线程中会while(1)，等待这些IO执行完，执行完后就会统一顺序执行<code>processCommandAndResetClient</code>方法，执行命令写到结果缓冲区，当下次事件触发，就会在<code>beforeSleep</code>方法中执行<code>handleClientsWithPendingWrites</code>方法，写回客户端</li>
</ul>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis既然是基于内存的，那么他是如何保证数据不丢失的呢？</p>
<p>答案就是持久化，redis给了三种持久化的方式：<strong>AOF</strong>、<strong>RDB</strong>、Redis4.0以后的<strong>混合持久化</strong></p>
<h3 id="AOF持久化概述"><a href="#AOF持久化概述" class="headerlink" title="AOF持久化概述"></a>AOF持久化概述</h3><p>AOF(Append Only File)，会将redis执行的每一条写命令追加到AOF日志文件中，然后重启redis后就会顺序执行文件中的命令并执行它，就相当于恢复数据了</p>
<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321174.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;" />

<p>可以看出，和mysql的双写日志不一样，redis这里是先执行命令再写到日志为什么呢？</p>
<ul>
<li><strong>避免额外检查的开销</strong>。如果执行的命令有错，你在执行前就写到AOF日志中，要么就得校验要么就等指令出错再回滚。这两种方法都要多花时间。</li>
<li><strong>不会阻塞当前写操作命令的执行</strong>。因为是先执行命令再写日志，那么当前命令可以得到立即执行，最后写日志，不会受到写日志的IO阻塞</li>
</ul>
<p>当然，这样做也不是没有风险：</p>
<ul>
<li><p>还是会出现数据丢失的情况，如果执行完命令，还没来得及把AOF写入磁盘就宕机了，就会发生数据丢失</p>
</li>
<li><p>如果并发很高，指令很密，那么就会影响后面指令的执行</p>
</li>
</ul>
<h3 id="AOF文件刷盘策略"><a href="#AOF文件刷盘策略" class="headerlink" title="AOF文件刷盘策略"></a>AOF文件刷盘策略</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321396.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<p>上述发生数据丢失，都是和AOF数据刷盘时机相关的，Redis给出了三个策略：</p>
<ul>
<li><strong>Always</strong>：每次写操作命令执行完后，同步将AOF日志数据写回硬盘。<strong>只会发生一条指令的丢失</strong></li>
<li><strong>Everysec</strong>：每次写操作命令执行完后，先将命令写入到AOF文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘。<strong>会发生1秒钟的数据丢失</strong></li>
<li><strong>No</strong>：不由 Redis 控制写回硬盘的时机，将命令写入到 AOF 文件的内核缓冲区后，由操作系统决定何时将缓冲区内容写回硬盘。<strong>无法确定</strong></li>
</ul>
<blockquote>
<p>其实，控制从内核缓冲区写到磁盘，就是调用<code>fsync()</code>函数</p>
</blockquote>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>如果Redis一直持续的执行写命令，那么总有时候AOF文件的大小会超过阈值导致磁盘溢出，因此Redis提供了一个AOF重写机制，当大小超过用户设置的阈值的时候，就会执行重写，压缩AOF文件</p>
<blockquote>
<p>当AOF文件大小大于<strong>64M</strong>的时候，执行重写机制就会通过后台线程执行，底层是通过fork子进程来实现的：</p>
<p>fork的子进程最先是和父进程共享内存，但是只是<strong>只读模式</strong>，一旦有一方进行写操作，内存就会发生<strong>写时复制</strong>，二者独立内存</p>
<p>要注意的是：写时复制<strong>操作的只是发生异常的页</strong>，而不是整个内存全部复制</p>
</blockquote>
<p>因此，如果主进程接收到写命令，那么就会发生内存复制，出现数据不一致的情况，该怎么解决呢？</p>
<ul>
<li>Redis又提供了一个<strong>AOF重写缓冲区</strong>，在AOF执行重写的时候，主进程出了执行写命令和写到AOF缓冲区以外，还会写入AOF重写缓冲区</li>
<li>当子进程重写结束后，<strong>主进程</strong>会将AOF重写缓冲区的内容写到新的AOF文件，然后对原AOF文件覆盖</li>
</ul>
<p><strong>AOF后台重写发生阻塞的地方</strong>：写时复制、AOF重写缓冲区写入</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB（Redis DataBase）快照用于保存某一瞬间Redis内存的完整状态，因此相比于AOF：</p>
<ul>
<li><strong>RDB恢复时间更快</strong>，直接读入内存而不是一条条指令的执行</li>
<li>但是由于需要保存内存的完整内容，因此<strong>耗费资源更多</strong></li>
</ul>
<p>RDB快照生成有两种方式：save和bgsave，其中后者是fork一个子进程进行保存。那么既然涉及子线程就会涉及写时复制，在RDB的bgsave中我们要注意的是：</p>
<blockquote>
<ul>
<li>写时复制保证了快照保存的是执行bgsave指令那一刻的内存快照，因为一旦主线程修改了某个key，那么其涉及的物理页就会发生写时复制，fork的子进程仍然会保存旧key的值</li>
<li>极端情况就是所有物理页都被修改，那么就会复制所有物理页导致redis占用内存为<strong>原本的两倍</strong>，发生内存溢出</li>
</ul>
</blockquote>
<p>RDB的bgsave指令会有以下几种情况会执行：</p>
<ol>
<li>用户配置的，多少秒内修改多少次就会自动执行bgsave</li>
<li>redis关闭的时候，会自动bgsave以下</li>
<li>主动在客户端执行</li>
</ol>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>RDB优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是数据恢复不快。</p>
<p>因此，Redis4.0推出了混合持久化：</p>
<ul>
<li>在AOF重写日志的时候，fork一个子进程，先保存当前内存的RDB快照到AOF文件中</li>
<li>同时，主线程修改的数据会被记录在AOF重写缓冲区中</li>
<li>RDB快照保存到AOF文件后，就会将AOF重写缓冲区的内容追加到AOF文件的RDB快照后面</li>
<li>最后，<strong>AOF重写后的文件前一半是RDB快照，后一半是AOF日志</strong></li>
</ul>
<h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><h3 id="Redis底层的key和value是怎么存储的？"><a href="#Redis底层的key和value是怎么存储的？" class="headerlink" title="Redis底层的key和value是怎么存储的？"></a>Redis底层的key和value是怎么存储的？</h3><ul>
<li>Redis的value和eky都被Redis统一包装为了redisObject类型，其中key的ptr是SDS</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<span class="hljs-comment">//对象类型（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<span class="hljs-comment">//编码（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<span class="hljs-comment">//记录对象最后一次被应用程序访问的时间（24位=3字节）</span><br>    <span class="hljs-type">int</span> refcount;<span class="hljs-comment">//引用计数。等于0时表示可以被垃圾回收（32位=4字节）</span><br>    <span class="hljs-type">void</span> *ptr;<span class="hljs-comment">//指向底层实际的数据存储结构(8字节)</span><br>&#125; robj;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280040314.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;" />

<ul>
<li>二者被封装为dictEntry，作为hash表中的对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key;<span class="hljs-comment">//指向key，即sds</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<span class="hljs-comment">//指向value</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个key-value键值对(拉链法解决哈希冲突)</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280038734.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;" />

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>这是Redis最基本的key-value结构，这里的String类型不仅仅是字符串，也可以是数字（整数、浮点数），也可以是二进制字节，它的大小最大可以达到<strong>512M</strong></p>
<p>Redis底层的String是自己设计的：<strong>简单动态字符串SDS</strong>（Simple dynamic string），Redis3.2以前如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>&#123;</span><br>  <span class="hljs-type">int</span> len;<span class="hljs-comment">//记录buf数组已使用的长度，即SDS的长度(不包含末尾的&#x27;\0&#x27;)</span><br>  <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<span class="hljs-comment">//记录buf数组中未使用的长度</span><br>  <span class="hljs-type">char</span> buf[];<span class="hljs-comment">//字节数组，用来保存字符串</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在redisObject中，SDS字符串对应的type就是<code>REDIS_STRING</code>，而encoding编码方式有三种：</p>
<ul>
<li><ul>
<li>int编码（OBJ_ENCODING_INT）：当存储的字符串是整型，并且可以用long表示，redisObject中的联合体的<strong>value指针直接从void*变为unit_64</strong></li>
</ul>
</li>
<li>embstr编码（OBJ_ENCODING_EMBSTR）：当当字符串对象中存储的是字符串，且长度小于 44 （Redis3.2版本之前是 39）时，Redis会选择使用embstr编码来存储。这时候，redisObject和SDS的内存是连续的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280017411.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>raw编码（OBJ_ENCODING_RAW）：当字符串对象中存储的是字符串，且长度大于embstr编码规定的长度，那就会采取raw编码进行存储。此时，ptr指针指向SDS的内存地址</li>
</ul>
<blockquote>
<p>embstr编码</p>
<ul>
<li>embstr由于是和redisObject连续存储的，因此申请和释放内存的时候只需要进行一次操作</li>
<li>但是embstr是只读的，一旦使用append改写，即使没有超出embstr长度限制，也<strong>会升级为raw且不会回退</strong>（int的append同理，int编码append后，就没法进行incr这种操作了）</li>
<li>由于redisObject被规定为大小不能大于64字节，而其本身的固定长度就是16字节，那么除去SDS的额外长度剩下的就是embstr的最大存储字符长度了：<ul>
<li>Redis3.2之前，由于有一个flag和一个len都是int，因此是8字节，然后字符串还有个’\0’，所以是<strong>64-16-8-1&#x3D;39字节</strong></li>
<li>而Redis3.2之后，对于64字节的字符串做了优化，变成了sdshdr8类型，这个类型的额外字段长度为1+1+1&#x3D;3字节的长度，除去’\0’，那么最后为<strong>64-16-3-1&#x3D;44字节</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>Redis3.2对于不同长度的SDS，有不同定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^5=32B</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-comment">//实际存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^8=256B</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-comment">//除去头跟空终止符分配的空间</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">//标识字符，3位用于类型，5位未使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-comment">//使用存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^16=64KB</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^32=4GB</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^64，但redis规定string长度小于512M，故没用过</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果调用redis的append函数导致sds超出分配的buf大小即alloc大小，那么就会<strong>扩容</strong>：</p>
<ul>
<li>如果大小小于1MB，那么翻倍扩容</li>
<li>如果大于1MB，那么递增1MB的方式扩容</li>
<li><strong>如果发现sds的类型对应的大小超过了</strong>，那么就会重新申请空间，并释放掉原有的sds空间</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List类型的底层数据结构是由list或ziplist实现的，而redis3.2后就用quicklist实现了</p>
<ul>
<li>如果列表的元素个数小于 512 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 64字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>在Redis3.2版本之后，List数据类型底层数据结构就<strong>只由quicklist实现了</strong></p>
<ol>
<li><strong>list数据结构</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">//前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">//后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">//节点的值</span><br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure>

<p>Redis中的listNode就是正常定义的，但是redisObject中的ptr指向的是重新包装后的list对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-comment">//链表头节点</span><br>    listNode *head;<br>    <span class="hljs-comment">//链表尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">//节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值释放函数</span><br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值比较函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">//链表节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280101820.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;" />

<ol start="2">
<li><strong>ziplist数据结构</strong></li>
</ol>
<p>list无法很好的利用cpu缓存并且额外数据太多，因此redis设计了一个内存紧凑型的数据结构——<strong>压缩链表</strong>：</p>
<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280104063.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<ul>
<li><strong>zlbytes</strong>：记录整个压缩列表占用对内存字节数</li>
<li><strong>zltail</strong>：记录末尾节点距离起始地址多少字节，也就是列表尾的偏移量</li>
<li><strong>zllen</strong>：记录压缩列表包含的节点数量</li>
<li><strong>zlend</strong>：标记压缩列表的结束点，固定值 0xFF</li>
</ul>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li><strong>prevlen</strong>：记录了「前一个节点」的长度，目的是为了实现从后向前遍历<ul>
<li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值</li>
<li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值</li>
</ul>
</li>
<li><strong>encoding</strong>：记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数</li>
<li><strong>data</strong>：记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定</li>
</ul>
<blockquote>
<p>encoding的类型有很多：1个字节的类似uint_8, unit_16这种整型，还有字符串类型（因为要额外保存字符串长度，会根据长度决定使用1字节&#x2F;2字节&#x2F;5字节的空间来保存，而整型的类型就已经决定了长度，不需要额外保存）</p>
</blockquote>
<blockquote>
<p><strong>连锁更新</strong></p>
<p>由于前一个节点的长度大于等于254，prelen就会变成5个字节，那么：</p>
<ul>
<li>如果当前所有节点长度全是250-253之间，这时候在头部插入一个长度为255的字节的listNode</li>
<li>那原本的一个节点的prelen就会变成5字节导致自己的长度也超过255</li>
<li>那么原本第二个节点的prelen也会变为5字节，以此类推<strong>最后全量更新扩容</strong></li>
</ul>
</blockquote>
<ol start="3">
<li><strong>quicklist数据结构</strong></li>
</ol>
<p>quicklist就是<strong>双向链表+压缩链表</strong>，其底层就是一个双向链表，然后listNode的data是一个压缩链表</p>
<blockquote>
<p>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能</p>
</blockquote>
<ul>
<li>和list一样，先定义链表节点quicklistNode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>     <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-comment">//下一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">//后一个quicklistNode</span><br>    <span class="hljs-comment">//quicklistNode指向的压缩列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;              <br>    <span class="hljs-comment">//压缩列表的的字节大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;                <br>    <span class="hljs-comment">//压缩列表的元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;        <span class="hljs-comment">//ziplist中的元素个数 </span><br>    ....<br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure>

<ul>
<li>再用quicklist封装至redisObject</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    <span class="hljs-comment">//quicklist的链表头</span><br>    quicklistNode *head;      <span class="hljs-comment">//quicklist的链表头</span><br>    <span class="hljs-comment">//quicklist的链表尾</span><br>    quicklistNode *tail; <br>    <span class="hljs-comment">//所有压缩列表中的总元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;<br>    <span class="hljs-comment">//quicklistNodes的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;       <br>    ...<br>&#125; quicklist;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280117106.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的，Redis7.0以后<strong>压缩链表被listpack代替</strong>：</p>
<ul>
<li>如果列表的元素个数小于512个（默认值，可由<code>list-max-ziplist-entries</code>配置），列表每个元素的值都小于64字节（默认值，可由<code>list-max-ziplist-value</code>配置），Redis会使用<strong>压缩列表</strong>作为List类型的底层数据结构</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>哈希表</strong>作为Hash类型的底层数据结构</li>
</ul>
<p>压缩列表前面已经说过了，接下来我们来看一看hash和listpack</p>
<ol>
<li><strong>Hash数据结构</strong></li>
</ol>
<p>Redis的哈希表结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">//哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">//哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;  <br>    <span class="hljs-comment">//哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-comment">//该哈希表已有的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303665.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:33%;" />

<p>可以看出，Redis处理哈希冲突的方法是拉链法，但是Redis中的hash表是如何扩容的呢？</p>
<p>Redis对hash表的dictht又再次封装了一层，用于<strong>解决rehash问题</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    …<br>    <span class="hljs-comment">//两个Hash表，交替使用，用于rehash操作</span><br>    dictht ht[<span class="hljs-number">2</span>]; <br>    …<br>&#125; dict;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302097.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;" />

<ul>
<li><p>Redis定义了两个dictht，用于扩容的时候一个提供使用，一个用于扩容</p>
</li>
<li><p>一般情况下，Redis只会使用ht[0]，只要发生rehash的时候，才会使用ht[1]</p>
</li>
<li><p>当达到rehash条件的时候，就会开始rehash，由于防止哈希表数据过多，导致阻塞主线程时间过长，因此数据迁移并不是一次完成，而是使用一个渐进hash的策略：</p>
<ul>
<li>给ht[1]分配空间，一般会比ht[0]大一倍</li>
<li>在rehash期间，新增操作全部在ht[1]中完成</li>
<li>对于查找、删除、更新操作，先去ht[0]中找找到就直接对ht[0]操作，没找到再对ht[1]操作</li>
</ul>
<blockquote>
<p>上述两个操作，可以保证ht[0]的数据只会一直减少，不会增加</p>
</blockquote>
<ul>
<li>每次对该hash表操作时，就会按顺序从ht[0]中迁移一部分数据到ht[1]中，最终一定会迁移完毕</li>
</ul>
</li>
</ul>
<ol start="2">
<li>listpack数据结构</li>
</ol>
<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303192.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;" />

<p>相比于ziplist，listpack的每个entry不再存储前一个node的长度，而是指存储自己的长度</p>
<p>这样，当插入节点的时候，不会引起其他节点的长度变化，从而<strong>解决了连锁更新的问题</strong></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于512（默认值，set-maxintset-entries配置）个，Redis会使用<strong>整数集合</strong>作为Set类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则Redis使用<strong>哈希表</strong>作为Set类型的底层数据结构</li>
</ul>
<h3 id="Zset——跳表skipList"><a href="#Zset——跳表skipList" class="headerlink" title="Zset——跳表skipList"></a>Zset——跳表skipList</h3><p>在Zset中，底层一个实现就是跳表和哈希表，但是哈希表仅仅只是用来以O(1)的复杂度查询元素的分数，底层的范围查询啥的还是通过skipList实现的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>跳表结构设计</strong></li>
</ol>
<p>跳表是在链表基础上改进过来的，实现了一种多层的有序链表，每一层在链表上的跨度不一样，并且还提供了查找前驱节点的能力</p>
<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302552.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">//Zset 对象的元素值</span><br>    sds ele;<br>    <span class="hljs-comment">//元素权重值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">//后向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">//节点的level数组，保存每层上的前向指针和跨度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>跳表节点查询过程</strong></li>
</ol>
<p>当查询一个节点的时候，会先从头节点的最高层开始查，有两个判断条件：</p>
<ul>
<li>如果下一个节点的next的权重比指定权重小，那么直接进入下一个节点</li>
<li>如果下一个节点的next的权重和指定权重一样，但是元素小于下一个节点的元素，那么也进入下一个节点</li>
</ul>
<p>最终，如果上述两个条件都不满足，那就往下一层继续判断（也是一种贪心法吧，尽可能跨度大点）</p>
<ol start="3">
<li><p><strong>Redis往跳表插入节点</strong></p>
<ol>
<li><p>插入节点的level应该设置为多大</p>
<p>Redis在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25，那么层数就增加 1 层，然后继续生成一个随机数，直到随机数大于0.25结束，最终确定该节点的层数</p>
<p>但是，Redis规定最大层数不能超过32，也就说<strong>zskiplist的头节点的高度直接设置为32</strong></p>
</li>
<li><p>如何插入</p>
<p>就是单纯的链表插入，只需要根据权重找到应该插入的位置，往前修改每个跨度的节点的指针，在往后指向每个跨度的节点</p>
</li>
</ol>
</li>
<li><p>为什么Redis不用树，而是用跳表</p>
</li>
</ol>
<ul>
<li>B+树属于磁盘友好型，对于redis来说并不实用，而且会<strong>多很多插入删除的额外操作</strong></li>
<li>树结构最起码需要两个指针（左右子树），但是跳表用redis的概率方法，平均下来只有1.33个指针，<strong>更节省空间</strong></li>
</ul>
<h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><p>Redis高可用有三种方式，分别是：<strong>主从复制、哨兵模式、切片集群</strong>，下面一个一个来说</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282307680.png" srcset="/img/loading.gif" lazyload alt="图片" style="zoom: 50%;" />

<p>在Redis主从集群之间，是读写分离的，数据修改只会在主服务器上进行，但是二者如何实现数据一致性的呢？</p>
<ol>
<li><strong>第一次全量同步</strong></li>
</ol>
<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282323846.png" srcset="/img/loading.gif" lazyload alt="图片" style="zoom:50%;" />

<p>第一次全量同步分为三步：</p>
<ul>
<li><p>当执行了replicaof指令后，slave就会给master发送psync指令</p>
<p>master收到后，就会把自己的runID和当前同步进度offset发给salve，并告诉slave进行全量同步</p>
</li>
</ul>
<blockquote>
<p>psync有两个参数分别是主服务器的runID和同步进度offset。</p>
<p>由于是第一次同步，因此第一次psync指令的参数是？-1，因此发送的psync指令为<code>psync ? -1</code></p>
</blockquote>
<ul>
<li><p>master在把自己的runID和offset发给salve后，就会执行bgsave指令生成RDB快照，然后发送给slave</p>
<p>slave收到后，就会清空内存读取RDB，接着就会给master回复一个ACK</p>
<p>但是，master在bgsave的时候也会写数据，这个时候就会用一个replication_buffer缓冲区来存储bgsave时执行的命令</p>
</li>
<li><p>当slave读取完RDB给master回复一个ACK后，master就会将replication_buffer的内容发给slave同步新的写入数据</p>
</li>
</ul>
<blockquote>
<p>master会为每个slave建立一个replication_buffer，一旦<strong>缓冲区溢出就会强制终止全量同步</strong></p>
</blockquote>
<ol start="2">
<li><strong>命令传播</strong></li>
</ol>
<p>完成第一次全量同步后，master就会和slave建立一个TCP连接</p>
<p>后续有写指令，master就会将该指令传给slave异步执行，同时slave会更新自己的offset</p>
<ol start="3">
<li><strong>增量同步</strong></li>
</ol>
<p>由于命令传播依靠的是TCP连接，那如果TCP连接断开会怎么办？</p>
<p>连接恢复后，slave就会调用psync runID offset，只不过这里的runID和offset就有值了</p>
<p>master收到后，就会根据offset和自己的offset查看，环形缓冲区repl_backlog_buffer是否被覆盖，如果被覆盖就告知slave全量同步，还没有被覆盖就执行增量同步</p>
<p>增量同步就会把slave发送的offset到目前master记录的offset之间的指令全部写到replication_buffer中，然后发送给slave</p>
<img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282359203.png" srcset="/img/loading.gif" lazyload alt="图片" style="zoom:50%;" />

<ol start="4">
<li>集群脑裂问题</li>
</ol>
<p>当主从结构中，如果原master和集群失联，但是和客户端仍然保持联系，那么：</p>
<ul>
<li>客户端仍然将数据写入旧master</li>
<li>哨兵发现旧master失联，因此选出新的master</li>
</ul>
<p>当旧master重新连接，哨兵会通知旧master有新的master，这样旧master会执行全量同步清空旧数据，导致客户端写入的数据丢失</p>
<h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>如果主从集群中的master挂了，那么如何自动化的实现发现并进行主从切换？这就是哨兵集群的功能了！</p>
<p>哨兵节点主要负责的就是三个事儿：监控节点状态、选择新的主节点、通知客户端和从节点 master发生变更</p>
<ol>
<li><strong>如何监控状态</strong></li>
</ol>
<p>每个哨兵节点每隔一秒就会给所有节点发送ping命令，节点收到后就会返回一个pong，一旦超过时间阈值没有返回pong命令，该哨兵节点就会认为这个节点<strong>主观下线</strong></p>
<p>如果有一个哨兵节点认为主节点主观下线了，那么就会发起投票，看看其他哨兵节点怎么认为的，超过用户配置的个数阈值，就会认为该主节点客观下线，就要开始进行故障转移</p>
<blockquote>
<p>注意的是，任何节点只要认为master主观下线了都会发起投票，一旦超过阈值就会认为master客观下线</p>
</blockquote>
<ol start="2">
<li><strong>故障转移</strong></li>
</ol>
<p>故障转移分为两步，分别是选出主导这次故障转移的leader以及选择新的主节点</p>
<ul>
<li><p>选leader</p>
<p>每个认为客观下线的哨兵节点都会作为leader的候选者，然后开始投票</p>
<p>其中在选leader的时候，每个哨兵只有一次投票机会，哪个候选者先来请求就先投给谁，而且<strong>候选leader自己的一票会投给自己</strong></p>
<p>最终超过半数投票（故哨兵数量应为<strong>奇数</strong>）并且超过配置阈值才会被认为是leader，开始主导本次故障转移</p>
</li>
<li><p>选新的master</p>
<p>选择新的master会先过滤掉网络状况不好的节点（主从断连次数超过10次），然后有三轮排序：</p>
<ol>
<li>根据设置的优先级排序，人为设置，可根据服务器配置进行设置</li>
<li>如果优先级一样，就根据同步的offset排序</li>
<li>offset一样，根据自己的runID排序</li>
</ol>
</li>
</ul>
<ol start="3">
<li><strong>通知变更</strong></li>
</ol>
<p>master的变更需要通知三个：</p>
<ul>
<li>给其他从节点发送slaveOf命令，通知新的主节点</li>
<li>给客户端发送指令，通知新的master的IP和端口</li>
<li>监视旧主节点，一旦旧的主节点上线，发送slaveOf指令</li>
</ul>
<h2 id="Redis过期删除和淘汰"><a href="#Redis过期删除和淘汰" class="headerlink" title="Redis过期删除和淘汰"></a>Redis过期删除和淘汰</h2><h3 id="Redis-主从模式中，对过期键如何处理"><a href="#Redis-主从模式中，对过期键如何处理" class="headerlink" title="Redis 主从模式中，对过期键如何处理"></a>Redis 主从模式中，对过期键如何处理</h3><p>要注意的是，<strong>slave永远不会修改自己的数据，哪怕是过期了</strong></p>
<p>只有当master发现key过期了，就会删除该key，并在AOF中添加一条对应的DEL指令，然后同步给slave</p>
<blockquote>
<p> master不处理读请求，如何发现key过期：过期删除策略是惰性+定时部分删除的</p>
</blockquote>
<h3 id="Redis-持久化时，对过期键如何处理"><a href="#Redis-持久化时，对过期键如何处理" class="headerlink" title="Redis 持久化时，对过期键如何处理"></a>Redis 持久化时，对过期键如何处理</h3><ol>
<li>RDB持久化<ul>
<li>RDB文件生成的时候，会对每个key检查，过期的不会写入RDB文件</li>
<li>RDB文件加载的时候，master会对key检查，但是slave不会</li>
</ul>
</li>
<li>AOF持久化<ul>
<li>AOF文件追加的时候，发现过期key不会删除，等待清理的时候追加一条DEL语句</li>
<li>AOF文件重写的时候，发现过期key，不会保存到AOF重写中去</li>
</ul>
</li>
</ol>
<h3 id="内存淘汰中LRU和LFU有什么区别"><a href="#内存淘汰中LRU和LFU有什么区别" class="headerlink" title="内存淘汰中LRU和LFU有什么区别"></a>内存淘汰中LRU和LFU有什么区别</h3><p>在redisObject中，有一个lru字段</p>
<p>当使用LRU算法的时候，lru就是用来记录最近访问的时间戳，等需要淘汰的时候，就删掉lru最小的</p>
<p>当使用LFU算法的时候，lru的高16位记录访问的时间戳，低8位记录访问次数，删除访问次数最少的，若很多一样则删掉时间戳最小的</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java%E5%85%AB%E8%82%A1/" class="category-chain-item">Java八股</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/" class="print-no-link">#个人笔记</a>
      
        <a href="/tags/Redis/" class="print-no-link">#Redis</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis总结</div>
      <div>http://example.com/2024/05/08/2024-05-08-Redis总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zenith Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/10/2024-05-10-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/" title="消息队列基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">消息队列基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/08/2024-05-08-Spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" title="Spring的一些问题">
                        <span class="hidden-mobile">Spring的一些问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"0iur3vFHYzHVWbfW0ACM22p2-gzGzoHsz","appKey":"Xq6ytGGvYcBfUTC6ZzSnFuPD","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
