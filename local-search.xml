<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RAG技术</title>
    <link href="/2025/03/22/LLM/2025-03-22-RAG%E6%8A%80%E6%9C%AF/"/>
    <url>/2025/03/22/LLM/2025-03-22-RAG%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="RAG技术"><a href="#RAG技术" class="headerlink" title="RAG技术"></a>RAG技术</h1><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>一个基本的RAG（Retrieval-Augmented Generation）架构如下：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202503221516137.png" alt="image-20250322151602991" style="zoom: 33%;" /><p>RAG技术包括两个重要模块：generator（生成器） 和 retriever（检索器）：</p><ul><li><p>retriever：通过用户的query，根据检索算法找到top k相关的信息</p><ul><li>sparse retriever：通过统计文本中的关键词（token），来找到相关文案</li><li>dense retirver：通过embedding模型，获取chunk的稠密向量，然后计算向量的相似度</li></ul></li><li><p>generator：就是现在的LLM，基于检索的信息和用户的query，生成答案</p><ul><li>transformer-based：目前主流的text2text的模型架构，比如deepseek、qwen、llama等</li><li>diffusion-based：主要用于text2img的应用，适用于img生成</li></ul></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202503221523976.png" alt="image-20250322152307931" style="zoom: 50%;" /><h2 id="RAG技术的范式"><a href="#RAG技术的范式" class="headerlink" title="RAG技术的范式"></a>RAG技术的范式</h2><p>RAG的基本技术范式主要可以分为四种：query-based、latent representation-based、logit-based、speculative</p><p>这四种范式对于如何使用用户query和检索出来的info，有着不同的基本方法</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202503221621840.png" alt="image-20250322162154789"></p><h3 id="query-based"><a href="#query-based" class="headerlink" title="query-based"></a>query-based</h3><p>query-based是最为常见的方法，简单来说就是直接将info和query扔到一个prompt template中，作为generator的输入</p><p>比较牛逼的方法有：</p><ul><li><p>Self-rag: Learning to retrieve, generate, and critique through self-reflection（ICLR’24）</p><p>通过一种自己评判的模块，来决定是否还需要检索，以及检索出来的info是否需要</p><p>其实就是通过几个特殊符号来做</p></li><li><p>RNG-KBQA: generation augmented iterative ranking for knowledge base question answering (ACL’22)</p></li></ul><h3 id="latent-representation-based"><a href="#latent-representation-based" class="headerlink" title="latent representation-based"></a>latent representation-based</h3><p>这个它和query-based不太一样，它不是将info显示的放到generator的input中</p><p>通过使用encoder-decoder架构的transformer model，有两种latent representation-based的解决方案：</p><ul><li><p>Leveraging Passage Retrieval with Generative Modelsfor Open Domain Question Answering （EACL’21）</p><p>对于每个query+info的组合使用单独的encoder，然后concat后，放入decoder解码</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202503221613173.png" alt="image-20250322161306138" style="zoom:67%;" /></li><li><p>Improving language models by retrieving from trillions of tokens （ICML’22）</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202503221615647.png" alt="image-20250322161537600" style="zoom:50%;" /></li></ul><p>总结下来就是通过encoder，将info和query整合到decoder的latent变量中，然后利用decoder来做seq2seq</p><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>query是在输入做prompt，latent是在encoder-decoder中间的latent中做，那么logit就是在decoder中做</p><p>另外speculative rag就不说了</p><p>对于目前的LLM来说，可以看到主流model都是decoder-only架构，所以我们还是多做一些对于query-based rag的研究</p><h2 id="RAG的优化"><a href="#RAG的优化" class="headerlink" title="RAG的优化"></a>RAG的优化</h2><p>对于RAG可以做优化的地方，可以分为五大类：input, retriever, generator, result, entire pipeline</p><p>其中retriever和generator的enhancement是很重要的</p><h3 id="Input-Enhancement"><a href="#Input-Enhancement" class="headerlink" title="Input Enhancement"></a>Input Enhancement</h3><p>输入增强可以分为两类，一个是query增强一个是数据增强</p><ul><li><p>query enhancement：通过改写用户的query来获得更好的检索效果</p><p>有的是丰富用户的query，使得query包含更多的信息</p><p>而有的是分解query为多个sub-query，然后整合结果得到更好的output，如：《Rq-rag: Learning to refine queries for retrieval augmented generation》</p></li><li><p>data augmentation：对于document数据的增强，或者说是预处理</p></li></ul><h3 id="Retriver-Enhancement"><a href="#Retriver-Enhancement" class="headerlink" title="Retriver Enhancement"></a>Retriver Enhancement</h3>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SE详解</title>
    <link href="/2024/08/04/%E5%85%AB%E8%82%A1/2024-08-04-Java%20SE%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/08/04/%E5%85%AB%E8%82%A1/2024-08-04-Java%20SE%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SE详解"><a href="#Java-SE详解" class="headerlink" title="Java SE详解"></a>Java SE详解</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>都知道，面向对象有三大特性：封装、继承、多态。那么这三者到底是什么呢？</p><ul><li><p><strong>封装</strong>：封装就是将类的属性以及方法等操作都封装起来，数据被保护在对象内部，只提供对外暴露的一些方法，用户无需知道其内部的细节</p><p>这样可以减少开发过程中的代码耦合，可读性更高</p></li><li><p><strong>继承</strong>：当某些类具有一些相同的特性，或者为了描述这些类的共同特性，我们可以使用一个父类来描述，然后让这些类去继承父类，再来定义一些自己的特性</p></li><li><p><strong>多态</strong>：多态是由于继承产生的，就是子类都可以用其父类的引用来指向，但是调用重写的方法时候，会调用原本子类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Instrument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Instrument is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Instrument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Music</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wind</span>());<br>        instruments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percussion</span>());<br>        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;<br>            <span class="hljs-comment">//这里的play，调用的是wind和percussion的play</span><br>            <span class="hljs-comment">//不是instrument的play</span><br>            instrument.play();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java有八大基本数据类型，占用空间从小到大为：boolean（1bit）、byte（1B）、char（2B）、short（2B）、int（4B）、float（4B）、long（8B）、double（8B）</p><p>那么每个基本数据类型，都是是有对应的包装类型的，二者之间的转换通过自动拆箱和装箱实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;     <span class="hljs-comment">// 装箱，Integer.valueOf()</span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;         <span class="hljs-comment">// 拆箱，Integer.intValue()</span><br></code></pre></td></tr></table></figure><p>其中，像Integer、Short这些还有缓存池这样一个东西，cache[i]就是<strong>数字i的包装类对象</strong></p><p>Integer的缓存池大小是-128～127，因此一旦调用Integer.valueOf的参数在这个范围内，会直接从IntegerCache中去拿</p><p>但是如果是<strong>通过new来创建</strong>的，那就会创建新的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true</span><br><br>Integer a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br>Integer b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br>System.out.println(a == b); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>其他包装类的缓存池大小如下：</p><ul><li>boolean：true and false</li><li>byte：all（00-FF）</li><li>short： -128 ～ 127</li><li>int：-128 ～ 127</li><li>char：\u0000 ～ \u007F</li></ul></li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String的不可变"><a href="#String的不可变" class="headerlink" title="String的不可变"></a>String的不可变</h3><p>String不可变原因应该都知道吧，从两个方面分析</p><ul><li>里面的byte数组设置为了final，无法改变</li><li>整个类也是final，无法被继承和重写</li></ul><p>但是，以上是源码的角度进行的分析，到底为什么String被设置为不可变呢？</p><ul><li><strong>字符串常量池</strong>的需要，常量池存放的是字符串-&gt;String类的映射，你要是String类能改，那常量池不就废了？</li><li><strong>hash值缓存</strong>，由于Stirng的hash值会被频繁使用，但是由于String的不可变性，只要hash值算过了，那下次就不用算了（hash值是懒加载的）</li><li><strong>线程安全</strong>，String不可变，导致多线程可以随意使用，不会发生线程安全问题</li></ul><h3 id="加法操作"><a href="#加法操作" class="headerlink" title="加法操作"></a>加法操作</h3><p>Java中有两个这样的类：StringBuffer和StringBuilder，其中StringBuffer是<strong>线程安全</strong>版本</p><p>他里面的append方法，就是执行字符串的追加操作，同时String的加号也是这个原理实现的</p><p>String的+运算符是Java中唯一一个重载的运算符，其原理就是执行加法的时候，会先创建一个StringBuilder类，然后执行append操作，最后调用toString方法将结果赋值给String引用</p><p>要注意的是，即使一行代码有多个连加，也只会创建一个StringBuilder；但是，如果你将连加拆成了100行代码，那就会创建100个StringBuilder</p><p>也就是说，String加法中StringBuilder的作用域仅在当前的代码行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>    a+=<span class="hljs-string">&quot;hello &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如以上代码，就会创建1000次StringBuilder，可能会导致很多次young GC</p><p>一般可以改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000</span>;i++)&#123;<br>    sb.append(<span class="hljs-string">&quot;hello &quot;</span>);<br>&#125;<br>String res=sb.toString();<br></code></pre></td></tr></table></figure><h3 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h3><p>当我们不是通过字面量的形式去new String，而是显式的new String，那么就不会在字符串常量池创建这个索引</p><p>我们需要手动intern，才能创建</p><p>这里的显式并不是指：new String(“hello”)，这个其实也创建了，这个构造函数中的hello其实也是字面量</p><p>我指的是：String str&#x3D;new String(“hello”)+new String(“world”)</p><p>这样的话，”hello world”这个字符串其实是没有的，当我们调用intern后，**”hello world”指向的String类就是str这个引用指向的类**</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>那几个访问权限修饰符，我就不说了，我们来讲讲default</p><p>default指的是包私有，也就是说，在同一个包下的类可以访问，一般接口的方法都是写成这个，然后我们在实现类中会重写这个方法为public</p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>在Java8以后，接口可以有可以有默认的方法实现以及字段了</p><p>和抽象类基本类似，但是二者还是有很多不一样的</p><ul><li><p>一般来说，抽象类主要是用来提取某些类的共同特征，或者作为模版模式使用的基石</p><p>而接口，则是定义某一类方法的集合，让很多不相关的类具有某些特性，比如Compareable接口</p></li><li><p>抽象类的方法字段可以随意定义访问权限，可以把它当作是一个类来使用（除了无法实例化）</p><p>接口中的字段一定是static final的，并且访问权限必须是public或者default</p></li><li><p>接口可以实现多个，但是抽象类是单继承，只能继承一个</p></li><li><p>因此，一般当需要继承某些非静态、非常量的字段，要用到访问权限来限制，就使用抽象类</p><p>当需要具有多个行为集合的特性、让<strong>不相关的类</strong>实现某些通用方法集合，一般就是实现接口</p></li></ul><h3 id="super父类"><a href="#super父类" class="headerlink" title="super父类"></a>super父类</h3><p>super指的是子类的父类，当执行子类的构造函数时候，会先执行父类的构造函数</p><p>此外，当子类中需要调用父类的函数，甚至是super的有参构造就要使用super，好比this指针一样</p><p>另外，我们要强调的时候，<strong>成员变量不具有多态性</strong>，也就是说，当前的引用是什么，就访问的是谁的成员变量，如果要在子类访问父类的成员变量，其必须声明为protected及以上，而且用super访问</p><p><strong>下面代码，一定要弄明白！！！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有两个类，Tiger、Animal，其中Tiger继承了Animal，二者都有一个public的name字段</span><br>Tiger tiger=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>();<br>Animal animal=(Animal) tiger;<br><span class="hljs-comment">//打印出来的是各自的name，而不是同一个name</span><br><span class="hljs-comment">//但是，如果调用的是二者的eat方法，那么都是调用的tiger的eat方法</span><br>System.out.println(tiger.name);<br>System.out.println(animal.name);<br><br></code></pre></td></tr></table></figure><h2 id="Object对象的函数"><a href="#Object对象的函数" class="headerlink" title="Object对象的函数"></a>Object对象的函数</h2><h3 id="equals和hashCode"><a href="#equals和hashCode" class="headerlink" title="equals和hashCode"></a>equals和hashCode</h3><p>equals就是单纯的比较，默认就是直接使用&#x3D;&#x3D;比较地址</p><p>一般来说，需要比较字段来判断对象是否相等，都需要重写equals方法</p><p>但是一旦重写了equals方法后，就需要重写hashCode方法，因为两个对象逻辑判断相等但是哈希码不一样，这是绝对不允许的，反过来同理</p><p>因此在Java中，equals和hashCode需要同时重写，二者结果应该相同</p><p>否则就会出现：在HashSet中，二者相等但是却都放在了Set中（HashSet是通过hashCode索引的）</p><p>而一个对象的hashCode是懒加载的，并且一旦使用过一次，就会缓存到对象头markWord中，永远不会改变，不然hashMap、hashSet不全都乱套了</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>这个方法就是我们将一个对象打印成字符串的方法</p><p>默认就是全限定名+@+hashCode，因此重写hashCode、equals方法后，如果不重写toString，二者判断相等，那么转化为String其实也是相等的</p><h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><p>这个方法比较特殊，它是Object的方法，但是如果没有实现Clonable接口，直接调用</p><p><strong>即使重写了，也是会报错的</strong></p><p>这点需要注意一下</p><h2 id="反射和注解"><a href="#反射和注解" class="headerlink" title="反射和注解"></a>反射和注解</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解在我们日常开发过程中很常见，比如Spring中就有很多注解</p><p>一般我们自定义一个注解通常是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> TestAnno &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以看到定义的注解里面还有注解，这个叫做<strong>元注解</strong>，用于定义注解的注解</p><p>一般常用的元注解有三个：</p><ul><li><p><code>@Target</code>：作用的地方，到底是类、方法、字段还是啥啥啥</p></li><li><p><code>@Retention</code>：生效范围，分为三种源文件保留、编译器保留、运行时保留</p><p>我理解的就是，xxx保留就是xxx过后这个注解就废了，一般来说都是Runtime即运行时生效</p><p>因为只有这个才能通过反射拿到，其他的我感觉纯粹就开发用来标注的</p></li><li><p><code>@Inherited</code>：继承关系，表示这个注解修饰的东西被继承了，是不是还有这个注解的特性</p></li></ul><p>而<strong>注解是一个实现自Annotation接口的一个接口</strong>，注意注解是接口！！</p><p>那为啥我们通过getAnnotations获得的是Annotation的数组，这个接口的实现是怎么来的？</p><p>想一想，接口要是没有实例一般只会一种情况：<strong>动态代理</strong></p><p>正好这是接口，那Java就直接使用JDK动态代理呗</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在Java中，每个类的信息都被封装在了Class中，为了将Class中的各个部分切分开</p><p>比如方法、字段等等，Java通过反射机制将其一个一个重新封装了一下</p><p>这个也没啥好说的了，主要就是通过反射获得注解信息</p><p>然后进行一些配置，最典型的就是Spring的依赖注入和bean的扫描</p><p>我认为<strong>Spring其实就是一个脚本</strong>哈哈，你配置好了，它就自动化的给你扫描完</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存应用问题</title>
    <link href="/2024/08/02/%E5%85%AB%E8%82%A1/2024-08-02-%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/02/%E5%85%AB%E8%82%A1/2024-08-02-%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存应用问题"><a href="#缓存应用问题" class="headerlink" title="缓存应用问题"></a>缓存应用问题</h1><p>这里我们将Redis的缓存应用问题，单独提出一篇文章来讲</p><p>说到缓存，咱们想到的肯定就是Redis，但是还是有很多其他的东西，比如本地缓存、Memcached等等</p><p>因此，把Redis和缓存混为一谈，那是都是放屁，再说Redis也不是就用来做缓存的啊</p><p>下面，我们就缓存这一知识点来单独谈一谈</p><h2 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h2><p>缓存的分类大致可以分为两种，一种是分布式缓存，一种是本地缓存</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>分布式缓存一般需要单独部署一个缓存服务，用于多个实例共享一个内存来协作，比如分布式锁，缓解MySQL等压力，其<strong>瓶颈往往在于网络IO</strong>，</p><p>比如Redis的多路复用+多线程就是为了尽可能提高网络IO，一般延迟在毫秒级</p><p>常见的缓存有分布式缓存Redis与Memcached</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>本地缓存则是，直接放在本机内存，没有网络延迟，基本只受本机内存的影响，但是无法想分布式缓存一下实现集群部署，扩展节点等功能，延迟极地，一般在纳米级</p><p>常见的本地缓存有mybatis的两级缓存，Guava Cache，Caffeine</p><p>更底层一点的有操作系统的CPU cache，分页中的page cache，还有文件的读写缓冲区，这些也都是</p><h3 id="本地还是分布式"><a href="#本地还是分布式" class="headerlink" title="本地还是分布式"></a>本地还是分布式</h3><p>首先，要明确的是本地缓存一般没法扩展，你一个机器申请下来，内存就这么大，因此需要省着用</p><p>分布式缓存则可以扩展，但是延迟稍微高一点</p><p>一般来说，在QPS不是很高的情况下，并且查询的数据不是很多，本地缓存就够了</p><p>这种场景，实例个数一般也不到100个，就算同时请求mysql能有多大压力，因此考虑ROI问题，本地缓存就足矣</p><p>但是如果对于QPS较高，数据量大，实例节点成百上千的时候，或者需要分布式锁、bitmap这种基于缓存的协调问题，一般就要分布式缓存了</p><p>因为首先数据量大，本地内存肯定不够用，又没法扩充，并且QPS大的时候往往瓶颈不在缓存和MySQL了，Tomcat、JVM扛不住了</p><p>这个时候可以用MQ削峰、限流，或者<strong>Nginx中写Lua脚本，直接走Redis</strong>，这个时候分布式缓存就有用了吧</p><p>但是，一般来说，还是两级缓存比较常见吧，那既然用了两级缓存，缓存一致性问题就得解决了吧？</p><h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><h3 id="没有本地缓存的时候"><a href="#没有本地缓存的时候" class="headerlink" title="没有本地缓存的时候"></a>没有本地缓存的时候</h3><p>一般来说就是旁路读写，先改MySQL在删Redis，这个没啥解释的吧，就是因为写MySQL比Redis慢，先改MySQL再删Redis尽可能保证并发问题概率足够小</p><p>但是还是存在两个问题：</p><ul><li><p>上述方法仍然存在并发问题，咋办？</p><p>延迟双删，就是删完Redis后，sleep一下，再删，这样尽可能保证并发时候读出来了脏数据</p><p>其实这样还是有一定概率，但是这种概率已经非常非常小了，并且修改同一个字段的高并发几乎很少见，比如删减库存这种，基本都是加锁并只走Redis，隔一段时间才会同步一次MySQL</p></li><li><p>如果第二步删除Redis失败了咋办？</p><p>为了解决这个问题，那就只能靠消息队列了，要么删除后发一个消息出去，要么监听binlog最终还是发一个消息出去</p><p>然后收到消息再删除缓存，这样即使删除失败，无法ACK，消息会重新发送的</p><blockquote><p>但是引入MQ后，MQ的一致性又是一个问题，它分为三个部分：生产者发送ACK、消息在MQ中的持久化、消费者消费的ACK</p></blockquote></li></ul><h3 id="有本地缓存的时候"><a href="#有本地缓存的时候" class="headerlink" title="有本地缓存的时候"></a>有本地缓存的时候</h3><p>今晚看！！！</p><h2 id="一个Http请求经过全链路缓存有哪些？"><a href="#一个Http请求经过全链路缓存有哪些？" class="headerlink" title="一个Http请求经过全链路缓存有哪些？"></a>一个Http请求经过全链路缓存有哪些？</h2><p>发送一个HTTP请求，会经过很多缓存从操作系统缓存、到应用程序本地缓存、分布式缓存、数据库缓存、到本地缓存（浏览器、App）、CDN缓存、反向代理缓存等等</p><p>下面来分析分析：</p><ul><li><p>HTTP在发出去之前，肯定要走一遍<strong>客户端缓存</strong>吧，即HTTP缓存</p><p>这个缓存分为两种：<strong>强缓存和协商缓存</strong></p><p>强缓存就是命中且没过期，就返回</p><p>协商缓存命中后，还是会发出去，服务端收到后会看看相关资源有没有过期，没过期返回304直接用，过期则返回200并带上数据</p><p>也就是说，协商缓存的话，其实HTTP请求还是发出去了并没有真正意义上走本地缓存</p></li><li><p>本地缓存过后，就会走DNS解析，那么本地的<strong>HOST文件</strong>也是一种缓存，如果请求的域名在HOST已经写死了映射，那就不用找DNS服务器了，直接走HOST文件提供的IP地址</p></li><li><p>如果HTTP请求的是静态资源的话，还会走一次<strong>CDN缓存</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080013606.png" alt="img" style="zoom:67%;" /><p>DNS服务器回去请求CDN的GSLB服务器，根据负载均衡以及地域等相关信息，返回一个CDN节点，然后直接走CDN返回静态资源</p></li><li><p>到此，如果HTTP还是没返回，那就真的会把HTTP请求发给服务器了，但是真的到没到服务器还是另一回事儿，一般来说服务器前面还有两个东西，一个是<strong>Nginx反向代理</strong>，一个是<strong>Gateway网关</strong></p><ul><li>Nginx反向代理，也可以有缓存，当QPS特别高的时候，Nginx甚至可以直接通过Lua脚本直连Redis，最终还是没到服务器</li><li>网关缓存，这个还是比较简单的，就比如存放一些用户的身份信息啊等等</li></ul></li><li><p>到现在为止，HTTP还没返回，那就真的到服务器了，到服务器还是有一堆缓存等着呢</p><ul><li><strong>Tomcat缓存</strong>，服务器一般就是Tomcat容器了吧，这个也是有缓存的</li><li><strong>分布式缓存</strong>，到这才是到了Redis这种分布式缓存，可见Redis的优先级是多么的低哈哈</li><li><strong>本地缓存</strong>，这里的本地缓存，我特指Guava、Caffeine这种缓存组件</li></ul></li><li><p>如果到现在都还没有，那就是到数据库去搜了，搜的时候还有几个缓存要注意</p><ul><li><strong>mybatis缓存</strong>：这个虽然也是本地缓存的范畴，但是还是不太一样，因为这个时候已经走到数据库了，还是要区别一下</li><li><strong>MySQL缓存</strong>，这个缓存在MySQL8.0以后就取消掉了，不过用的如果是5.0的版本还是会有的</li><li><strong>MySQL的Page Cache</strong>，这个是最终缓存，已经到<strong>OS级别</strong>了，到这里其实延迟已经很慢了，如果还是没有，就只能加载磁盘，去搜了</li></ul></li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><h3 id="内存淘汰策略分类"><a href="#内存淘汰策略分类" class="headerlink" title="内存淘汰策略分类"></a>内存淘汰策略分类</h3><p>内存淘汰策略两大类，三个算法：</p><p><strong>两大类</strong>是指，针对的key类型是所有key还是有过期时间的key，分为all-keys和volatile</p><p><strong>三个算法</strong>有：lru、lfu、fifo</p><p>我们来看看LRU和LFU在Redis咋实现的</p><ul><li><p><strong>LRU</strong></p><p>Redis的LRU不是基于双向链表的，而是基于计时器的，但是计时器的话就会涉及时间排序问题</p><p>Redis直接每次选n个key，然后lru出最近最久未使用的，也就是说<strong>Redis是一种近似LRU</strong></p></li><li><p><strong>LFU</strong></p><p>Redis的LFU也不是简简单单计个数，而是访问次数和时间的比值，这个比值计算比较麻烦</p><p>但是最终反应的是，<strong>访问频率这一指标</strong></p></li></ul><h3 id="内存淘汰策略选择"><a href="#内存淘汰策略选择" class="headerlink" title="内存淘汰策略选择"></a>内存淘汰策略选择</h3><p>我们来讨论讨论这个策略的选择</p><ul><li><p>首先，要明确的是内存淘汰原则上在项目里不应该发生</p><p>因为一般公司都应该有一个监控系统，如果redis内存达到80%就会告警，这个时候就应该扩容了</p></li><li><p>但是仍然会有发生内存满的情况，此时内存淘汰策略应该是一种兜底方案，发生内存满的特殊情况我认为可以分为两种</p><ul><li><p>一种是大key直接把redis塞满，这样就没有到80%的过程，而是直接从70%到爆满</p><p>那这种只能是编码问题了，比如大V的粉丝不能用set直接放进去等等</p><p>对于这种情况，一般不设置缓存策略，塞满了应该直接报错而不是把大key塞进去，从而影响其他key的使用，比如存在的key被清掉或者其他key放不进来</p><p>通过报错，来解决大key的问题</p></li><li><p>另一种，就是并发过大，发现告警到扩容来不及了，三秒塞满</p><p>这种情况，都是因为Redis作为缓存来用的，我们来想一想缓存的特性</p><p>首先一定是设置过期时间的，其次缓存是为最近需要使用的数据而准备的，因此我们肯定是选择volatile</p><p>但是是lru还是lfu这个倒是都可以，因为Redis的LFU是基于频率的，而不是次数的，因此LFU也可以</p></li></ul><p><strong>总的来说，对于不是大并发的情况，可以不设置淘汰策略，避免大key导致的其他key异常</strong></p><p><strong>对于，Redis作为缓存的情况，可以使用volatile+LRU或者volatile+LFU</strong></p></li></ul><h2 id="缓存击穿、缓存雪崩、缓存穿透"><a href="#缓存击穿、缓存雪崩、缓存穿透" class="headerlink" title="缓存击穿、缓存雪崩、缓存穿透"></a>缓存击穿、缓存雪崩、缓存穿透</h2><p>这个是烂大街的八股了，但是我在这里会做最简洁的总结以及实现一些方案，不能光理论</p><p>这里有一点需要提一下，在Redis中有一个<strong>双key策略</strong>，在缓存雪崩的解决方案中，就可以使用这个</p><p>双key策略更可以看成是一种降级的方式，为了防止redis同一时间大量key同时过期，可以对一些热点key设置一个永不过期的key，这个key在发现设置过期时间的key过期后，直接拿来使用，而不是走数据库</p><blockquote><p>在高并发期间，任何的高并发打到数据库都是无法想象的</p></blockquote><p>包括在高并发的搜索，也是走的Redis，一般使用list来实现，而不是String</p><p>因为String的解析是十分耗时的，而为了防止list失效，我们可以用一个String的数据来作为备用key，这也是一种双key策略</p><h2 id="热点key的解决方案"><a href="#热点key的解决方案" class="headerlink" title="热点key的解决方案"></a>热点key的解决方案</h2><p>热key问题，也是频繁的问的一个问题，但是很多人，都会忽略嗅探，只背一个些鸡肋的解决方案，殊不知，嗅探热点key才是王道!</p><h3 id="什么是热点key"><a href="#什么是热点key" class="headerlink" title="什么是热点key"></a>什么是热点key</h3><p>虽然采用了集群部署，但是对于某一个key的高并发访问，最终压力还是打到了单一Redis节点上</p><p>仅仅靠读写分离肯定是够呛的，因此解决热点key问题也是十分必要的</p><p>解决热点key有两个步骤：嗅探热点key、解决热点key</p><h3 id="嗅探热点key"><a href="#嗅探热点key" class="headerlink" title="嗅探热点key"></a>嗅探热点key</h3><ul><li><p><strong>流量监控</strong></p><p>因为热点key本质是流量&#x2F;数据倾斜，比如阿里云中，就可以监控某台机器是否资源快速上升，而他资源没有，可能就是热点key问题</p><p>但是具体是哪个热点key还是不知道</p></li><li><p><strong>客户端统计</strong></p><p>当使用比如Java的Jedis客户端连接的时候，可以在发送请求前打个日志，然后通过实时计算聚合统计，精准找到热点key</p><p>至于实时计算，一般可以使用Flink等这种大数据流式计算的方式</p></li></ul><h3 id="解决热点key"><a href="#解决热点key" class="headerlink" title="解决热点key"></a>解决热点key</h3><p>当嗅探到热点key，一般当key的qps到1000的时候就需要关注热点key问题了，怎么解决呢？</p><ul><li><p><strong>引入本地缓存</strong></p><p>本地缓存的延迟为纳秒级，只要JVM能扛住，就不是问题</p><p>但是引入本地缓存后，一致性问题的解决还是比较麻烦的</p></li><li><p><strong>离散热点key</strong></p><p>将同一个key分成多份，然后存到不同的redis节点上</p><p>比如，通过给key拼装ip或者mac地址，使得热点key离散</p><p>但是这样做，一旦缓存更新，就会更新多个key，万一没有完全覆盖，就出问题了</p></li></ul><h2 id="BigKey的解决方案"><a href="#BigKey的解决方案" class="headerlink" title="BigKey的解决方案"></a>BigKey的解决方案</h2><h3 id="什么是big-key"><a href="#什么是big-key" class="headerlink" title="什么是big key"></a>什么是big key</h3><p>一般来说，对于string类型来说，一个key大概超过10KB，就可以当作大key</p><p>对于list hash set zset二级数据结构来说，超过1000个，就是大key</p><p>一旦Redis中存在big key：</p><ul><li><p>就会导致节点的内存占用太大，导致节点还没存啥，就开始内存淘汰策略了</p></li><li><p>当key过大时，网络IO问题就是很难受了，即使Redis采用了多线程，但是要是输出缓冲区不够，那可就寄了</p></li><li><p>删除阻塞，如果使用del同步删除，那会很慢从而阻塞其他命令，一般都会用unlink的后台删除</p></li></ul><p>一般来说big key的产生主要都是开发问题，比如大V的粉丝列表、很大的缓存数据直接转json丢进去</p><h3 id="解决big-key"><a href="#解决big-key" class="headerlink" title="解决big key"></a>解决big key</h3><p>同样big key的解决也是分两步：嗅探+解决</p><ul><li><p><strong>嗅探big key</strong></p><ul><li>Redis自己就提供嗅探big key的策略，使用–bigkeys来查看，但是这个命令会扫描全节点，最好还是<strong>用从节点</strong>，不要走主节点影响写阻塞</li><li>或者，和嗅探热点key一样，走jedis客户端，打日志然后分析</li></ul></li><li><p><strong>解决bigkey</strong></p><ul><li><p>对于删除操作，直接使用unlink异步删除，而不是del同步删除</p></li><li><p>选择合适的数据结构，对于多字段的大对象，可以采用hash而不是string</p><p>set这种考虑使用bitmap来解决</p></li><li><p>优化存储架构</p><p>比如对于大V的粉丝可以用bitmap方式，特殊处理，而不是直接作为Set塞进去</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节码和类加载器</title>
    <link href="/2024/07/29/%E5%85%AB%E8%82%A1/2024-07-29-%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2024/07/29/%E5%85%AB%E8%82%A1/2024-07-29-%E5%AD%97%E8%8A%82%E7%A0%81%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="字节码和类加载器"><a href="#字节码和类加载器" class="headerlink" title="字节码和类加载器"></a>字节码和类加载器</h1><h2 id="Class字节码文件解析"><a href="#Class字节码文件解析" class="headerlink" title="Class字节码文件解析"></a>Class字节码文件解析</h2><h3 id="什么是Class文件"><a href="#什么是Class文件" class="headerlink" title="什么是Class文件"></a>什么是Class文件</h3><p>在JVM中任何一个class文件都会对应这个其中的某个类或者接口的信息，但是说是class文件</p><p>它并不一定是以磁盘的形式存放着，我们可以把它看作是一个<strong>二进制流</strong>，可能是从网络等路径读取过来的</p><p>然后通过特定的classLoader加载到内存中，生成一个class对象出来</p><p>class文件不同于xml这种文件，他没有什么特定的标签来标注某块区域的功能</p><p>因此，class文件一般都会严格表明长度，从而被分为两种数据类型：<strong>无符号数</strong>（长度、数量值、索引等）和<strong>表</strong>（数据）</p><p>这种存储方式有点类似于Redis的压缩链表的方式，就是长度+data的方式存储数据</p><h3 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h3><p>class文件结构不是一成不变的，但是基本框架是不会有什么大变化的</p><p>class文件分为以下几个大部分：</p><ul><li><strong>魔数</strong>：CAFEBABE，这四个字节是每个字节码文件的开头，包括类加载中的验证阶段，就会验证开头是否是CAEBABE</li><li><strong>class文件版本</strong>：表示这个字节码文件是在什么JAVA版本下编译的，包括大版本和小版本</li><li><strong>常量池</strong>：分为长度+表</li><li><strong>访问标识</strong>：public？interface？abstract？等等</li><li><strong>类索引、父类索引、接口索引集合</strong>：类名、父类名、接口个数、接口表（java是单继承，因此父类是u2即2字节无符号整型，接口是个数+表）</li><li><strong>字段表集合、方法表集合、属性表集合</strong>：这些都是类的一些信息，由于这些都是不止一个，因此都是做成了长度+表的形式</li></ul><p>接下来，我们对这些结构，一个一个来解析解析</p><h3 id="魔数和版本号"><a href="#魔数和版本号" class="headerlink" title="魔数和版本号"></a>魔数和版本号</h3><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>魔数就是每个class文件开头固定的四个字节（u4类型），就是单纯的为了标识字节码文件CAFEBABE</p><p>当在类加载的验证阶段，发现开头四个字节不合法，就会报错</p><p>使用魔数是为了更加安全，我们无法单纯的修改文件后缀名为.class就可以作为字节码文件加载，而是通过文件内容这种更安全的方式去做检验</p><blockquote><p>这种魔数的方式，很多文件结构都有定义，比如office的doc、xls等等</p></blockquote><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>紧接着魔数后面，就是版本号，他一共也是四个字节（u4类型），但是细分可以分为两组：大版本和小版本</p><p>其中小版本在前（5、6字节），大版本在后（7、8字节）</p><p>一般来说，<strong>高版本的JVM可以加载低版本的类</strong>，但是反过来不可以！</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池是整个class文件的基石，在class文件版本号过后，紧跟着的就是常量池的数量以及常量池表</p><p>其中长度是u2（后面只要涉及到表长度，都是u2类型）</p><p>常量池存放的是class文件中的字面量以及符号引用，当加载到方法区后，就会变为<strong>运行时常量池</strong></p><blockquote><p>要注意的是，字符串常量池则是被放到了堆中</p></blockquote><p>常量池的长度其实是常量池表中的个数+1，也就是说常量池表的第一个常量是从1开始计数的，0号位置放的是空数据，为了方便某些地方的索引指向常量池，但是又不引用常量池的数据</p><h4 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h4><p>常量池表包含了class文件中引用的所有字面量、类、接口名、字段名、方法名等等</p><p>每一项都是具有相同特征的，第一个字节都是标注<strong>当前项是什么类型</strong>（tag type），一旦类型确定，那么后面的数据大小也就确定了。其中：</p><ul><li><strong>字面量</strong>包括：文本字符串和声明为final的常量值</li><li><strong>符号引用</strong>包括：类或接口的全限定名、字段的名称和描述符、方法的名称和描述符</li></ul><p>这里描述符比较重要，它是用来描述字段的数据类型、方法的参数列表的，由于类型就是八大常用类型+类的引用，因此类型的标志不会在下图之外：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407300212285.png" alt="image-20240730021219161" style="zoom:50%;" /><p>这些常量池数据，都是无法被JVM直接使用的，都是class被加载后，在Linking的Resolve阶段被替换为直接引用，才可以供JVM使用</p><h4 id="表项解析"><a href="#表项解析" class="headerlink" title="表项解析"></a>表项解析</h4><p>刚刚说了，只要表项的tag type确定了，那么这个表项的大小也就确定了，那具体是多大就要看类型了</p><ul><li>类（接口的方法另有一个类型，但是内容基本相同）中方法的符号引用：有两个u2的索引项，分别指向方法所属的类名引用以及字段或方法的名称引用</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据存储问题</title>
    <link href="/2024/07/20/%E5%85%AB%E8%82%A1/2024-07-20-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/20/%E5%85%AB%E8%82%A1/2024-07-20-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="数据存储问题"><a href="#数据存储问题" class="headerlink" title="数据存储问题"></a>数据存储问题</h1><p>今天，我们来聊一聊在业务中，我们的数据是如何存储的，包括海量数据、高并发读写等问题是如何解决的</p><p>我们将会从MySQL开始讲起，谈一谈分库分表，然后我们聊一聊除了MySQL以外的数据库，包括NoSQL和新一代的分布式关系数据库NewSQL</p><p>最后，来讲一讲在类似ES、HBase这些数据存储方式面前，MySQL到底是个什么样的存在</p><h2 id="基于MySQL的存储优化：分库分表"><a href="#基于MySQL的存储优化：分库分表" class="headerlink" title="基于MySQL的存储优化：分库分表"></a>基于MySQL的存储优化：分库分表</h2><h3 id="分库分表的初衷"><a href="#分库分表的初衷" class="headerlink" title="分库分表的初衷"></a>分库分表的初衷</h3><p>首先，我们来讨论一下分库分表的初衷，为什么我们要进行分库分表呢？</p><p>要知道的是，分库分表在一个项目里肯定会大大增加开发工作量和系统复杂度的，我们做分库分表肯定是有读写瓶颈，而导致我们迫不得已要做分库分表</p><p>对于MySQL而言，我们在业务场景中往往会碰到这几种问题：<strong>读请求过多</strong>、<strong>写请求过多</strong>、<strong>数据量过大</strong></p><p>那么针对上面三种问题，我们可以通过MySQL分库分表来解决这些问题</p><ul><li><p><strong>读请求过多</strong></p><p>这个还是比较简单的，多搞几个从库，然后做读写分离就可以了</p></li><li><p><strong>写请求过多</strong></p><p>这个就不能加从库了，我们得将数据分到多个主库上，这也就对应着分库分表中的<strong>分库</strong></p><p>像拆成微服务，每个服务抽出自己的数据放到自己的库里，这就是<strong>垂直分库</strong></p><p>也有的就是单纯的将数据切分成部分，然后放到不同的库里，那这就是<strong>水平分库</strong></p></li><li><p><strong>数据量过大</strong></p><p>我们知道MySQL单表不能超过2000w，其实一般我们不会让单表的数据超过1000w的</p><p>那么超过这个，我们就得将数据拆到多个表中，这也就对应着分库分表中的<strong>分表</strong></p><p>但是我很少见到有垂直分表的（按列拆），基本都是拆分成多个部分放到不同的表中，即<strong>水平分表</strong></p></li></ul><p>综上所述，我们可以将分库分表的初衷归纳为：</p><p><strong>分库就是缓解数据库计算的压力</strong>，因为数据库连接池（<strong>MySQL自己的</strong>）大小有限，当并发量过高，不但CPU、内存压力过大，等待连接的阻塞时间也会变长，我们只能通过分库来缓解压力</p><p>而<strong>分表就是缓解数据库的存储压力</strong>，因为一旦一张表的数据量上去，B+树的层数很有可能超过三层，那么就会导致查询很慢，我们分表就是为了保证B+树的层数在三层以内</p><p>这就是分库分表的初衷了，其实从分库的目的来看，主从、冷热我觉得都可以看作是分库吧</p><h3 id="分库分表的方式"><a href="#分库分表的方式" class="headerlink" title="分库分表的方式"></a>分库分表的方式</h3><p>我们先来看看数据是如何路由到某个库的某张表上</p><h4 id="路由方式"><a href="#路由方式" class="headerlink" title="路由方式"></a>路由方式</h4><p>一般来说，较为简单的就是，直接取模，我们可以将数据库以及表的数量设置为<strong>2的幂</strong>，这样我们只需要根据id做mask就可以直接路由了，相比于取模更加节省时间</p><p>但是这样的方式，不适合系统的拓展，比如你要将数据库的个数增大一倍，那你就会导致所有的数据都会更换到不同的数据库的表中去，工程量巨大！</p><p>一般来说，都是使用<strong>一致性哈希</strong>的方法来实现路由的，简单来说就是将整个id空间划分为一个范围，然后在上面放上几个节点，进来一个id就会沿着这个环顺时针的找，碰到的第一个节点就是存储的节点</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407231625132.png" alt="img" style="zoom:50%;" /><p>这个方法，看起来貌似扩展性很强，但是考虑图中的节点D加入的位置，就会导致只有少量的id分配给了节点B</p><p>这就会导致另一个问题：数据倾斜，这也是为什么订单id不根据卖家id分库分表，而是通过买家id，因为对于nike、adidas这中大卖家，订单量可能比很多个小卖家加起来还多</p><p>那么为了解决这种问题，一般我们都是在换上均匀的放置虚拟节点，然后给真正的节点分配虚拟节点，这样就可以实现数据平衡了</p><blockquote><p>其实redis的slot分片，也是采用的这种思想，只不过虚拟节点的间隔为1，更加灵活</p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407231630788.png" alt="img" style="zoom:50%;" /><h4 id="分库分表工具"><a href="#分库分表工具" class="headerlink" title="分库分表工具"></a>分库分表工具</h4><p>下面我们再来看一看，常用的分库分表的工具，一般来说分为两种：<strong>中间件形式</strong>以及<strong>代码侵入的jar包形式</strong></p><p>中间件有MyCat，KingShard这种的，这种代码耦合度较低，但是由于需要单独部署，那么可靠性就是一个问题了，一旦出现问题，不好定位</p><p>而像Sharding-Jdbc这种的，只需要引入jar包，在代码中做配置，会增加一定工作量，但是稳定性较高</p><h3 id="分库分表的案例"><a href="#分库分表的案例" class="headerlink" title="分库分表的案例"></a>分库分表的案例</h3><p>这里会讲一讲订单的分库分表，我也是从美团的技术博客：<a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">大众点评订单系统分库分表实践</a>学习的</p><p>在这个例子中，是对订单表进行了分库分表，采用的是32*32的方式，也就是32个库32个表，全部做的水平拆分</p><p>是通过userid的后四位mod32，分到不同的库，然后（userid&#x2F;32）mod 32分到各个表中</p><p>这个是分表的方式，但是分完后有三个问题：</p><ul><li><p>分布式ID怎么生成</p><p>分布式ID有很多方法，比如UUID、雪花算法等等，但是这里直接是时间戳+用户ID后四位+随机数</p><p>这样既不会重复，而且订单ID包含用户信息，可以直接通过订单ID实现分库分表，这样看似是通过userID分库分表，同时也是通过订单号分库分表的，<strong>不管是根据userID查还是orderID查都是可以直接路由到指定表</strong></p></li><li><p>数据迁移怎么做？</p><p>要知道，原本数据库中的数据，如何通过设置的分库分表算法迁移到新的库中，而且还不会影响原本业务的调用，其实是很难的</p><p>就比如，当你在迁移的时候，由用户下单了，那你怎么办呢？或者用户取消订单了等等，哪又如何保证数据一致性呢？</p><p>这个我们后面介绍，其中美团采用的就是第三个：双写方案</p></li><li><p>要是查询订单的其他信息，比如时间、金额等数据，或者统计报表某个指定条件的订单这种功能怎么办呢？</p><p>我总不能把每个表全筛选一边，然后做聚合吧？这个后面的查询问题，我们会介绍</p></li></ul><h2 id="数据迁移问题"><a href="#数据迁移问题" class="headerlink" title="数据迁移问题"></a>数据迁移问题</h2><p>数据迁移一般来说有三个解决方案，简单地说：</p><ul><li><strong>停机迁移</strong>，这没啥好说的，关闭服务然后数据迁移，像银行这种的，下班后关闭服务，然后开始迁移，这样只需要保证迁移正确，不会出现数据一致性问题</li><li><strong>日志追加法</strong>，这个就是在对老库做写操作的时候，记录一个日志，同时将老库的数据全量迁移到旧库，然后全量完毕，就通过日志进行追平，一边增量一边校验，直至数据完整</li><li><strong>双写法</strong>，就是在对老库操作的时候，同时对新库进行同样的操作，同时进行全量迁移</li></ul><p>而美团采用的就是双写法，我们来重点介绍一下双写法，一般迁移都是用这个</p><h3 id="双写法基本思想"><a href="#双写法基本思想" class="headerlink" title="双写法基本思想"></a>双写法基本思想</h3><p>双写法简单来说就是：在对老库进行写操作的时候，同时也对新库执行一样的操作，并且在此过程中进行全量数据迁移</p><p>其实写操作也就三个嘛，增删改，那么我们一个个来分析</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407232241213.png" style="zoom: 67%;" /><p>我们采用主键从小到大的方式进行迁移，假设我们迁移的主键为now</p><ul><li><p><strong>Insert</strong></p><p>如果在插入的是now之前的，那同时插入，没有问题</p><p>如果是插入在now之后，那插入后，等同步到这里，就会多出一条出来（因为老库的ID和新库的分布式ID不一样）</p><p>这里出现问题，只是说会出现问题，会有解决方案的</p></li><li><p><strong>Delete</strong></p><p>如果在now之前，那同时删除，没有问题</p><p>如果在now之后，同时删除，新库中没有，删了等于没删，旧库有，删了就不会同步了</p><p>不会出问题，但是极端情况下，刚从旧库拿了一条，然后执行双删操作，然后再插入新的一条，那就出问题了</p></li><li><p><strong>Update</strong></p><p>这个比较重要，我们在数据迁移的时候，会把update看成delete+insert操作，保证数据一致，当然也会出现Delete中的并发问题</p></li></ul><p>那么怎么解决呢？对于这种极端的并发问题，我们一般是通过数据校验的方式解决，就是对比数据，发现问题，就补全差异，一般以老库为准</p><p>那insert的这种问题呢？我们来看看美团是怎么解决的</p><h3 id="美团的数据迁移"><a href="#美团的数据迁移" class="headerlink" title="美团的数据迁移"></a>美团的数据迁移</h3><p>美团的数据迁移分为了三个部分，同时为了保证插入、查询问题，使用了一个order_mapping表，来关联新库和老库的orderID关系</p><ol><li><p><strong>第一阶段</strong>：数据库双写，并且全量更新数据，每天数据校验补齐差异，期间任何查询都是走老库</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407232256924.png" alt="数据迁移" style="zoom:50%;" /></li><li><p><strong>第二阶段</strong>：全量更新结束并且数据校验无误，继续数据库双写，但是查询逐渐切到新库，每天校验数据完整性</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407232257468.png" alt="数据迁移" style="zoom:50%;" /></li><li><p><strong>第三阶段</strong>：同步结束，老库基本不是用，等到全部改造完成，就可以废除了</p></li></ol><h2 id="其他查询问题"><a href="#其他查询问题" class="headerlink" title="其他查询问题"></a>其他查询问题</h2><p>在美团的分库分表的解决方案中，根具orderID查，是通过内嵌userID来实现的，那么其他的查询请求我们该怎么解决呢?</p><p>那就是要借助其他的数据存储工具了，ES、HBase实现最近订单的查询</p><p>可以ES建立要查询的索引，这里ES其实就是扮演了一种分布式索引的一个功能，然后拿到对应的ID再去MySQL里面找，或者在MySQL上面再加一层HBase实现，我认为如果不做冷热分离，可以加一层，做了的话，可以那就热数据直接走MySQL，冷数据走HBase，比如阿里就是做了冷热分离</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201630029.webp" alt="img" style="zoom:50%;" /><p>那么我们完全可以将统计类的一些指标提前统计好，比如日交易金额、订单量等等</p><p>那么一些真的是查几年前的订单，这种历史的查询其实很少，冷库使用一些数仓的解决方案比如HBase这种的其实也还好，慢一点就慢一点</p><h2 id="数据存储方案"><a href="#数据存储方案" class="headerlink" title="数据存储方案"></a>数据存储方案</h2><h3 id="数据存储工具对比"><a href="#数据存储工具对比" class="headerlink" title="数据存储工具对比"></a>数据存储工具对比</h3><p>上述讲到了很多数据的存储方式，比如ES、HBase等等。更进一步的，我们还有Redis、MongoDB这种NoSQL数据库，甚至还有像TiDB这种的分布式关系数据库，那么这些数据库到底有什么优劣呢？</p><p>其实看这些数据库，我们可以知道这些特性，就很好理解了</p><ul><li>MySQL：关系型数据库，用于数据结构化存储，并且支持事务保证数据完整性，但是没有天然的水平切分能力</li><li>Redis：内存级的NoSQL数据库，并发能力极强，一般用于分布式锁、分布式缓存，还支持持久化、集群部署</li><li>ES：索引数据库，一般是用于查询，一般可以存全量数据，也可以存id+索引字段数据，查出来再去MySQL、HBase这种存放全量数据的地方根据ID查找，支持天然的水平切分能力</li><li>MongoDB：文档型数据库，虽然有类似MySQL中表的定义，但是表中的每个document的schema都是允许修改的，一般用来存放数据量大、写入多，而且不是那么重要的数据，比如日志、消息的落库等等</li><li>TiDB：这是一种分布式关系型数据库，NewSQL，支持分布式事务，支持MVCC，天然的水平分片，因此后续的分库分表可以使用TiDB来实现简单的水平扩展，美团已经迁过去了：<a href="https://tech.meituan.com/2018/11/22/mysql-pingcap-practice.html">新一代数据库TiDB在美团的实践</a></li><li>HBase：一般用于大数据的处理场景，同样水平可切分，支持海量数据查询，并且根据主键rowKey查询极快</li></ul><p>综上所述，我们一般存储都是基于MySQL存储，然后通过canal这种监听binlog的中间件去异步同步类似ES、HBase这种中间件</p><p>因为MySQL具备事务的能力，保证数据的完整性，而且其他的组件没有支撑事务的能力，除了TiDB，因此仙子啊有钱的公司都是上了TiDB，或者类似这种的<strong>分布式关系数据库</strong></p><h3 id="海量数据的存储查询问题"><a href="#海量数据的存储查询问题" class="headerlink" title="海量数据的存储查询问题"></a>海量数据的存储查询问题</h3><p>一般来说，为了解决海量数据存储问题，都是MySQL+ES+HBase的方案</p><ul><li><p>通过MySQL保证数据的完整性，因为MySQL支持事务，这也是为什么都用HBase存储全量数据了，还要MySQL落库的原因，也是任何数据存储都是采用MySQL落库+binlog监听同步的原因（kc也是）</p></li><li><p>通过ES实现索引字段的查询，现在我终于理解了为什么ES中把table叫做index，其实ES不应该存放全量数据，而是充当分库分表后MySQL的<strong>分布式索引的功能</strong></p><blockquote><p>全量存放可以称为聚簇索引，只存放ID+索引字段可能会造成要去HBase做“回表查询”</p><p>我们完全可以实现覆盖索引的功能</p></blockquote></li><li><p>通过HBase的水平扩展能力，以及根据ID查询的高性能，作为数据全量存储的引擎，提供海量数据的存储和查询能力</p></li></ul><p>下面这个图是几种方案的总结，我们称分库分表为SC，单个SC就是没有分库分表</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407232329838.webp" alt="img" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据去重问题</title>
    <link href="/2024/07/18/%E5%85%AB%E8%82%A1/2024-07-20-%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/18/%E5%85%AB%E8%82%A1/2024-07-20-%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="数据去重问题"><a href="#数据去重问题" class="headerlink" title="数据去重问题"></a>数据去重问题</h1><p>在面试中，曾经碰到过很多次布隆过滤器的问题，比如我在解决接口回调幂等性问题的时候，就是通过布隆过滤器+Mysql实现的，当然也可以通过redis来实现</p><p>其实对于数据量不大的情况下，用redis就好了，使用布隆过滤器+MySQL只会增加系统的复杂度，并且提升并不是很大，因为你第一次回调都是会写到mysql里面去，并且同一个请求只会回调几次罢了</p><p>那么用redis做肯定是更为简单的，但是有人就问了，要是数据量很大，比如我们是上亿的用户都来艾特呢？</p><p>这就会导致上亿个消息，你总不能全存到redis里去吧，这一个id就是128位，128*100000000差不多都十几个G了，不太好吧？</p><p>那这些问题该怎么解决呢，我们一步一步来看</p><h3 id="MySQL直接落库"><a href="#MySQL直接落库" class="headerlink" title="MySQL直接落库"></a>MySQL直接落库</h3><p>最简单粗暴的办法，那就是使用MySQL落库，你来一条消息，处理完落库然后在返回</p><p>这么做当然是最简单的了，但是如果并发量上来，比如我有好几亿个用户，同时来艾特这个机器人导致回调，那你这一下全往MySQL写，那不就出问题了吗</p><h3 id="Redis的Set"><a href="#Redis的Set" class="headerlink" title="Redis的Set"></a>Redis的Set</h3><p>那么既然MySQL扛不住这么高的并发，那很自然而然的就想到了用Redis嘛</p><p>Redis的Set数据类型，对吧！</p><p>来一个Id，就看看Set里面有没有，没有的话就加进去，有的话就不加</p><p>注意上述的if-else判断得用lua脚本喔，不然很有可能回调很快，那就出现两次都没有，然后写了两次这种极端情况了</p><p>但是，我们再想一想，你如果一亿个请求，每个请求128位，你塞到redis的Set里面</p><p>咱先不管Redis的Set、String这些的额外空间开销，你就算基本开销那就是$128\times 10^8\approx 16\text{GB}$</p><p>我靠，那这还得了，你一个Redis集群一半也就是3-5个，一个master节点就是32G内存</p><p>你就为这么个东西，干掉了一个master的一半内存，那不出大问题了</p><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>我们再讲一个简单粗暴的方法，那就是bitmap</p><p>就是比如咱们有两亿个请求，如果id是递增的，那么id其实也就是0-200000000</p><p>那么我们可以搞一个两亿个bit的这样一个东西，然后来一个id，咱们就将对应位置为1，等下次来就可以直接根据id来看看是不是1了</p><p>其实这就是哈希表的解决方式吧，但是这种方式仅仅针对于id是紧密的像这种递增的key是可以的</p><p>如果我们是刚刚说的128位随机UUID，那你不得$2^{128}$的bitmap，那就更不得了了</p><p>当然，如果是Bitmap的话，最好别放本机，因为一旦多个实例，就会出现问题，所以最好放在中间件中，比如Redis就有这个数据结构</p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>那么我们应该怎么做呢，其Bitmap的做法没什么问题，我们可以使用布隆过滤器，压缩我们的bitmap</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201418875.png" alt="Bloom Filter 的简单原理示意图"></p><p>布隆过滤器的原理见上图，就不多说了，我们来看看这个<strong>布隆过滤器的长度应该怎么设置</strong>？</p><p>如果布隆过滤器的长度为m，元素的个数为n，使用k个哈希函数</p><p>一个id进来，某个位置被置为1的概率为$\frac{1}{m}$，置为0的概率就是$1-\frac{1}{m}$</p><p>那么k个哈希函数过后，还是0的概率就是$(1-\frac{1}{m})^k$，插入n个数还是0的概率就是$(1-\frac{1}{m})^{nk}$</p><p>那是对于每一位来说，为1的概率就是$1-(1-\frac{1}{m})^{nk}$</p><p>此时我们来了一个id来查询，k个hash函数对应的k个位置都为1的概率就是$(1-(1-\frac{1}{m})^{nk})^k$</p><p>由于当$(1-\frac{1}{m})^m$中m趋向无穷的时候为$\frac{1}{e}$，因此$(1-\frac{1}{m})^{nk}&#x3D;e^{-\frac{nk}{m}}$</p><p>也就是说，最终发生<strong>误判的概率</strong>$&#x3D;(1-e^{-\frac{nk}{m}})^k$</p><p>那么当我们知道n的大小的时候，可以根据m和k的大小来降低误判率，一般来说，我们会根据$\frac{m}{n}$，来设置k大小</p><p>可是布隆过滤器还是有缺点：</p><ul><li><p>会出现误判，我们要好好的调整好k和m，才可以</p></li><li><p>其实压缩也并没有好到哪去，一般也就到32倍的压缩</p></li><li><p>代码耦合度比较高了</p><p>比如你插入数据的时候，是不是得同步到布隆过滤器里面去</p><p>而且删除的时候你也没法直接抹掉吧？那你不抹掉，你查这个被删掉的Id，还是会去到MySQL里面查，你解决了个啥缓存穿透啊？</p><blockquote><p>其实这个解决方法也是有的：</p><ul><li>设置一个定时器，定时去同步布隆过滤器，模仿redis的hash扩容，同步完替换掉老的bitmao。但是同步的时候发生修改比较麻烦，加锁会影响性能，不加锁那你同步的时候又出现删除怎么办（新增可以同时插入嘛，倒也无所谓）</li><li>计数布隆过滤器：不是bitmap而是一个数组，每置为一次1就加一，然后删除的时候计数器减一就好了，但是这样你就又提高了布隆过滤器的大小了，比如你用short那就是增加了16倍啊！</li></ul></blockquote></li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>可以看出来，对于128位的UUID去重，我们还是没辙，那么最终该怎么做呢？</p><p>咱们来看哈，bitmap、redis这些痛点都是内存，128位*2亿的耗费量太大了，就算怎么压缩也没法实现，毕竟人家UUID是用来唯一标识的，你要是轻易去重了还得了？</p><p>那么我们只能用磁盘来实现咯，那就是MySQL嘛，但是MySQL扛不住高并发啊！</p><p>咋整？消息队列做异步削峰呗，回调咱不同步的进行处理，直接将消息塞到MQ，然后回一个OK，我们后面开多线程满满处理，减轻了MySQL的压力</p><p>行了，我能想到的大概就是这些了，其他的我也想不出来什么解决方案了</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2024/07/16/%E5%85%AB%E8%82%A1/2024-07-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/07/16/%E5%85%AB%E8%82%A1/2024-07-18-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h2><h3 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h3><p>HTTP全名叫超文本传输协议（high text transfer protocol），我们可以将其分为三个部分来解释：</p><ul><li><strong>超文本</strong>：这个不同于我们普通的文本文件，传递字符流。超文本可以传输视频、图片、二进制文件等信息。比如HTML文件，虽然本身是文本文件，但是其内部有很多a、img等标签，当http请求html文件展示到浏览器后，就会在页面渲染出图片出来</li><li><strong>传输</strong>：HTTP是用于两点直接传输的，其底层用的是TCP协议保证可靠传输</li><li><strong>协议</strong>：HTTP是定义的一套规范，用于两点之间传输超文本信息的</li></ul><h3 id="HTTP的状态码"><a href="#HTTP的状态码" class="headerlink" title="HTTP的状态码"></a>HTTP的状态码</h3><p>HTTP的状态码讲烂了，分为五类，分别是：1xx, 2xx, 3xx, 4xx, 5xx</p><p>其中4xx指的是客户端（请求端）错误，比如HTTP header不合法、权限不允许</p><p>而5xx指的是服务端（响应端）错误，比如服务器崩溃等等</p><p>此外，3xx指的是重定向，浏览器如果收到3xx的http response，会根据里面的location字段重新跳转，比如知识中心里面的草稿无效直接跳转就是用了这个状态码</p><h3 id="HTTP常见字段"><a href="#HTTP常见字段" class="headerlink" title="HTTP常见字段"></a>HTTP常见字段</h3><ul><li><p><code>HOST</code>：最常见的字段，当客户端请求的时候，就会用host字段标识请求的域名</p></li><li><p><code>Content-Length</code>：表示reponse数据的长度</p></li><li><p><code>Content-Type</code>：表示本次超文本传输的文件是什么格式的，由于HTTP可以传递很多文件格式，所以必须要这个字段来标识response的字节流如何解码</p></li><li><p><code>Content-Encoding</code>：表示本次数据是什么格式压缩的，浏览器需要根据给定的压缩格式进行解压</p><p>当然，浏览器在发起请求的时候会通过<code>Accept-Encoding</code>字段注明可以接受那些压缩方法，服务端从里面选一个方式，通过Content-Encoding字段返回</p></li><li><p><code>Connection</code>：这个主要用于保持长连接的，如果需要保持长连接可以声明为<code>Connection:Keep-Alive</code>。当然，http1.1以后就是默认长连接的，要是http1.0的话，需要手动置为Keep-Alive</p><blockquote><p>这个http的keep alive和tcp的不一样：</p><ul><li>http的是用户态进程的的keep alive，防止多次http创建多次tcp连接</li><li>tcp的是内核态进程的keep alive，用于内核探测另一端是否存活，在<code>keepalive_timeout</code>设置的时间内如果一直没有tcp报文传输，内核进程就会探测一次，若对面ACK则重新计时，不然就会默认TCP断开连接</li></ul></blockquote></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>https协议解决了http明文传输的问题，防止抓包后导致http中的敏感数据泄漏，端口号为443</p><p>基本方式就是在http和tcp之间加了一层SSL&#x2F;TLS层（七层模型对应会话层）</p><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h3><p>SSL&#x2F;TLS的工作原理简单来说就是：非对称加密实现密钥传输，再使用对称加密实现数据传输</p><ul><li>非对称加密：发送方拥有接收方的公钥，用该公钥加密，该密文只能用接收方自己的私钥解密</li><li>对称加密：使用同一个密钥，该数据的保密性，取决于密钥的安全性，如果密钥传输过程中被窃取，那就完蛋<blockquote><p>其实TLS1.0就是SSL3.0，只不过http是把这两个混在一起谈了</p></blockquote></li></ul><p>其实，即使是非对称加密，也还是有隐患：</p><p>在公钥传输的过程中，有人截获该包，然后将自己的公钥发给发送者，那么发送方就会用这个公钥加密，发送的数据被攻击者截获后，可以直接用自己的私钥解密</p><p>这就是公钥传输的信赖性问题，为了解决这个问题，需要第三方机构——证书颁发机构（CA，Certificate Authority）介入</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书就是由权威机构CA颁发的证书，该证书证明了这个公钥就是发送方本人的，而保证数字证书不会被伪造的方法就是数字签名</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201419732.png" alt="img"></p><p>数字签名使用了单向无法被逆运算的哈希函数（比如RSA、MD5等）</p><p>具体做法就是：</p><ul><li>CA通过哈希算法生成<strong>接收方的公钥+接收方部分身份信息（即数字证书）</strong>的摘要</li><li>CA在用自己的私钥加密摘要，生成签名，然后将数字证书和签名发出去</li><li>客户端收到后，首先也生成摘要，然后和数字签名解密后的摘要比对，如果一样则信任，不一样则说明篡改</li></ul><p>但是这样做还是无法杜绝证书被伪造，因为证书的公钥还是无法保证安全</p><p>为了保证公钥安全，CA的公钥采用直接安装在系统中，每个系统中都有一个<strong>根证书</strong>，包含可信赖的CA的公钥，这就可以保证公钥不会在传输过程中，被窃取伪造</p><blockquote><p>我认为，搞这么复杂，最终本质还是通过本地直接安装CA公钥，保证公钥的可信赖性</p><p>因为你不可能所有的服务器都本地安装一下，只能安装少数的比如CA的公钥，借助第三方认证</p></blockquote><h2 id="HTTP的演变"><a href="#HTTP的演变" class="headerlink" title="HTTP的演变"></a>HTTP的演变</h2><h3 id="1-0到1-1"><a href="#1-0到1-1" class="headerlink" title="1.0到1.1"></a>1.0到1.1</h3><ul><li><p><strong>缓存处理</strong></p><p>在浏览器中加入了http请求的缓存，当出现第二次请求的时候，就会在请求头中带上<code>If-Modified-Since</code>询问服务端资源是否还有效。</p><p>如果还有效，那就会返回304状态码，直接使用缓存资源；无效的话，就会返回200，带上新的数据</p></li><li><p><strong>连接方式</strong></p><p>HTTP1.0默认使用短连接，这导致每次请求都会进行一次TCP的握手和挥手，导致资源的浪费</p><p>HTTP1.1开始默认使用长连接，一旦开启长连接，建立TCP以后就不会立即断开，而是一直保持</p><p>也就是说HTTP的长连接底层还是依赖于TCP的长连接，如果双方有一方不支持，那就无法进行</p></li><li><p><strong>HOST头处理</strong></p><p>在DNS中允许将多个域名和同一个IP绑定，但是在HTTP1.0中并没有什么字段注明是访问哪个域名，它只标明了来自什么路径（比如”&#x2F;v1&#x2F;knowledge”）</p><p>而在服务端，很有可能会根据访问的域名来决定走什么逻辑，那么这就出现问题了</p><p>因此在HTTP1.1中，加入了HOST字段，表明访问的域名是什么</p></li><li><p>引入新的状态码，优化带宽资源，比如：</p><p>206：断点续传，而不是重新传递整个资源，但是仅限于字节流</p><p>100：大文件传递预热，先询问是否可以传递，若回复4xx则服务端拒绝传递；回复100则表示允许</p></li></ul><h3 id="1-1到2-0"><a href="#1-1到2-0" class="headerlink" title="1.1到2.0"></a>1.1到2.0</h3><p>目前来说，大部分网站用的都是2.0版本的HTTP，那么到底有哪些升级呢？</p><ul><li><p><strong>头部压缩</strong>：使用哈夫曼编码，将头部大小减小了一倍</p></li><li><p><strong>二进制帧传输</strong>：相比于1.1的文本格式传输，二进制方式的传输更紧凑高效</p></li><li><p><strong>多路复用</strong>：</p><p>基于TCP长连接的升级版，一个TCP连接可以支持多个HTTP传递，这就解决了HTTP的阻塞问题</p><p>虽然不同HTTP请求之间是乱序，但是同一个HTTP请求的数据包是有序的</p><p>因此，当前面的HTTP请求阻塞的时候，不会影响后续的HTTP请求</p></li></ul><h3 id="2-0到3-0"><a href="#2-0到3-0" class="headerlink" title="2.0到3.0"></a>2.0到3.0</h3><p>2.0到3.0的最大变化就是：<strong>TCP变为UDP支持的QUIC协议</strong></p><p>QUIC不仅解决了HTTP的队头阻塞问题，还提供和TLS&#x2F;SSL相当的安全性，属于UDP的升级版</p><h2 id="WebSocket与SSE"><a href="#WebSocket与SSE" class="headerlink" title="WebSocket与SSE"></a>WebSocket与SSE</h2><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>websocket协议是用来弥补http协议的不足，在建立一次TCP连接后可以持续的实现全双工通信</p><p>而HTTP虽然用的是TCP全双工传输，但是到http层还是使用的半双工的请求-响应模式</p><p>这种情况下，如果服务端有消息需要主动推送给客户端是无法实现的，只能通过短轮询和长轮询机制</p><blockquote><p><strong>短轮询</strong>：就是客户端一直向服务端发送http请求，服务端收到后返回有没有消息</p><p><strong>长轮询</strong>：像Apollo、RocketMQ都是这样，防止大量的pull请求过来，当收到http请求后如果有消息立即返回，如果没消息就先在</p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201421249.png" alt="img" style="zoom:67%;" /><p>具体工作流程如下：</p><ul><li>首先客户端会发送http请求，但是携带header参数：<code>Upgrade: websocket</code>和<code>Sec-WebSocket-Key</code>，请求升级成websocket协议</li><li>服务端收到后，如果可以支持websocket协议，就会返回状态码101，并且携带参数<code>Connection: Upgrade</code></li><li>这样二者就会建立websocket连接，可以双向传输数据，数据以帧为单位传输</li><li>当有一端想关闭连接的时候，就会发送关闭帧，然后对方ACK以后就会关闭连接</li></ul><h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><p>SSE是ChatGPT实现流式输出的底层原理，其还是基于HTTP的，和websocket不一样</p><p>虽然websocket开启的时候还是需要发送http请求，但是一旦升级成功，就不是http了</p><p>但是SSE仍然是基于http的，只不过他的Content-Type字段是text&#x2F;event-stream</p><p>你可以理解为，客户端请求一次后，http连接一直保持，并且服务端分多次响应</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201421537.png" alt="img" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆数据结构实现</title>
    <link href="/2024/07/15/%E5%85%AB%E8%82%A1/2024-07-15-%E5%A0%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/07/15/%E5%85%AB%E8%82%A1/2024-07-15-%E5%A0%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="堆数据结构实现"><a href="#堆数据结构实现" class="headerlink" title="堆数据结构实现"></a>堆数据结构实现</h1><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407151142292.png" alt="堆的表示与存储" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//小顶堆实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> [] arr;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Heap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span>&#123;<br>        arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [capacity];<br>        <span class="hljs-built_in">this</span>.capacity=capacity;<br>        <span class="hljs-built_in">this</span>.size=<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">left</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*index+<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parent</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>        <span class="hljs-keyword">return</span> (index-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> size&lt;=<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> temp=arr[i];<br>        arr[i]=arr[j];<br>        arr[j]=temp;<br>    &#125;<br><br>    <span class="hljs-comment">//插入后，将堆尾元素上浮</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-comment">//跟根元素比较，如果发现自己更小，就跟根元素交换</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> parent(pos);<br><br>            <span class="hljs-comment">//直到上浮到堆首，或者不用上浮了</span><br>            <span class="hljs-keyword">if</span>(parent&lt;<span class="hljs-number">0</span>||arr[parent]&lt;=arr[pos])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            swap(parent,pos);<br>            pos=parent;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//插入后，将堆顶元素沉底</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pos&lt;size)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftIndex</span> <span class="hljs-operator">=</span> left(pos);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rightIndex</span> <span class="hljs-operator">=</span> right(pos);<br><br>            <span class="hljs-comment">//如果没有左子树，那就说明更没有右子树了，直接结束沉底</span><br>            <span class="hljs-keyword">if</span>(leftIndex&gt;=size)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果没有右子树，那就说明只有左子树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rightIndex&gt;=size)&#123;<br><br>                <span class="hljs-comment">//发现根元素已经比左子树小了，那就结束沉底</span><br>                <span class="hljs-keyword">if</span>(arr[pos]&lt;=arr[leftIndex])&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//不然，就要将根元素和左子树交换</span><br>                swap(pos,leftIndex);<br>                pos=leftIndex;<br>            &#125;<br>            <span class="hljs-comment">//左右子树都存在的情况</span><br>            <span class="hljs-keyword">else</span>&#123;<br><br>                <span class="hljs-comment">//如果根元素比其他两个都要小，那就结束沉底</span><br>                <span class="hljs-keyword">if</span>(arr[pos]&lt;=Math.min(arr[leftIndex],arr[rightIndex]))&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//左边更小就跟左边换，右边更小，就跟右边换，保证换过后根元素比左右子树都要小</span><br>                <span class="hljs-keyword">if</span>(arr[leftIndex]&lt;=arr[rightIndex])&#123;<br>                    swap(pos,leftIndex);<br>                    pos=leftIndex;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    swap(pos,rightIndex);<br>                    pos=rightIndex;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-type">int</span> item)</span>&#123;<br>        <span class="hljs-keyword">if</span>(size==capacity)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Heap is full!&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//往堆尾插一个元素</span><br>        arr[size]=item;<br>        <span class="hljs-comment">//然后整理堆，将堆尾元素上浮</span><br>        siftUp(size);<br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Heap is empty!&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//先将堆顶元素和堆尾交换，然后弹出堆尾元素</span><br>        swap(<span class="hljs-number">0</span>,size-<span class="hljs-number">1</span>);<br>        size--;<br>        <span class="hljs-comment">//将堆顶元素沉底</span><br>        siftDown();<br>        <span class="hljs-keyword">return</span> arr[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相交链表</title>
    <link href="/2024/07/14/%E5%88%B7%E9%A2%98/2024-07-14/2024-07-14-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/07/14/%E5%88%B7%E9%A2%98/2024-07-14/2024-07-14-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这题简单粗暴的就是hash表查重，但是这里要介绍一个双指针的方法</p><p>这个相交的交点以后就是，我们不管遍历那个链表都是相同节点，换句话说，我们从尾巴往前遍历，最后一个相同的节点就是交点，当然这对于单向链表来说是不现实的</p><p>但我们可以换个思路，我们从相同的长度开始往后找，第一个一样的不就是交点了吗，那也就是说再往后遍历之前，我们需要将较长的那个链表的起点对齐到较短链表的长度那，然后往后找</p><p>具体方法就是双指针，先同时向后，然后较短链表肯定先到尾，这时候，我们将先到尾的指针指向另一个链表的开头，然后继续往后，此时原本的较长链表的指针到尾指针的距离正好就是两个链表长度的差值</p><p>紧接着继续往后找的话，较长链表的指针也会到尾，这时候再将该指针指向另一个链表，此时这两个指针就对齐了</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>        ListNode pA=headA;<br>        ListNode pB=headB;<br><span class="hljs-comment">//只要没发现相同的节点，就一直倒换指针</span><br>        <span class="hljs-comment">//倒换两次就会结束，也就是说，每个链表只会遍历两次</span><br>        <span class="hljs-comment">//第一次对齐，第二次查找</span><br>        <span class="hljs-keyword">while</span>(pA!=pB)&#123;<br>            <span class="hljs-keyword">if</span>(pA==<span class="hljs-literal">null</span>)&#123;<br>                pA=headB;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pA=pA.next;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(pB==<span class="hljs-literal">null</span>)&#123;<br>                pB=headA;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pB=pB.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-14 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并 K 个升序链表</title>
    <link href="/2024/07/14/%E5%88%B7%E9%A2%98/2024-07-14/2024-07-14-%E5%90%88%E5%B9%B6%20K%20%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/07/14/%E5%88%B7%E9%A2%98/2024-07-14/2024-07-14-%E5%90%88%E5%B9%B6%20K%20%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="合并-K-个升序链表"><a href="#合并-K-个升序链表" class="headerlink" title="合并 K 个升序链表"></a>合并 K 个升序链表</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K 个升序链表</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这题基本思路和合并两个有序链表类似，但是具体就是，每次向新链表插入，应该选k个链表中最小的那个</p><p>这个没法像两个有序链表那样，直接比较，因为如果这样直接比较，那时间复杂度是O(k)，再加上会插入kn次，最终时间复杂度是$O(nk^2)$，这是不能接受的</p><p>那么我们可以通过top k的思想，使用优先队列，先将k个队列的头放进去，然后从里面poll出最小的，然后如果poll的节点的next不是null，再把其next重新offer到优先队列里面去</p><p>这样重复做，直至优先队列空了</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">//返回结果链表的虚拟头节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        ListNode p=root;<br>        <br>        <span class="hljs-comment">//由于优先队列的元素是ListNode，因此需要自定义比较器</span><br>        Comparator&lt;ListNode&gt; cmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;ListNode&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(ListNode e1, ListNode e2)</span> &#123;<br>                <span class="hljs-keyword">return</span> e1.val-e2.val;<br>            &#125;<br>        &#125;;<br>        Queue&lt;ListNode&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(cmp);<br><br>        <span class="hljs-comment">//将每个链表的头指针放进去</span><br>        <span class="hljs-keyword">for</span>(ListNode head:lists)&#123;<br>            <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            q.offer(head);<br>        &#125;<br>       <span class="hljs-comment">//循环至优先队列空</span><br>        <span class="hljs-keyword">while</span>(!q.isEmpty())&#123;<br>            ListNode node=q.poll();<br>            p.next=node;<br>            p=p.next;<br>            <span class="hljs-comment">//如果没有到链表尾，就将其next放进去</span><br>            <span class="hljs-keyword">if</span>(node.next!=<span class="hljs-literal">null</span>)&#123;<br>                q.offer(node.next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-14 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长递增子序列</title>
    <link href="/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这题一看就是dp，我们用<code>dp[i]</code>表示：以第i个数字结尾的最长递增子序列，然后最后，我们遍历dp取最大值就好了</p><p>那么状态转移方程为：<br>$$<br>dp[i]&#x3D;max(dp[j]+1), \quad num[i]&gt;num[j] \quad &amp;&amp;\quad 0&lt;j&lt;i\<br>res&#x3D;max(dp[i]),\quad0\le i&lt;n<br>$$<br>就是遍历前面的所有子序列，看看第i个数和哪个数挨着组成的递增子序列最长，然后遍历dp数组</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> []dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            dp[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])&#123;<br>                    dp[i]=Math.max(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            res=Math.max(dp[i],res);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-12 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><strong>Problem:<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这个可以采用递归的算法，该函数返回的就是p、q的父节点</p><p>我们递归左边和右边，如果发现左边是p、q的父节点并且右边也是，那就说明p、q各在一边，那么当前节点就是最近的公共祖先，直接返回当前节点</p><p>这个找到后，递归往上传，只会出现一边有而一边没有的情况，因为公共祖先只是它父节点的一边，另一边一定找不到p、q，因此返回null</p><p>所以，当发现一边有值而一边没值的情况，那就直接返回有值的那个结果，因为这说明最近公共祖先已经找到了</p><p>如果发现都是null，那就返回null，如果发现当前节点就是p或者q，那就把自己传上去，其结果一定会汇总到公共祖先那，<strong>成为第一个发现左右都不是null的节点</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;<br>        <span class="hljs-comment">//发现是自己，直接返回</span><br>        <span class="hljs-keyword">if</span>(root==p||root==q)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-comment">//初始化左右dfs的结果</span><br>        TreeNode left=<span class="hljs-literal">null</span>,right=<span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-comment">//左树不为空，则dfs左树</span><br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)&#123;<br>            left=lowestCommonAncestor(root.left,p,q);<br>        &#125;<br>        <span class="hljs-comment">//右树不为空，则dfs右树</span><br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)&#123;<br>            right=lowestCommonAncestor(root.right,p,q);<br>        &#125;<br><br>        <span class="hljs-comment">//发现左右dfs结果都不为空，那么当前节点就是最近公共祖先，返回自己</span><br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>&amp;&amp;right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br><span class="hljs-comment">//接下来，不会出现二者都不为空的情况了</span><br>        <br>        <span class="hljs-comment">//左树不为空，则返回左树</span><br>        <span class="hljs-keyword">if</span>(left!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br><br>        <span class="hljs-comment">//右树不为空，返回右树</span><br>        <span class="hljs-keyword">if</span>(right!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <br>        <span class="hljs-comment">//最后，全是空，直接返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-12 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表 II</title>
    <link href="/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>基本思路就是：找到要反转的那一段，然后反转，并修改连接处的指针</p><p>为了修改连接处的指针，我们需要保存四个点：反转部分的start和end，然后反转部分左端点的pre以及反转部分右端点相连的next</p><p>并且，为了保证操作的普适性，我们加入了一个虚拟头节点，防止整个链表反转时候，返回的链表头节点不是原头节点，由于虚拟头节点不会进入反转范围，因此反转后我们可以一视同仁的修改链表连接处的next指针，然后返回虚拟头节点的next</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">//虚拟头节点</span><br>        ListNode temp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        temp.next=head;<br>        head=temp;<br><br>        ListNode p=head;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//找左端点以及左端点的前一个端点</span><br>        <span class="hljs-keyword">while</span>(count&lt;left-<span class="hljs-number">1</span>&amp;&amp;p!=<span class="hljs-literal">null</span>)&#123;<br>            p=p.next;<br>            count++;<br>        &#125;<br>        ListNode pre=p;<br>        ListNode start=pre.next;<br>        <br><span class="hljs-comment">//找右端点以及右端点的后一个端点</span><br>        <span class="hljs-keyword">while</span>(count&lt;right&amp;&amp;p!=<span class="hljs-literal">null</span>)&#123;<br>            p=p.next;<br>            count++;<br>        &#125;<br>        ListNode end=p;<br>        ListNode next=p.next;<br><br>        <span class="hljs-comment">//反转链表</span><br>        reverse(start,end);<br>        <span class="hljs-comment">//修改连接处指针变化</span><br>        pre.next=end;<br>        start.next=next;<br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br><br>    <span class="hljs-comment">//反转链表函数，就是以前的那个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode start, ListNode end)</span>&#123;<br>        ListNode pre=<span class="hljs-literal">null</span>;<br>        ListNode cur=start;<br>        <span class="hljs-keyword">while</span>(cur!=end)&#123;<br>            ListNode next=cur.next;<br>            cur.next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        cur.next=pre;<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-12 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的锯齿形层序遍历</title>
    <link href="/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层序遍历</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-12 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岛屿数量</title>
    <link href="/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/number-of-islands">岛屿数量</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这个就是典型的dfs，看到当前为1并且没有mark过，我们就进去dfs，四个方向全跑一遍</p><p>dfs过程中，我们要更新mark数组，把遍历过的1全部标记为true</p><p>在main函数中，每进去dfs一次，就会把联通的1全标记了，那么每次dfs就说明有一个联通的区域即岛屿</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//标记数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> [][] mark;<br>    <span class="hljs-comment">//将grid转为全局的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> [][] grid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> m;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-comment">//初始化成员变量</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        n=grid.length;<br>        m=grid[<span class="hljs-number">0</span>].length;<br>        mark=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][m];<br>        <span class="hljs-built_in">this</span>.grid=grid;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-comment">//发现为1且没有mark，则是一个新的岛屿，进去dfs，把联通的1全标记了</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;!mark[i][j])&#123;<br>                    dfs(i,j);<br>                    res++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-comment">//如果i、j不合法，即到头了，那就返回，或者发现已经遍历过了或者不是1的格子也返回</span><br>        <span class="hljs-keyword">if</span>(i&gt;=n||i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||j&gt;=m||mark[i][j]||grid[i][j]!=<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mark[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//遍历上下左右四个方向</span><br>        dfs(i,j+<span class="hljs-number">1</span>);<br>        dfs(i,j-<span class="hljs-number">1</span>);<br>        dfs(i+<span class="hljs-number">1</span>,j);<br>        dfs(i-<span class="hljs-number">1</span>,j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-12 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2024/07/12/%E5%88%B7%E9%A2%98/2024-07-12/2024-07-12-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/spiral-matrix/">螺旋矩阵</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>我们可以使用count记录个数，一旦到了n*m个就说明遍历完了，然后返回res</p><p>在遍历过程中，我们需要判断是否需要转向：col、row是否超出边界，或者验证当前方向下一个是否遍历过了</p><p>因此我们需要维护两个东西：</p><ul><li>mark矩阵，记录遍历记录</li><li>direction以及index，记录当前的遍历方向</li></ul><p>一旦发现需要转向，就让<code>(index+1)%4</code>，实现螺旋遍历，并且directions数组的方向顺序为右、下、左、上</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> m;<br>    <br>    <span class="hljs-comment">//方向</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] directions=&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-comment">//matrix信息转为全局</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] matrix;<br>    <span class="hljs-comment">//mark标记矩阵</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span>[][] mark;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <br>        <span class="hljs-comment">//初始化成员变量</span><br>        n=matrix.length;<br>        m=matrix[<span class="hljs-number">0</span>].length;<br><br>        mark=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][m];<br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.matrix=matrix;<br><br><br>        <span class="hljs-type">int</span> row=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> directionIndex=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n*m;i++)&#123;<br>            res.add(matrix[row][col]);<br>            mark[row][col]=<span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">//产生下一步需要更新的变化量</span><br>            <span class="hljs-type">int</span> changeRow=directions[directionIndex][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> changeCol=directions[directionIndex][<span class="hljs-number">1</span>];<br>            <br>            <span class="hljs-comment">//如果转向检查通过，则继续遍历</span><br>            <span class="hljs-keyword">if</span>(check(row+changeRow,col+changeCol))&#123;<br>                row+=changeRow;<br>                col+=changeCol;<br>            &#125;<br>            <span class="hljs-comment">//如果转向检查不通过，则转向</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                directionIndex=(directionIndex+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>                row+=directions[directionIndex][<span class="hljs-number">0</span>];<br>                col+=directions[directionIndex][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">////如转向检查不通过，则转向</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span>&#123;<br>        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||row&gt;n-<span class="hljs-number">1</span>||col&lt;<span class="hljs-number">0</span>||col&gt;m-<span class="hljs-number">1</span>||mark[row][col])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-12 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序数组</title>
    <link href="/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/sort-an-array/">排序数组</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>就是那几个$O(n\log n)$的排序算法：快速排序、堆排序、归并排序</p><p>那么我们就实现一下快速排序，其他的后面慢慢做</p><p>快排的基本思路就不讲了，我们来讲一讲partition函数的思想：</p><p>为了保证快排的稳定性，我们选择随机基准元素，然后如何让左边都小，右边都大呢</p><p>我们先将随机的基准元素换到最左边，然后双指针指向数组的l和r处</p><p>先从右向左找到第一个比base小的数，然后和l交换，并且l++</p><p>然后再从做向右找到第一个比base大的数，然后和r交换，并且r++</p><p>也就是说，我们用base临时变量保存左边第一个数，从而空出一个位置让剩下的数字移动</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-comment">//快排</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-comment">//发现就一个数字或者数组左右指针错过，那就返回</span><br>        <span class="hljs-keyword">if</span>(l&gt;=r)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//先分割，然后递归快排</span><br>        <span class="hljs-type">int</span> pos=partition(nums,l,r);<br>        quickSort(nums,l,pos-<span class="hljs-number">1</span>);<br>        quickSort(nums,pos+<span class="hljs-number">1</span>,r);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<br>        <span class="hljs-comment">//随机基准元素</span><br>        Random random=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">int</span> pos=random.nextInt(r-l+<span class="hljs-number">1</span>)+l;<br>        swap(nums,pos,l);<br>        <span class="hljs-comment">//拿出基准元素，并且空出l位置，作为临时的缓冲区</span><br>        <span class="hljs-type">int</span> base=nums[l];<br>        <span class="hljs-type">int</span> i=l;<br>        <span class="hljs-type">int</span> j=r;<br>        <br>        <span class="hljs-comment">//循环，直至左右指针相遇</span><br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-comment">//先从右向左找，因为空出来的是左边元素，需要先将右边第一个不符合的元素移到左边</span><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; base) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//右边第一个元素移到左边，此时空出来的位置变成了j位置</span><br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                nums[i++] = nums[j];<br>            &#125;<br>            <span class="hljs-comment">//由于空出来右边的位置，再从左向右找，找到左边的不符合的数，然后换到右边的位置</span><br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt; base) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-comment">//左边第一个不符合的元素移到右边，此时空出来的位置变成了i位置</span><br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                nums[j--] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最终i和j相遇，然后将相遇的地方改为base</span><br>        nums[i]=base;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> temp=nums[i];<br>        nums[i]=nums[j];<br>        nums[j]=temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-11 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>由于时间复杂度是O(log n)，因此肯定是用二分来做</p><p>这个我们需要明白旋转后数组的特性，旋转后数组的方式不是左边的样子，而是右边的样子：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407111816938.png" alt="image-20240711181631670" style="zoom:40%;" /><p>我们二分以后，必然是将数组分为两个序列，并且<strong>一个有序一个无序</strong></p><p>我们可以通过target和两个序列的边界判断他是否在有序中那一半中</p><p>判断序列有序，就是看数组的边界nums[0]、nums[n-1]和nums[mid]的大小</p><p>如果左边有序则<code>nums[0]&lt;=nums[mid]</code>，反之则<code>nums[mid]&lt;nums[n-1]</code></p><blockquote><p><strong>为什么不那l、r来和mid比而是那0、n-1和mid比？</strong></p><p>因为mid很有可能正好在那个旋转点上，那么这两个序列恰好都是有序的</p><p>拿0、n-1这两个固定边界判断，更精准不会出问题</p></blockquote><p>如果target在有序序列范围中，那就直接在有序中分，否则去无序中继续找有序</p><p>这个思路比较难理解，我们要根据<strong>上述的图</strong>来进行思考！</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> r=n-<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//开始二分</span><br>        <span class="hljs-keyword">while</span>(l&lt;=r)&#123;<br>            <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-comment">//找到target直接返回</span><br>            <span class="hljs-keyword">if</span>(nums[mid]==target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>            <br>            <br><span class="hljs-comment">//左边序列有序</span><br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&lt;=nums[mid])&#123;<br>                <span class="hljs-comment">//在有序序列范围内，则去左边有序序列找</span><br>                <span class="hljs-keyword">if</span>(nums[l]&lt;=target&amp;&amp;target&lt;nums[mid])&#123;<br>                    r=mid-<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//不在，则去右边无序序列找</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    l=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//右边序列有序</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//在有序序列范围内，则去右边有序序列找</span><br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[r])&#123;<br>                   l=mid+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">////不在，则去z边无序序列找</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    r=mid-<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-11 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子串</title>
    <link href="/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p><strong>Problem:<a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这题也是DP做，<code>dp[i][j]</code>表示substring(i,j)子串是否为回文子串</p><p>那么，只有两种情况，当i和j的字符相等并且substring(i+1,j-1)是回文子串的时候，<code>dp[i][j]</code>为true</p><p>否则为false，状态转移方程写为：<br>$$<br>dp[i][j]&#x3D;(s[i]&#x3D;&#x3D;s[j])&amp;&amp; (dp[i+1][j-1]||(i+1\ge j-1))<br>$$<br>为什么有后面这一个东西呢：这个东西避免了当前字符长度为1和2的情况</p><p>最后，由于<code>dp[i][j]</code>和i+1、j-1有关，我们不能从左到右dp</p><p>应该第一层从右到左，第二层从左到右</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> n=s.length();<br>        <span class="hljs-type">boolean</span> [][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n][n];<br><br>        <span class="hljs-comment">//记录结果</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//从右向左dp</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//状态转移方程</span><br>                <span class="hljs-keyword">if</span>(s.charAt(i)==s.charAt(j)&amp;&amp;(dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]|| i+<span class="hljs-number">1</span>&gt;=j-<span class="hljs-number">1</span>))&#123;<br>                    dp[i][j]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">//如果发现当前子串是，那就更新一下最大的子串长度和起始位置</span><br>                    <span class="hljs-keyword">if</span>(res&lt;j-i+<span class="hljs-number">1</span>)&#123;<br>                        res=j-i+<span class="hljs-number">1</span>;<br>                        start=i;<br>                    &#125;<br>                    <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(start,start+res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-11 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子数组和</title>
    <link href="/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这题很简单，就是用dp，<code>dp[0]</code>就是第一个数，<code>dp[i]</code>表示以第i个数结尾的连续子串的最大和</p><p>那么其实<code>dp[i]</code>只有两种情况，就是第i个数单独成串，或者和第i-1个数组成连续串</p><p>那么状态转移方程可以写成：<br>$$<br>dp[i]&#x3D;max(dp[i-1]+nums[i],nums[i])<br>$$</p><p>此外，我们还可以通过滚动数组来降低空间复杂度，因为<code>dp[i]</code>只和<code>dp[i-1]</code>有关</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> n=nums.length;<br>        <span class="hljs-comment">//初始化dp，使用滚动数组</span><br>        <span class="hljs-type">int</span> dp=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//res记录过程中最大的结果</span><br>        <span class="hljs-type">int</span> res=nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//更新dp和res</span><br>            dp=Math.max(dp+nums[i],nums[i]);<br>            res=Math.max(dp,res);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-11 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和</title>
    <link href="/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/07/11/%E5%88%B7%E9%A2%98/2024-07-11/2024-07-11-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/3sum/">三数之和</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>首先，基本思想就是：枚举每一个数，然后对于剩下的数就是给定target的两数之和</p><p>为保证三元组的不可重复，需要将数组排序，然后一旦发现当前数和前面的数相同，就直接跳过，因为对于同一个target，三元组肯定是一样的</p><p>其次，如果是暴力两数之和，那就是$O(n^3)$的时间复杂度，为此，我们使用双指针，分别指向target的后面以及数组末尾</p><p>如果发现当前双指针指向的两个数之和大于target，那右边的指针就要向左走；反之，左指针向右走</p><p>如果发现一样，那就是三元组结果</p><p>当然为防止三元组重复，我们在双指针的时候，也需要判断，双指针指向的数前面是否遍历过，遍历过则直接跳过</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> n=nums.length;<br>        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right=n-<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> target=-nums[i];<br><br>            <span class="hljs-comment">//发现遍历过，直接continue</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i-<span class="hljs-number">1</span>]==nums[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-type">int</span> num=nums[left]+nums[right];<br>                <span class="hljs-comment">//发现左指针的数遍历过，直接continue</span><br>                <span class="hljs-keyword">if</span>(left&gt;i+<span class="hljs-number">1</span>&amp;&amp;nums[left]==nums[left-<span class="hljs-number">1</span>])&#123;<br>                    left++;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//发现右指针的数遍历过，直接continue</span><br>                <span class="hljs-keyword">if</span>(right&lt;n-<span class="hljs-number">1</span>&amp;&amp;nums[right]==nums[right+<span class="hljs-number">1</span>])&#123;<br>                    right--;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-comment">//小于target，则左指针右移</span><br>                <span class="hljs-keyword">if</span>(num&lt;target)&#123;<br>                    left++;<br>                &#125;<br>                <span class="hljs-comment">//大于target，则右指针左移</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num&gt;target)&#123;<br>                    right--;<br>                &#125;<br>                <span class="hljs-comment">//找到目标三元组，加入res，然后双指针同时更新</span><br>                <span class="hljs-keyword">else</span>&#123;<br>                    List&lt;Integer&gt; ans=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                    ans.add(-target);<br>                    ans.add(nums[left]);<br>                    ans.add(nums[right]);<br>                    res.add(ans);<br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-11 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组两端取数</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E6%95%B0%E7%BB%84%E4%B8%A4%E7%AB%AF%E5%8F%96%E6%95%B0/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E6%95%B0%E7%BB%84%E4%B8%A4%E7%AB%AF%E5%8F%96%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数组两端取数"><a href="#数组两端取数" class="headerlink" title="数组两端取数"></a>数组两端取数</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/predict-the-winner/">预测赢家</a></strong></p><p><strong>Problem: <a href="https://leetcode.cn/problems/stone-game/">石子游戏</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>这个就是用dp来做，<code>dp[i][j]</code>表示从i到j第一个取数的玩家可以得到最大值</p><p>为什么说是第一个取数的玩家，而不是玩家一，因为在dp过程中，不一定第一个取数的就是玩家一</p><p>对于dp转移方程可以写出：<br>$$<br>dp[i][j]&#x3D;max(sum(i+1,j)-dp[i+1][j]+arr[i],sum(i,j-1)-dp[i][j-1]+arr[j])<br>$$<br>意思就是，对于当前数组，我取左边和取右边两种方式的最大值</p><p>当我拿了某一边后，由于我拿了，那么我就不是先手了，那我后面能拿的就是剩下的数组和减掉可以取的最大值</p><p>因为作为后手玩家，采取的策略肯定也是剩下数组的最大值，那我后面能拿到的不就是剩下的石子吗？</p><p>由于涉及的数组求和，因此需要用前缀和实现求和</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> n=arr.length;<br>        <span class="hljs-type">int</span>[]sum=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-type">int</span> [][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br><br>        <span class="hljs-comment">//初始化前缀和以及dp数组，当只有一个的时候，那我肯定直接拿，因此dp[i][i]就是arr[i]</span><br>        sum[<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            sum[i]=arr[i]+sum[i-<span class="hljs-number">1</span>];<br>            dp[i][i]=arr[i];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-comment">//两个方式，从左边拿和从右边拿</span><br>                <span class="hljs-type">int</span> sum1=arr[i]+sum[j]-sum[i]-dp[i+<span class="hljs-number">1</span>][j];<br>                <br>                <span class="hljs-comment">//从右边拿需要加一个特殊判断</span><br>                <span class="hljs-comment">//如果当前i是最左边就不需要sum[j-1]-sum[i-1]，直接就是sum[j-1]</span><br>                <span class="hljs-type">int</span> sum2=arr[j]+sum[j-<span class="hljs-number">1</span>]-dp[i][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>                    sum2-=sum[i-<span class="hljs-number">1</span>];<br>                &#125;<br>                <br>                dp[i][j]=Math.max(sum1,sum2);<br>            &#125;<br>        &#125;<br>        <br><span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n-<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">//若是判断玩家一是否可以获胜，不要把sum/2，而是结果*2的比较</span><br>        <span class="hljs-comment">//return dp[0][n-1]*2 &gt; sum[n-1]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-10 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">K个一组翻转链表</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>基本思路很简单，就是你把每一组找出来，然后反转每一组的链表就好了</p><p>但是每一组反转了，各个组之间的next关系也得改正：</p><ul><li>该组反转了后，上一组的最后一个应该指向反转后的第一个</li></ul><p>这里我们采用递归的方法，reverseKGroup函数返回的是给定数组反转后的头部，我们只需要反转当前组，然后将反转后的最后一个节点的next指向反转后面链表的头就好了</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode p=head;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">//找当前链表的第一组，也就是前K个节点</span><br>        <span class="hljs-keyword">while</span>(p.next!=<span class="hljs-literal">null</span>&amp;&amp;count&lt;k)&#123;<br>            p=p.next;<br>            count++;<br>        &#125;<br>        <br>        <span class="hljs-comment">//如果发现当前链表个数少于K个就不反转，直接返回head</span><br>        <span class="hljs-keyword">if</span>(count&lt;k)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        <br>        <span class="hljs-comment">//反转当前的K节点链表，也是使用prev，next、cur指针实现</span><br>        ListNode node=head;<br>        ListNode prev=<span class="hljs-literal">null</span>;<br>        ListNode tailNext=p.next;<br><br>        <span class="hljs-comment">//但是while的break条件是该组结束，也就是遍历到当前组最后一个节点的next的时候就会结束</span><br>        <span class="hljs-comment">//p节点由于是while循环出来的，因此p当前指向的就是当前组的最后一个节点</span><br>        <span class="hljs-keyword">while</span>(node!=tailNext)&#123;<br>            ListNode next=node.next;<br>            node.next=prev;<br>            prev=node;<br>            node=next;<br>        &#125;<br><br>        <span class="hljs-comment">//head反转后是最后一个节点，它指向反转后继链表后的头节点</span><br>        head.next=reverseKGroup(tailNext,k);<br><br>        <span class="hljs-comment">//返回当前组反转后的头节点，也就是原本的最后一个节点 ———— p节点</span><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-10 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的第K个最大元素</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第K个最大元素</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>很简单，要实现O(n)的复杂度，那就<strong>桶排序</strong>了，因为题目给了num的范围在-10000到10000之间</p><p>我们只需要加一个基准量，将数字映射到0-20000之间就好了</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">//基准量</span><br>        <span class="hljs-type">int</span> BASE_NUM=<span class="hljs-number">15000</span>;<br><br>        <span class="hljs-comment">//记录每个数量</span><br>        <span class="hljs-type">int</span> [] bucket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">30000</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;<br>            <span class="hljs-comment">//防止num为负数的时候，数组下标为负数</span><br>            bucket[num+BASE_NUM]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bucket.length-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            k-=bucket[i];<br>            <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> i-BASE_NUM;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-10 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU缓存</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-LRU%20%E7%BC%93%E5%AD%98/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-LRU%20%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/lru-cache/">LRU缓存</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用双向链表加hashMap实现</p><p>双向链表实现LRU顺序的维护，map实现O(1)时间复杂度的查找</p><ul><li><p>get函数：</p><ul><li>如果map中有，那就将该节点移到队头，然后返回</li><li>没有就返回-1</li></ul></li><li><p>put函数</p><ul><li>如果map中有，那就将该节点移到队头，然后修改node的value值返回</li><li>没有的的话：创建新节点，size++并放到map以及队头中；如果操作完成后发现容量超了，那就移除队尾元素。由于需要两个方向的入队出队操作，因此需要双向链表</li></ul></li><li><p>两个trick：</p><ul><li><p>将节点移到队头可以分为删除节点，添加节点到队头两个操作；移除队尾节点，就是移除节点</p><p>因此，可以写两个函数offer和remove，来封装这两个操作</p></li><li><p>为了保证这两个操作的普适性，我们使用虚拟的头尾节点</p></li></ul></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-comment">//双向链表节点内部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> key;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> val;<br>        <span class="hljs-keyword">public</span> ListNode prev;<br>        <span class="hljs-keyword">public</span> ListNode next;<br>    &#125;<br>    ListNode head;<br>    ListNode tail;<br><br>    <span class="hljs-comment">//hashMap，key就是get的key，value是链表的节点</span><br>    Map&lt;Integer,ListNode&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> capacity;<br><br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity=capacity;<br>         <span class="hljs-comment">//初始化，头尾使用虚拟节点</span><br>        head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        tail=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        head.next=tail;<br>        tail.prev=head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        ListNode node=map.get(key);<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//发现存在，从原位置移除当前节点，在将该节点放到队头</span><br>            remove(node);<br>            offer(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>        ListNode node=map.get(key);<br>        <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">null</span>)&#123;<br>            node.val=value;<br>            <span class="hljs-comment">//发现存在，从原位置移除当前节点，在将该节点放到队头</span><br>            remove(node);<br>            offer(node);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        node=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        node.key=key;<br>        node.val=value;<br>        map.put(key,node);<br>        offer(node);<br>        size++;<br><br>        <span class="hljs-keyword">if</span>(size&gt;capacity)&#123;<br>            <span class="hljs-comment">//移除队尾的节点，由于是虚拟尾节点，因此实际移除的是尾节点的prev</span><br>            map.remove(tail.prev.key);<br>            remove(tail.prev);<br>            size--;<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-comment">//移除操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        node.prev.next=node.next;<br>        node.next.prev=node.prev;<br>    &#125;<br><br>    <span class="hljs-comment">//往队头添加节点的操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(ListNode node)</span>&#123;<br>        node.next=head.next;<br>        node.prev=head;<br>        head.next.prev=node;<br>        head.next=node;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-10 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/reverse-linked-list/description/">反转链表</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>我们只需要简单粗暴的将当前元素的next指针指向prev节点就好了</p><p>但是这里为了保证数组能继续遍历，并且可以获取prev节点，我们需要两个指针来分别保存prev和next</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//如果链表为空直接返回</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    <span class="hljs-comment">//三个指针，p表示当前节点，prev表示p的前驱，next表示p的后继</span><br>        ListNode p=head;<br>        ListNode prev=<span class="hljs-literal">null</span>;<br>        ListNode next=p.next;<br>        <br>        <span class="hljs-comment">//只要p的后继不是空，那就让p的next指向prev，然后三个指针各往后挪一步</span><br>        <span class="hljs-keyword">while</span>(next!=<span class="hljs-literal">null</span>)&#123;<br>            p.next=prev;<br>            prev=p;<br>            p=next;<br>            next=next.next;<br>        &#125;<br>        <span class="hljs-comment">//当遍历到最后，将最后一个节点的next指向前驱就好了</span><br>        p.next=prev;<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-10 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/07/10/%E5%88%B7%E9%A2%98/2024-07-10/2024-07-10-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长子串</a></strong></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>双指针实现滑动窗口，并且使用hashMap记录滑动窗口中的字符遍历情况，注意滑动窗口变换的时候，hashMap也也要变化</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        Map&lt;Character,Boolean&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> [] str=s.toCharArray();<br>        <span class="hljs-type">int</span> n=str.length;<br>        <br>        <span class="hljs-comment">//记录当前的最大长度，right每加一次就要更新一下</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">while</span>(right&lt;n)&#123;<br>            <span class="hljs-keyword">while</span>(map.getOrDefault(str[right],<span class="hljs-literal">false</span>))&#123;<br>                <span class="hljs-comment">//当map中发现该char已经遍历过，左边指针移动，直到弹出和右边界冲突的那个char</span><br>                map.put(str[left],<span class="hljs-literal">false</span>);<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//将右指针的字符入map，并且更新右边界</span><br>            map.put(str[right],<span class="hljs-literal">true</span>);<br>            res=Math.max(res,right-left+<span class="hljs-number">1</span>);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-07-10 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2024/07/07/%E5%85%AB%E8%82%A1/2024-07-07-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/07/07/%E5%85%AB%E8%82%A1/2024-07-07-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Operation-System"><a href="#Operation-System" class="headerlink" title="Operation System"></a>Operation System</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>OS中存储器的层次如下：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006494.png" alt="img" style="zoom:67%;" /><p>当CPU取数据的时候，会依次按照上述顺序查看缓存是否存在，如果存在则立即加载，否则就会走到最后从硬盘中拿数据，具体架构如下：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006889.png" alt="img" style="zoom: 50%;" /><h3 id="CPU层面的性能优化"><a href="#CPU层面的性能优化" class="headerlink" title="CPU层面的性能优化"></a>CPU层面的性能优化</h3><p>很经典的就是数组的行优先还是列优先，还有循环展开，使得最大程度上的cache复用</p><blockquote><p>循环展开就是，将100个轮回的循环分为n次，每次循环100&#x2F;n个计算，这样我们每次计算可以选择不同缓存行的数据，可以认为是并发访问</p></blockquote><p>还有其他的比较特殊的优化：</p><ul><li><p><strong>多核的线程切换问题</strong></p><p>从上图可以看出，对于多核CPU来说，L3是共享的，但是L1和L2是每个核私有的</p><p>因此，如果对于某个计算密集型线程，每次都会命中L1，那么我们可以固定其运行的CPU核，保证L1可以命中，而不是每次切换发现L1都没有，然后又要去内存中记载进来</p></li><li><p><strong>if-else</strong>的代码缓存问题</p><p>如果分支结果可以预测，那么可以判断if会用的比较多，else的情况比较少，那么就可以将if的指令数据放到L1中，访问更快</p><p>比如，对于乱序数组和排序好的数组，如果有一个<code>if(arr[i]&lt;100)</code>的循环判断，那么对于排序好的数组可以进行分支预测，因为肯定在某个i后都是大于100的</p><p>而对于乱序数组，我们无法判断，因此无法充分利用L1</p></li></ul><h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>既然使用了缓存，那肯定有缓存的一致性问题，也就是内存和缓存如何保证数据一致的？</p><p>对于单核场景下很简单，就是十分经典的两种方式：</p><ul><li>修改Cache的时候，同时也修改内存（<strong>双写</strong>）</li><li>修改Cache的时候先不修改内存，而是标记该Cache行，等到换出的时候在写回去（<strong>延迟写</strong>）</li></ul><p>对于<strong>多核场景</strong>就麻烦了，一致性的难度也就体现在这个地方</p><p>首先来看看问题，对于并发场景由于每个核都有自己的L1和L2，那么对于同一块内存区域如果都有写操作，但是线程一还没来的及写回内存，旧数据就被线程二读走了，去自己的L1里面修改</p><p>那么这两次写操作，最终只会有一个生效，这肯定是无法容忍的！</p><p>如何解决这个问题，那就是java并发编程里面，我提到的<strong>总线嗅探+MESI</strong>了</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>我们先来看看，要解决这个问题我们要实现什么：</p><ul><li><p><strong>写事件的传播</strong></p><p>当对于某块内存区域写的时候，我们需要通知别的核，这个地方被修改了</p></li><li><p><strong>事务串行化</strong></p><p>如果两次写事件的通知到达不同核的顺序恰好是相反的，那么也会导致数据的不一致问题</p><p>因此，让别的核对于同一块区域的写操作，看起来是串行化的，也是一个问题</p></li></ul><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><ul><li><p><strong>写事件的传播</strong></p><p>这个问题解决放式就是总线嗅探了，每当有核修改了Cache，就会向总线广播一条信息</p><p>其他的核都会监听总线，如果发现写事件的位置自己的cache也有，那就修改</p><p>这就实现了事件传播</p></li><li><p><strong>事务串行化</strong></p><p>虽然总线嗅探实现了事件传播，但是事务串行化怎么保证呢？</p><p>解决方法就是MESI协议了，MESI协议将每个cache行的状态分为了四种：Modified、Exclusive、Shared、Invalidate</p><ul><li><p>Modified表示脏数据行，自己修改了但是还没写回</p></li><li><p>Exclusive表示只有自己读入了该行，一旦有其他人读了，那就全部变为Shared</p></li><li><p>Shared表示多个核都读入了该行，一旦有人修改该行，自己变Modified，别人变Invalidate</p></li><li><p>Invalidate表示该行失效，有其他核修改了</p></li></ul><p>MESI具体状态转移为：</p></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006740.png" alt="img" style="zoom:67%;" /><blockquote><p>其中Local Read&#x2F;Write表示自己读写，Remote Read&#x2F;Write表示其他核的读写</p></blockquote><h4 id="线程伪共享问题"><a href="#线程伪共享问题" class="headerlink" title="线程伪共享问题"></a>线程伪共享问题</h4><p>在多核场景中，我们使用了MESI协议来保证缓存一致性，但是这会导致缓存伪共享的问题</p><p>比如有一个数组长度为2，然后线程A修改a[0]，而线程B修改a[1]</p><p>由于缓存行大小为64B，因此线程A和B读入各自要修改的数时候都会把整个数组读进来</p><p>那么由于MESI，不管是A还是B修改，肯定<strong>一个变为Invalidate，一个变为Modified</strong>，那么变为I的那个就要强制另一方写回然后自己重新读取</p><p>这就会导致原本可以并发的线程反而变成串行化了，这可不能接受！</p><p>解决方法就是空间换时间，直接将数组长度声明为16，然后a[0]放一个a[8]放一个</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006201.png" alt="img" style="zoom:80%;" /><p>这样就可以实现隔离了，当然为了防止a[0]前面的地址可能也有另一个核在修改，我们可以声明一个长度为24的数组，然后a[0]放在a[8]，a[1]放在a[16]</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在OS中，进程访问某一块内存并不是直接访问内存的真实物理地址，而是访问分配给他的虚拟地址，然后通过地址映射，找到对应的内存地址</p><p>为什么要搞这么麻烦呢？</p><ul><li><strong>内存有限</strong>，但是虚拟地址空间很大（32位是$2^{32}$，64位是$2^{64}$）</li><li>给进程分配自己独享的虚拟地址空间，具体地址映射，包括换页、换段对于进程都是透明的，由内核控制，<strong>方便OS管理</strong></li></ul><p>映射方式主要分为两种：页和段</p><p>其中页是固定大小，容易有内部碎片；段是动态大小，但是会有外部碎片</p><p>相比于内部碎片，外部碎片更影响性能，因为一旦碎片过多，无法分配内存就要进行内存整理；而分页只会造成一点空间浪费，也问题不大</p><p>对于分页，我们还有一系列优化：<strong>多级页表、TLB</strong>等等，包括段页式管理</p><h3 id="Linux内存架构"><a href="#Linux内存架构" class="headerlink" title="Linux内存架构"></a>Linux内存架构</h3><p>Linux整体采用的是分页管理，每个用户进程都有自己的地址空间，内核进程也有自己的内存空间</p><p>同时为了方便内核态和用户态的切换，用户态地址空间中的内核地址空间是一样的（因为内核进程只有一个）</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006127.png" alt="img" style="zoom:50%;" /><p>具体到某一个用户进程的架构是这样的：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080007993.png" alt="虚拟内存空间划分" style="zoom: 50%;" /><p>我们这里注意一下<strong>文件映射区</strong>：这个就是IO磁盘拷贝到内核的区域，mmap的空间就是在这里</p><p>其他的堆栈、数据代码段就不讲了</p><h3 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h3><p>malloc函数众所周知就是分配内存的函数，但是到底是如何分配的呢？</p><p>其实malloc分配函数有两种方式，取决于你申请的资源大小：</p><ul><li><p>小于128KB就是通过**brk()**，移动堆指针</p><p><strong>brk不是系统调用</strong>，而且通过brk申请的堆空间在free的时候<strong>并不会直接释放掉</strong>，而是还在原地，直到进程销毁</p><p>这样，等下次再申请可以直接使用，减少性能消耗</p><p>但是这样会导致产生外部碎片，这也为什么<strong>小于128KB才会用brk</strong>，否则太大的free不立马释放，可是会出大问题的！！</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006313.png" alt="img" style="zoom:50%;" /></li><li><p>大于128KB用**mmap()**，这个是系统调用，也是零拷贝用到的系统调用</p><p>它会在文件映射区找内核要一块，然后把地址指针共享到用户，这样申请的区域在内核，但是用户态可以访问</p><p>它会产生两次用户态-内核态切换，同时还会发生一次地址的拷贝，free的时候会直接归还给内核，真正的释放掉</p><p>因此频繁的申请小空间轮不到它出手，比较耗费性能，只有申请大空间的时候才会出手</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006369.png" alt="img" style="zoom:50%;" /></li></ul><blockquote><p>free的时候，因为内存区域头部有一个表示大小的字段，所以可以知道本次要free多大内存</p></blockquote><h3 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h3><p>这里的内存回收机制其实就是讲的缺页中断问题</p><h4 id="内存回收具体细节"><a href="#内存回收具体细节" class="headerlink" title="内存回收具体细节"></a>内存回收具体细节</h4><p>当有程序通过malloc申请内存的时候，一般都是<strong>申请的虚拟内存</strong>，然后申请完请求使用的时候，就会根据地址映射查找相应的页</p><p>发现在内存中，就直接使用，如果不在那就触发缺页中断，由用户态变为内核态</p><p>紧接着，就会开始进行页面替换，但是到底要替换哪个页？有人肯定就说<strong>LRU</strong>，再细节点的能讲讲么？</p><ul><li><p>首先，LRU之前肯定先看看有没有空闲页可以用对吧，没有才会开始搞LRU，不然就直接放进去了</p></li><li><p>其次LRU，替换出来的物理页放哪？你要是文件加载过来的内存还好，就直接释放，后面再从硬盘里面读，要是像堆栈、代码段这种的，你往哪放呢？</p><p>针对这个情况，OS把页面分为了两种，分别是<strong>文件页和匿名页</strong>，恰好对应上面两种情况</p></li><li><p>如果是文件页，就直接把文件的那个文件标识符啥的给他搞掉，相当于关闭文件，释放内存，下次还要就从硬盘里读</p></li><li><p>如果是匿名页，那就放到磁盘的<strong>SWAP分区</strong>（这个你得开启才行），暂存一下，后面要就从这里加载</p></li></ul><p>具体的回收策略就是LRU，二者都会维持自己的<strong>LRU双向链表</strong></p><h4 id="内存回收优化"><a href="#内存回收优化" class="headerlink" title="内存回收优化"></a>内存回收优化</h4><p>大家可以看到，不管是文件页还是匿名页，移出去的页都是要放到硬盘上，这肯定会造成大量的IO，性能问题就会来了，如何优化呢？</p><p>首先，我们要知道内存回收的流程：</p><p>当空闲物理页数下降到某个阈值的时候，就会触发<strong>异步回收</strong>，如果回收速度小于申请速度，就会触发<strong>同步回收</strong>，会阻塞进程，如果同步回收完还是放不下，就触发OOM，<strong>杀死进程来获取空闲内存</strong></p><p><strong>这有点像JVM的CMS+Serial Old垃圾回收</strong></p><p>具体优化方案如下：</p><ul><li><p><strong>尽量回收文件页</strong>，因为SWAP分区还是比较小的，并且匿名页的使用频率要比文件页搞，人家毕竟存的是堆栈、代码段这些</p><p>因此，我们可以配置相关比例参数，来限制二者的回收比</p></li><li><p><strong>减少同步回收</strong>，我们可以提高异步回收的阈值，从而减少同步回收的次数</p></li></ul><h4 id="内存OOM问题"><a href="#内存OOM问题" class="headerlink" title="内存OOM问题"></a>内存OOM问题</h4><p>有一个很经典的问题：<strong>在4G内存的机器上申请8G的空间，会出现啥情况？</strong></p><p>我们要明确的一点是，malloc申请的空间是虚拟内存，也就说即使超出了实际物理内存，那么只要在虚拟内存满足的大小内，你不使用，应该也是问题不大的（不使用就不会读到物理内存里来）</p><p>而对于32位机器来说，用户可申请的虚拟内存大小为3G，64位位128T</p><p>所以对于32位而言一定无法申请成功，但是对于64位是问题不大的，所以接下来我们就64位机器来说</p><p>既然64位机器是128T的虚拟内存空间大小，那么是不是可以直接分配128T呢？这个也得分情况，如果我们是分块申请，比如一次申请1G，然后申请128*1024次，那这样还是会OOM</p><p>因为每次申请获得的块，都是要耗费资源的，mmap总得有个东西来保存文件映射区的地址吧，如果你实际物理内存很小比如就2G，那么内存无法存下这么多额外信息，还是会OOM</p><blockquote><p>这就相当于你用了一个长度为$2^{16}$的数组，来保存每个块的信息，包括长度、地址等等</p><p>内存如果放不下这些东西，还是会OOM</p></blockquote><p>那么就有人问了，不是虚拟内存吗，换页呢？</p><p>其实这个保存的位置不是文件页，而是匿名页，<strong>在没有开启SWAP的情况下，会OOM</strong>；但是开启SWAP分区，那必然就不会了</p><p>并且，你开启SWAP分区后，你甚至都可以使用这些超过物理内存大小的虚拟内存，只不过这会造成很大的IO压力</p><p>如果<strong>虚拟内存过大</strong>，<strong>即使开启了SWAP，还是会出现OOM</strong></p><h3 id="预读失效和缓存污染"><a href="#预读失效和缓存污染" class="headerlink" title="预读失效和缓存污染"></a>预读失效和缓存污染</h3><p>要知道，在Linux的页面淘汰机制中，都知道是通过LRU实现的，并且是针对文件页和匿名页分别LRU</p><p>那么在各自的LRU中，都维持了两个双向链表你们知道吗？</p><p>分别为活跃链表（active_list）和不活跃链表（inactive_list），每次LRU优先从不活跃链表移除</p><p>为什么要这样做呢，其实就是为了避免预读失效和缓存污染问题</p><h4 id="预读机制"><a href="#预读机制" class="headerlink" title="预读机制"></a>预读机制</h4><p>不管是MySQL的buffer pool还是Linux的page cache，都是有一个预读机制的</p><p>就是说，当我们读取的是0-3KB的数据，往往会读出一整页即0-4KB，但是预读机制会额外读出几页出来，它们认为这边上挨得近的都是容易被读取的，因此这也就是为什么我们常说<strong>MySQL一页是16KB</strong></p><p>因为预读机制，一次会读取4个4KB的OS页出来</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080007458.png" alt="img" style="zoom:67%;" /><h4 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h4><p>那么预读机制读出来的这些物理页，往往有可能是访问不到的，但是你LRU还是把它放到链表头</p><p>这些用不到的数据放进来，很有可能会挤掉一些链表尾但是会需要的数据</p><p>这可忍不了！</p><p>因此Linux搞出了一个<strong>活跃链表</strong>和<strong>不活跃链表</strong>，每次读出来的页都放在不活跃里面，访问了才会移到活跃链表上</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080007951.png" alt="img" style="zoom: 67%;" /><p>包括MySQL，它也有一个young区和old区，扮演着同样的功能，只不过是放在一条链表上</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080011157.png" style="zoom:67%;" /><h4 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h4><p>那么既然用上了这个两级LRU机制，是不是就可以了，还是不行！</p><p>比如我们要全表扫描一下某个MySQL表，那么实际上每个地方都会访问一次，然后全部放到活跃链表里去了，把里面真正频繁访问的数据给挤出去了</p><p>然后后面这个表的数据再也没有用上，这不也出大问题了吗，也就是缓存污染问题</p><p>缓存污染指的是，一些不是频繁访问的东西被放到缓存里面来了，导致一些是缓存的被挤出去了</p><p>那么Linux是怎么做的呢？</p><p>很简单，就是你既然第一次访问代表不了什么，那你<strong>第二次访问再加到活跃链表</strong>不就行了</p><p>MySQL更复杂点，他还会在第二次访问的时候查看一下和第一次的时间间隔，如果<strong>超过1s还是不会加进去</strong></p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程的状态大致可以分为五种：</p><ul><li><strong>创建状态</strong>：当一个线程正在被创建，比如申请PCB、初始化数据等等，这个过程往往会很快，而且一个线程只会在这个状态停留一次</li><li><strong>就绪状态</strong>：线程创建完成后，就会进入就绪队列，然后等待时间片，上CPU运行</li><li><strong>运行状态</strong>：上CPU运行的时候就是运行状态，一旦时间片到了，就会重新回到就绪状态；如果碰到IO等事件，就会阻塞，进入阻塞状态</li><li><strong>阻塞状态</strong>：一旦碰到事件，比如IO就会进入阻塞状态，等待通知（IO结束，DMA中断），唤醒后回到就绪状态</li><li><strong>终止状态</strong>：程序正在结束中，shutdown你也得要一个过程吧</li></ul><p>但是，还有一种特殊情况，就是当前不需要运行当前程序（sleep函数），那么就会将内存移除到磁盘暂存，此时进入<strong>挂起状态</strong>。</p><ul><li>如果你是就绪的时候sleep，就会进入<strong>就绪挂起状态</strong>，等重新装到内存就会回到就绪状态</li><li>如果你是阻塞的时候sleep，就会进入<strong>阻塞挂起状态</strong>，等重新装到内存就会回到阻塞状态</li></ul><p>因此，最终程序应该是有七个状态的，转移关系如下：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006870.png" alt="进程五种状态的变迁" style="zoom:67%;" /><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><p>既然上面说到了进程与很多个状态，那么这些状态是怎么标识的呢？</p><p>这么多状态之间的切换，是怎么实现的呢，怎么从就绪状态的进程中选一个，放到CPU上运行呢？</p><p>这些问题，其实都是进程控制的问题，在OS中，每个进程都一个数据结构来存储进程的相关信息，那就是<strong>进程控制块PCB</strong></p><p>PCB会存放包括进程状态、进程PID、分配的虚拟地址空间信息、IO列表等等进程自己的信息</p><p>此外，当进程进行切换的时候，寄存器的信息也会放到PCB中，就是所谓的<strong>保留CPU现场</strong></p><p>这些PCB会根据不同的状态放到相应的链表中：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080008947.png" alt="就绪队列和阻塞队列" style="zoom:67%;" /><blockquote><p>运行状态的链表，如果是<strong>单核则只是一个指针</strong>，指向当前运行的PCB</p><p>但是如果为多核，就会组织为一个链表</p></blockquote><p>那么我们基于PCB，来讲一讲进程的状态切换吧：</p><ul><li><p><strong>创建进程</strong></p><p>当一个线程创建的时候，就会创建一个新的PCB，然后为其分配自己的虚拟地址空间</p><p>一切准备就绪后，就会将该PCB插入到就绪链表中，等待调度</p></li><li><p><strong>终止进程</strong></p><p>这里主要关注父子进程问题，即fork出来的进程怎么处理</p><p>如果只是单纯的终止，那就回收内存、IO等资源，然后释放PCB就行了</p><p>但是如果存在父子关系，子进程被回收，就需要将资源归还给父进程</p><p>如果父进程被回收，则子进程<strong>统一交给1号进程管理</strong>，这个进程专门来管理孤儿进程的</p></li><li><p><strong>阻塞进程</strong></p><p>找到对应的PCB，如果正在运行，则先执行进程上下文切换操作</p><p>然后将PCB移到阻塞队列中</p></li><li><p><strong>唤醒进程</strong></p><p>一般唤醒都是由当前正在运行的进程去唤醒，比如IO好了，就会触发中断</p><p>然后内核处理中断的进程去唤醒等待IO的进程</p><p>此时，就会将对应的PCB移到就绪队列中，等待调度</p></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是进程中的一条执行流程，是程序独立运行的基本单位</p><p>传统的进程作为运行的基本单位，会导致上下文切换十分耗时，因为PCB中包含了太多的信息，而且内存是相互隔离开的，不同的进程的切换很容易就<strong>发生缺页中断</strong></p><p>此外，进程之间的通信也是十分麻烦的，因为相互之间<strong>很多资源都是隔离的</strong></p><p>因此，就提出了线程的概念，相同进程的线程共享其所有资源，因此发生切换的时候，并不会出现耗费性能的情况，也就切换个寄存器现场罢了</p><blockquote><p>一般进程只是用来做资源管控，线程是用来运行的</p><p>大家所说的启动一个进程，其实就是<strong>申请资源，然后启动一个主线程</strong></p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006569.png" alt="多线程" style="zoom:67%;" /><p>因此对于<strong>线程切换</strong>，分为两种情况：</p><ul><li><p>如果切换的两个线程<strong>属于同一个进程</strong>，那基本上就把寄存器的数据切换一下就好了</p><p>有人说还是栈，其实OS中栈也是两个寄存器esp和ebp保存的，因此其实就是切换寄存器</p></li><li><p>如果两个线程不属于同一个进程，那最后还是进程的上下文切换，需要涉及到PCB块的移动等等</p></li></ul><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>在OS中，线程也是有很多种实现方式的</p><p>因为真正线程调度的其实是内核的线程，所谓的多核处理，其实多个核上并行的也是内核线程</p><p>但是，有的程序中，会自己写一套并发库，这个库虽然说是并发库，但是里面是自己定义的线程。我们可以把这些用户线程看作是内核线程的服用</p><p>就是说，一个进程内使用这种并发库的线程都是一个线程即进程的主线程，这种其实往往效率更低，但是处于实时性的要求可能有需要，或者<strong>自己实现某种调度方式</strong>（内核线程调度是OS管的）</p><p>因此，线程的实现可以看作是用户线程和内核线程的对应关系，可以分为三种：</p><p>一个用户：一个内核、多个用户：一个内核、多个用户：多个内核</p><p>其中，多个用户多个内核可以看作是线程池的形式，就是说一个进程我给你m个内核线程，但是具体你生成了多少个用户线程我不管，反正你就m个内核线程可以复用</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006653.png" alt="LWP 模型" style="zoom:67%;" /><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>进程是资源分配的基本单位，它统一管理整个程序的资源，包括虚拟内存（代码段、数据段）、打开文件、IO等等</li><li>线程是独立运行的基本单位，一<strong>个进程无法直接运行</strong>，他只是一个资源的集合，要想运行必须要开启一个主线程</li></ul><p>那为什么进程切换比线程切换慢呢？</p><ul><li>线程的切换只用切换寄存器，但是进程切换由于内存地址隔离，因此往往会发生<strong>页面置换</strong></li><li>线程的通信可以直接通过共享内存，但是进程不行（一般就是管道或者socket）</li><li>线程创建比进程快，因为进程需要申请资源组织PCB，而线程的TCB更轻量而且不用申请资源</li><li>线程终止也比进程快，因为线程终止不用释放大量资源，而进程则需要，甚至还涉及父子进程</li></ul><h2 id="进程和线程的通信方式"><a href="#进程和线程的通信方式" class="headerlink" title="进程和线程的通信方式"></a>进程和线程的通信方式</h2><h3 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h3><ol><li><p><strong>管道</strong></p><p>管道是通过pipe函数生成的，其实本质就是内核中的一个缓冲区，支持无格式的流式写入</p><p>分为<strong>匿名管道</strong>和<strong>命名管道</strong>，<strong>管道是单向的</strong>，如果需要相互读写就得声明两个管道</p><p>要想声明一个<strong>匿名管道</strong>，可以调用pipe函数，我们会得到一个数组fd，其中fd[0]代表管道的读端、fd[1]代表管道的写端</p><p>但是这个数组只存在于pipe的进程中，其他进程怎么拿过来进行通信呢？</p><p><strong>通过fork函数就可以了</strong>，但是命名管道就没有父子进程这样的限制了</p><blockquote><p>在linux中，<code>ps aux|grep java</code>就是匿名管道，将ps出来的进程信息拿过来grep一下</p><p>虽然没有显式的fork，由于都是命令行，其实都是shell fork出来的</p></blockquote></li><li><p><strong>消息队列</strong></p><p>管道这种通信方式，read、write还会阻塞，而且匿名管道还有父子进程的关系限制</p><p>因此OS给了一个消息队列的形式，它是一个为内核中链表结构，<strong>当然如果是跨机器的进程可以使用消息中间件</strong></p><p>这个是任何进程都可以访问的，突破了fork的限制</p></li><li><p><strong>共享内存</strong></p><p>消息队列由于消息体有大小限制，并且有一次内核态到用户态的内存拷贝，因此效率还是不够高</p><p>共享内存就是相当于java中的直接内存，直接约定一块虚拟内存区域，多个进程都可以访问就好了</p></li><li><p><strong>信号量</strong></p><p>当使用共享内存的时候，如果多个进程同时修改同一块数据，那就会乱套</p><p>为了实现进程同步，通过信号量来保证资源的有序使用</p></li><li><p><strong>信号</strong></p><p>就是通过kill -xxx pid的形式来给其他进程发送信号，比如kill -9就是杀死进程</p></li><li><p><strong>socket</strong></p><p>刚刚提到的消息中间件，其实也属于socket</p><p>当两个进程不在同一台机器上，那就无法通过管道、消息队列、共享内存这些方式来实现了</p></li></ol><h3 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a>线程的通信方式</h3><p>线程的通信方式其实跟进程差不多</p><ol><li><p><strong>锁机制</strong>：比如互斥锁、读写锁等等</p></li><li><p><strong>信号量机制</strong></p></li><li><p><strong>共享内存</strong>：Java的堆其实就是共享内存</p></li></ol><h2 id="线程同步问题"><a href="#线程同步问题" class="headerlink" title="线程同步问题"></a>线程同步问题</h2><p>当多个线程或者多个进程同时访问某一块共享资源的时候，如果都发生写事件，那么就会出现由于时间片切换发生的线程不安全问题</p><p>最经典的案例就是对于同一个i，多个进程进行i++，但是最后i的结果和累加的次数不一样</p><p>因此，实现对于共享资源的互斥访问，就是线程同步需要解决的问题</p><p>我们将互斥资源称为<strong>临界资源</strong>，访问互斥资源的代码段，称为<strong>临界区</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一般来说解决方案有两种，锁或者信号量</p><ul><li><p>锁的解决方案同样也是两种，其实就是乐观锁和悲观锁</p><p>一种就是CAS自旋直到释放后CAS成功，一种就是拿不到直接阻塞等待释放后的唤醒</p></li><li><p>还有一种就是经典的<strong>信号量PV操作</strong></p><p>P操作就是将信号量-1，然后如果发现小于0，就阻塞</p><p>V操作就是信号量+1，发现小于等于0，就唤醒阻塞队头的线程</p></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080009212.png" alt="img" style="zoom:67%;" /><h3 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h3><p>关于线程同步有三个经典问题：</p><ul><li>生产者-消费者问题</li><li>哲学家就餐问题：这里重点注意，会出现死锁，有多种解决方案</li><li>读者-写者问题：这个是互斥锁和共享锁的问题</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁在并发编程中用的太多了，这里我们讲一讲死锁问题，然后来看一看锁的选择</p><h3 id="死锁的四大必要条件"><a href="#死锁的四大必要条件" class="headerlink" title="死锁的四大必要条件"></a>死锁的四大必要条件</h3><ul><li><p>互斥条件：一个资源无法共享使用，拿不到就等</p></li><li><p>持有并等待条件：当拿不到的时候就会等待，并且等待的时候不会释放已经获得的互斥资源</p></li><li><p>不可剥夺条件：持有的互斥资源无法被其他程序剥夺</p></li><li><p>循环等待条件：获取资源的顺序构成了环形链</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006235.png" alt="img"></p></li></ul><p>一般来说，我们通常使用<strong>资源的有序分配</strong>，防止出现越过低序号资源直接申请高序号资源，这样可以<strong>破坏循环等待条件</strong></p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h4><p>互斥锁就是拿不到就阻塞，等待释放唤醒</p><p>自旋锁就是拿不到就一直acquire，直到拿到为止</p><p>这两种锁各有各的坏处：</p><ul><li>互斥锁因为涉及到阻塞问题，一般都是要进到内核态的，会涉及的线程的上下文切换的开销</li><li>自旋锁由于一直acquire，会一直占用CPU，导致其他线程只有等待自己的时间片才能上CPU运行</li></ul><p>因此对于互斥锁，一般如果临界区运行时间很短不推荐用，这切换一次的时间比临界区还长，那不得不偿失吗？</p><p>而自旋锁恰恰相反，它不适用于临界区很长的场景，明知道要运行十几秒，你非得一直搁那acquire，那不浪费资源吗？</p><p>因此，二者的选择往往<strong>依赖于临界区的运行时间</strong></p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>这个往往适用于读多写少的场景，可以很大程度上提高读并发</p><p>读写锁的实现方式有很多种，比如读优先、写优先等等</p><p>其中<strong>读优先</strong>表示当有线程正在读的时候，即使写进程先被阻塞，但是后续读进程依然可以先访问</p><p><strong>写优先</strong>则恰恰相反，写进程被阻塞了或者读进程优先阻塞，依然先提供给后续写进程</p><p>我们可以基于当前的读写场景选择读优先还是写优先，甚至可以根据读写时间来选择是互斥还是自旋</p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>这个就没啥好说的了吧</p><p>乐观锁适用于并发较少的场景</p><p>悲观锁适用于并发较多的场景，但是也有一种特殊情况，就是如果乐观锁回滚的代价很大，一般还是上悲观锁</p><blockquote><p>比如知识编辑，你写了半天，结果CAS失败，让你重新写，这谁顶得住啊？</p></blockquote><h2 id="线程创建问题"><a href="#线程创建问题" class="headerlink" title="线程创建问题"></a>线程创建问题</h2><h3 id="一个进程可以创建多少线程"><a href="#一个进程可以创建多少线程" class="headerlink" title="一个进程可以创建多少线程"></a>一个进程可以创建多少线程</h3><p>线程的创建耗费的资源一般就是一个TCB，然后还有私有的栈空间（OS设置的默认大小）</p><p>那么对于32位和64位的OS，只要可用虚存够用，就可以一直创建栈空间</p><p>像64位的OS，128T的地址空间，理论上可以无限创建</p><p>但是OS还会有一个<strong>最大线程数</strong>的设置</p><p>因此最终个数为：<strong>min(可用虚存&#x2F;栈大小，OS设置的最大线程数)</strong></p><h3 id="线程崩溃会导致进程崩溃吗"><a href="#线程崩溃会导致进程崩溃吗" class="headerlink" title="线程崩溃会导致进程崩溃吗"></a>线程崩溃会导致进程崩溃吗</h3><p>理论上，只要线程出现了内存访问的异常，比如空指针、访问内核内存空间、栈溢出等等</p><p>一般都会导致进程崩溃，因为OS为了保证正确性，非法访问空间会导致当前进程下的其他线程出现<strong>连锁反应</strong>，因此OS直接终止进程</p><p>具体流程就是，发生异常直接触发kill中断，进入内核态，然后走中断处理程序，杀死对应pid的程序</p><p>那为啥Java线程崩了，JVM不会崩呢？</p><p>因为<strong>JVM里面对kill中断进行拦截</strong>了，也就是说OS没有发生中断，而是被JVM拦截，抛出异常了。</p><p>只有出错线程终止，但是如果发现当前JVM的所有非守护线程全终止了，就会自动退出</p><h2 id="IO问题"><a href="#IO问题" class="headerlink" title="IO问题"></a>IO问题</h2><h3 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h3><p>文件IO的分类分为很多种：缓冲&#x2F;非缓冲IO，直接&#x2F;非直接IO，同步&#x2F;异步IO，阻塞&#x2F;非阻塞IO</p><ul><li><p><strong>缓冲和非缓冲IO</strong></p><p>缓冲IO指的是利用标准库的缓存来实现IO，一般来说块设备的IO都是基于缓冲IO的</p><p>非缓冲IO就是不利用缓存，而是直接访问文件，比如字节流式的IO，键盘按一次就IO一次</p></li><li><p><strong>直接和非直接IO</strong></p><p>这个<strong>一定要和零拷贝区分开</strong>，一般来说IO都是先走page cache，然后再从page cache拷贝到用户空间的内存中处理</p><p>直接IO和零拷贝分别解决的是两个地方的问题：</p><p>Direct IO是绕过了page cache直接从磁盘缓冲区拷贝至用户内存</p><p>零拷贝则是将page cache的地址共享到用户内存，绕过了page cache到用户内存的拷贝</p></li><li><p><strong>阻塞和非阻塞IO</strong></p><p>当CPU发起IO的时候，会先将磁盘数据拷贝到缓冲区，然后读取到内核的page cache，然后再从page cache读取到用户内存</p><p>但是这段时间如果CPU都是阻塞的，那岂不是十分浪费资源</p><p>因此非阻塞IO就是为了防止想拷贝数据到用户内存的时候发现数据没有准备好，导致被阻塞</p><p>比较经典的做法就是：<strong>select&#x2F;epoll</strong>这种IO多路复用，<strong>DMA直接内存访问</strong></p><blockquote><p>其实这二者还是有点区别的</p><p>IO多路复用解决的是多个IO请求顺序到来的时候，会导致前者阻塞后面已经准备好的IO问题，这个其实和http2.0的那个多路复用很像，通过<strong>事件驱动的方式实现单线程处理多个IO，谁先准备好谁先处理</strong></p><p>而DMA解决的是磁盘到page cache的拷贝操作（双向都是DMA操控），为了<strong>防止这些操作对于CPU的频繁中断</strong>，CPU只需要发送一个指令，后续所有IO的中断都有DMA处理，只有最后处理完毕DMA才会去中断CPU</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006474.png" alt="img"></p></blockquote></li><li><p><strong>同步和异步IO</strong></p><p>一般来说，不管是从磁盘缓冲区还是page cache拷贝到用户内存，都是需要CPU来参与的</p><p>就算是IO多路复用和DMA，也只是拷贝到page cache，Direct IO只是绕过page cache，但是从磁盘缓冲区到用户内存也需要CPU参与</p><p>当然零拷贝没有涉及用户内存的拷贝，当然没啥关系了</p><p>但是对于需要拷贝到用户内存的操作而言，这段拷贝的时间依然浪费了CPU</p><p>异步IO就是解决这个问题，就是把拷贝到用户态的过程也不通过CPU来做，彻底解放了CPU</p></li></ul><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>上面讲到了，零拷贝就是减少内核态到用户态的拷贝，具体怎么做的呢？其实有两种方式</p><p>要知道，引入了DMA以后，我们的IO流程就成了这样：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006121.png" alt="img" style="zoom:40%;" /><p>那么DMA减少的是什么？其实就是从磁盘到page cache的拷贝导致的CPU的阻塞</p><p>归根到底，两次内核-用户态的切换加一次内存拷贝，其实一个也没少</p><p>在我们读加写的场景，比如mq从index文件中读出来，然后发送出去这种情况其实是read+write</p><p>那么就会造成四次内核-用户态的切换加两次内存拷贝</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006037.png" alt="img" style="zoom:50%;" /><p>这其实开销还是蛮大的，那么我们该咋解决呢，一个就是异步IO还有一个就是零拷贝</p><p>零拷贝的方式有两种：分别是mmap和sendfile</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>mmap方式是系统调用，它会将page cache中的空间映射到用户内存上，其实相当于在用户内存留一个句柄，我可以访问内核的这块区域</p><p>然后我对这块内存读写完，再通过write函数写到目的文件上</p><p>那既然这样，其实两次系统调用还是导致了四次的内核-用户态切换，但是<strong>减少了一次内核到用户的拷贝</strong>，这其实我认为并没有解决太多，但是为什么有人用呢</p><p>因为有些场景需要知道文件的信息，我们需要mmap映射到用户空间上，但是如果你只是read操作完全可以直接用mmap，这样只需要<strong>两次切换加零次CPU拷贝</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080012603.webp" alt="mmap + write 零拷贝" style="zoom:50%;" /><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>但是如果我不关心文件信息，我只想实现类似MQ这样的转发功能，实现文件的拷贝操作呢？</p><p>直接用sendfile，这个系统调用根本不会管你的文件内容，你调用这个函数，直接在内核态完成page cache到目的地址的拷贝</p><p>如果是网卡转发，那就是page cache到socket buffer的拷贝；</p><p>如果是文件复制，那就是page cache到page cache的拷贝</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080009917.png" alt="img" style="zoom:50%;" /><p>这样其实只有<strong>两次内核-用户态的切换和一次CPU拷贝</strong>，减少了一半时间</p><blockquote><p>如果是针对网卡的转发，可以使用<strong>SG-DMA技术</strong></p><p>就是直接通过page cache，做DMA，根本没有CPU拷贝，只有两次内核-用户态的切换</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080009557.png" alt="img" style="zoom:50%;" /></blockquote><h3 id="大文件处理"><a href="#大文件处理" class="headerlink" title="大文件处理"></a>大文件处理</h3><p>有人就说了，既然非阻塞IO+零拷贝这么牛逼，为啥不全用这个呢</p><p>确实，对于小文件而言确实很实用，比如Kafka、RocketMQ这些都是这样做的，大大提高了吞吐量</p><p>但是对于大文件可不行了，大文件的非阻塞IO，拷贝到page cache那占用内存也是很大的，这会导致大量小文件无法利用page cache了</p><p>那既然不要用page cache那就用直接IO呗，直接绕过page cache</p><p>但是直接IO从磁盘缓冲区到用户内存还是要CPU参与，这拷贝占用CPU可不是一时半会，因此要想解决这一问题，那就可以上异步IO</p><p>所以最终，解决大文件的理想方式就是<strong>直接IO+异步IO</strong></p><blockquote><p>其实这些IO方式的使用，你只要搞清楚这些IO有什么优点，当前场景的问题，就很好对症下药</p></blockquote><h2 id="键盘输入到屏幕显示发生了什么？"><a href="#键盘输入到屏幕显示发生了什么？" class="headerlink" title="键盘输入到屏幕显示发生了什么？"></a>键盘输入到屏幕显示发生了什么？</h2><p>键盘属于我们口中的外设，其实就是一种IO设备，在我们的计算机中，其实有很多的IO设备，它们都是异构的，那么当键盘输入了一个字符，他是怎么显示屏幕上的呢？</p><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>由于不同的IO设备实际上是异构的，因此为了屏蔽这些设备之间的差异，每个设备都有自己的<strong>设备控制器</strong></p><p>设备控制器用于自己的寄存器，包括：</p><ul><li>接受IO数据的数据寄存器</li><li>执行OS指令的指令寄存器</li><li>表示IO设备状态的状态寄存器</li></ul><p>那么当发生IO操作的时候，是如何让CPU接受数据的呢？总不能让CPU去轮询状态寄存器吧？</p><p>其实就是通过中断来实现的，每当IO通知OS的时候就会触发中断，或者用户态请求IO的时候也会发生中断，那么这样的话频繁的IO也会导致CPU全去用来处理中断了，这可不太好</p><p>为例防止这种情况出现，我们使用了DMA技术</p><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>上面讲到IO设备的事件处理是通过中断来实现的，但是中断处理程序是很多的</p><p>就比如键盘和磁盘的中断处理程序肯定不一样吧？</p><p>要是你电脑再装个显卡，又得多出来中断处理程序，你总不能事先在OS上全部配好吧？</p><p>这个时候，为了屏蔽不同设备控制器的差异，包括处理中断的方式，缓存区的异构性等等，我们就有了设备驱动程序这一东西</p><p>你用啥设备，你就自己装驱动，这样发生中断我就有应对了，而且减小了OS的复杂程度</p><p>但是比如键盘、鼠标、磁盘这种常见的驱动一般还是都会事先装上的</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080006255.png" alt="img" style="zoom:50%;" /><h3 id="到底发生了什么？"><a href="#到底发生了什么？" class="headerlink" title="到底发生了什么？"></a>到底发生了什么？</h3><p>那么最后到底发生了什么呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202408080009113.png" alt="CPU 的硬件架构图" style="zoom:67%;" /><ul><li><p>当你按下一个字母的时候，就将该按下的数据放到设备管理器的数据寄存器里，然后触发中断</p></li><li><p>当CPU检测到中断后，就会进入内核态，然后执行驱动程序中设计好的中断处理程序</p><p>它会从寄存器里面拿出来，然后转为ASCII码</p></li><li><p>然后就会将这个ASCII码放到显示器的读缓冲区，显示器的驱动程序会将读缓冲区的内容转到写缓冲区，进而显示在屏幕上</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis详解</title>
    <link href="/2024/07/06/%E5%85%AB%E8%82%A1/2024-07-06-Mybatis%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/07/06/%E5%85%AB%E8%82%A1/2024-07-06-Mybatis%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis详解"><a href="#Mybatis详解" class="headerlink" title="Mybatis详解"></a>Mybatis详解</h1><h2 id="Mybatis架构"><a href="#Mybatis架构" class="headerlink" title="Mybatis架构"></a>Mybatis架构</h2><p>Mybatis的架构图如下所示，分为配置层、接口层、数据处理层和框架支撑层</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407072116447.png" alt="image-20240707211554372" style="zoom:50%;" /><h3 id="配置层"><a href="#配置层" class="headerlink" title="配置层"></a>配置层</h3><p>配置层分为两个部分，分别是mybatis本身的<code>mybatis-config.xml</code>以及每个mapper接口对应的<code>xxxMapper.xml</code></p><p>其中mybatis-config.xml声明了数据库的信息、连接池、以及各个mapper的对应的xml文件位置等等</p><p>然后解析完mabatis-config.xml后，就会根据其中的mapper.xml解析出每个mapper的信息</p><p>mybatis-config.xml是用于SqlSeesionFactoryBuilder来build一个SqlSessionFactory对象的，而SqlSessionFactory通过openSession函数可以生成SqlSession对象</p><p>当SqlSessionFactory生成后，配置层就初始化完了，SqlSessionFactoryBuilder也就没有用处了</p><blockquote><p>build的时候，一般传入config.xml的inputStram，最终会转换为Configuration类，当然你也可以直接通过Configuration来build</p><p>你也可以用同一个Builder去build多个SqlSessionFactory对象，比如分库分表</p></blockquote><h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h3><p>接口层就是每一个Mapper接口，一般通过java文件定义mapper接口，然后通过mapper接口的中方法名作为statementId来在mapper.xml中定位每个sql语句</p><p>执行Sql有两种方式，虽然看起来不太一样，但是底层都是通过SqlSessionFactory来创建一个SqlSession来执行的：</p><ul><li><p>通过SqlSession来直接执行，传入对应的mapper的方法以及参数，定位对应的mapperStatement，找到对应的sql执行</p></li><li><p>直接执行mapper接口的方法，mybatis会创建一个动态代理（由于是接口，因此是dynamicProxy）</p><p>然后根据该方法获取mapperStatement，生成一个SqlSession来执行对应的Sql</p></li></ul><h3 id="数据处理层"><a href="#数据处理层" class="headerlink" title="数据处理层"></a>数据处理层</h3><p>数据处理层主要完成两个方面的功能：</p><ul><li>实现动态参数的绑定，就是在sqlSession执行sql的时候，会先进行<code>prepareStatement</code>进行动态参数的绑定，其中使用<code>#&#123;&#125;</code>可以防止sql注入，但是<code>$&#123;&#125;</code>不行</li><li>执行语句，并将结果映射，比如resultMap、resultType等</li></ul><h3 id="框架支撑层"><a href="#框架支撑层" class="headerlink" title="框架支撑层"></a>框架支撑层</h3><p>框架支撑层提供基本功能，比如sqlSession能进行事务的commit、rollBack，还有mybatis的二级缓存、连接池等</p><blockquote><p>这也是为什么Spring的事务会用ThreadLocal，因为要实现事务，就需要保存当前的sqlSession，然后进行事务管理，否则用一个mapper接口的方法就open一个sqlSession那没法管理事务</p></blockquote><p>其中mybatis的二级缓存分别是：</p><ul><li>一级缓存：SqlSession的缓存，每个sqlSession都会有一个</li><li>二级缓存：全局缓存，所有的SqlSession公用，需要第三方缓存技术</li></ul><h2 id="一条Sql是如何执行的"><a href="#一条Sql是如何执行的" class="headerlink" title="一条Sql是如何执行的"></a>一条Sql是如何执行的</h2><p>我们就以mapper接口调用方法来讲：</p><ul><li><p>首先，mapper接口调用方法会通过动态代理类invoke一下，这里也是插件作用的地方</p><p>invoke的时候就会SqlSessionFactory就会通过openSession创建一个sqlSession出来</p><blockquote><p>SqlSession封装了当前连接的事务、执行器executor、数据库连接connection等等</p><p>因此，我们可以通过sqlSession开启、提交、回滚事务；也可以执行sql语句</p></blockquote></li><li><p>然后，sqlSession就会通过mapper的方法找到mapperStatement，这个statement还是有<code>#&#123;&#125;、$&#123;&#125;</code>这些东西的</p></li><li><p>然后通过Executor来执行sql，这个executor其实也可以在openSession时候指定</p></li><li><p>excutor中执行的时候，会先看看缓存，有直接返回，没有则创建StatementHandler，去数据库执行sql</p></li><li><p>在执行之前，statementHandler会先通过ParameterHandler来动态映射参数</p><p>然后再执行sql，其执行结果会通过ResultSetHandler进行结果集映射</p></li></ul><h2 id="Mybatis的插件机制"><a href="#Mybatis的插件机制" class="headerlink" title="Mybatis的插件机制"></a>Mybatis的插件机制</h2><p>Mybatis提供了拦截器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable;<br><br>  Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span>;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过实现这个接口，并且注册拦截器到拦截器链InterceptorChain中，实现拦截</p><p>拦截器有两个比较重要的方法需要实现：</p><ul><li><p><code>interceptor</code>：这个是拦截器的主要逻辑，就是如果拦截了，那么就会执行这个方法</p></li><li><p><code>plugin</code>：这个方法用于决定是否进行拦截，如果需要拦截就通过<code>Plugin.wrap(target, this)</code>来生成代理类</p><p>一般拦截是通过<code>@Signature</code>注解来实现拦截的地方，比如分页拦截器就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type =StatementHandler.class, method = &quot;prepare&quot;, args =&#123;Connection.class&#125;)&#125;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;  <br>    ...  <br>&#125;<br></code></pre></td></tr></table></figure><p>拦截StatementHandler的prepare方法，解析sql中修改执行的sql</p></li></ul><p>拦截器可以作用在四个地方：Executor、ParameterHandler、ResultSetHandler、StatementHandler，这个四个类是通过工厂方法new出来的，因此在工厂中new出来后会通过interceptor.pluginAll方法将每个plugin进去</p><p>而plugin方法是拦截器接口实现的，如果需要在这个四个地方的某个或某几个地方用，就通过Plugin.wrap返回代理类，否则就返回本身</p><h2 id="Mybatis的两级缓存"><a href="#Mybatis的两级缓存" class="headerlink" title="Mybatis的两级缓存"></a>Mybatis的两级缓存</h2><p>Mybatis有两级缓存，但是默认开启的是一级缓存，二级缓存需要手动开启，一旦开启SqlSession封装的Executor就会变成CachingExecutor</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是基于SqlSession的，每个SqlSession都会封装一个Executor，而缓存就是存放在Executor中的</p><p>每次查询之前，都会先去看看Executor中</p><p>有没有查询缓存，有的话直接返回，没有的话就会queryFromDatabase</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407072117287.png" alt="img" style="zoom:40%;" /><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存需要在config.xml中配置cacheEnabled&#x3D;true才可以开启</p><p>虽然说二级缓存是应用级的，但是我们在开启cacheEnabled后还需要对mapper单独设置cache节点</p><p>并且，如果不加说明mybatis会为每个mapper创建一个cache，但是如果使用cache-ref设置，可以使得多个mapper公用一个cache</p><p>因此，要让某条select语句使用二级缓存，则需要满足：</p><ul><li>MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled&#x3D;true</li><li>该select语句所在的Mapper，配置了<code>&lt;cache&gt;</code> 或<code>&lt;cached-ref&gt;</code>节点，并且有效</li><li>该select语句的参数 useCache&#x3D;true</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM详解</title>
    <link href="/2024/06/14/%E5%85%AB%E8%82%A1/2024-06-14-JVM%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/14/%E5%85%AB%E8%82%A1/2024-06-14-JVM%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="初步认知"><a href="#初步认知" class="headerlink" title="初步认知"></a>初步认知</h2><p>JVM是一个程序集虚拟机，它可以运行一系列虚拟的计算机指令，这个指令就是我们常说的字节码</p><p>当然，JVM不仅仅就是运JAVA程序，它其实是一个虚拟机，你只要提供的字节码是满足JVM定义的规范那就可以运行</p><p>也就是说对于任意一个语言，我们只需要设计一个编译器将该语言编译成JVM定义的字节码规范，就可以直接在JVM中运行，比如Scala、Kotlin等</p><h3 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h3><p>JVM的指令集是基于栈操作的，比如你执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> k=i+j;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是换成C语言来做，他的编译是基于寄存器的，因此就直接使用mov指令+add指令就可以完成了</p><p>但是JVM的字节码是基于栈来实现的，最通过javap反编译的结果是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iconst_2<span class="hljs-comment">//常量2</span><br><span class="hljs-number">1</span>: istore_1<span class="hljs-comment">//存到栈里</span><br><span class="hljs-number">2</span>: iconst_3<span class="hljs-comment">//常量3</span><br><span class="hljs-number">3</span>: istore_2<span class="hljs-comment">//存到栈里</span><br><span class="hljs-number">4</span>: iload_1<span class="hljs-comment">//读取</span><br><span class="hljs-number">5</span>: iload_2<span class="hljs-comment">//读取</span><br><span class="hljs-number">6</span>: iadd<span class="hljs-comment">//加</span><br><span class="hljs-number">7</span>: istore_3<br><span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>虽然这个和C语言的汇编比起来指令更多，但是<strong>基于栈的架构可移植性更强、指令集更小</strong>，不需要考虑计算机硬件（比如寄存器）的问题，因为栈是基于内存的</p><p>但是相比寄存器而言，毕竟是基于内存的栈，因此<strong>执行性能会差点</strong></p><h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><ul><li>JVM启动：通过bootstrapClassLoader创建一个初始类，这个类是由虚拟机完成的</li><li>JVM执行：就是执行一个java任务，当启动一个java程序的时候，其实就是启动了一个JVM进程</li><li>JVM退出：正常退出、出现错误或者异常导致退出、调用System.exit()方法</li></ul><h3 id="JVM的整体架构"><a href="#JVM的整体架构" class="headerlink" title="JVM的整体架构"></a>JVM的整体架构</h3><p>JVM的组成可以分为三大部分，分别是：<strong>类加载器</strong>、<strong>运行时数据区</strong>、<strong>执行引擎</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152303592.png" alt="img" style="zoom: 50%;" /><ul><li><p>类加载器：就是将.class文件加载到内存中，生成一个klass对象，放在方法区中</p></li><li><p>运行时数据区：这个就是JVM的内存结构，这个一定要和JMM区分开，JMM是屏蔽硬件而定义的一个规范</p><blockquote><p>因为JVM是一个虚拟机，因此我们需要在这里面屏蔽掉底层操作系统的异构性，所以定义了一个叫做JMM的内存规范，它提供了多线程情况下的内存访问方式，抽象出了主内存和工作内存两大空间，并且还提供了类似volatile、synchronized这些关键字用于线程同步</p></blockquote></li><li><p>执行引擎：这个就是执行字节码，这期间还涉及到了垃圾回收和即时编译（JIT）</p></li></ul><p>如果学完整个JVM，最终的JVM架构图应该是这样的：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152303132.png" alt="img" style="zoom:40%;" /><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190210050.png" alt="preview" style="zoom: 80%;" /><p>类加载过程总的氛围三个阶段：Loading、Linking、Initialization，其中Linking阶段还分为为三个子阶段：Verifying、Prepare、Resolve</p><p>这里一定要把这里的Loading阶段的加载和类加载器的加载区分开，Loading阶段只是类加载的一个阶段，但是它只是恰好也叫加载</p><p>类加载器的作用：</p><ul><li>加载class文件到内存中，其中class文件有特定的开头文件标识（魔数 CAFEBABE）。文件开头是否合法的验证就是在Linking阶段的Verify</li><li>ClassLoader只负责加载文件，他不会分析代码，具体执行是否会出异常或者错误，是由执行引擎决定的</li><li>类加载器会把加载后的类信息放到方法区中，方法区中还会放运行时常量池，其实这也是从字节码文件映射过来的</li></ul><h3 id="Loading阶段"><a href="#Loading阶段" class="headerlink" title="Loading阶段"></a>Loading阶段</h3><p>这里一共会做三件事：</p><ol><li>通过一个类的全限定名读取该字节码文件，并且是以二进制字节流的形式读取</li><li>将这个字节流代表的静态存储结构转化为运行时数据结构</li><li>生成一个Class对象，作为方法区类信息的访问接口，包括反射也是通过这个Class对象实现的</li></ol><h3 id="Linking阶段"><a href="#Linking阶段" class="headerlink" title="Linking阶段"></a>Linking阶段</h3><p>链接阶段一共分为三个子阶段：验证、准备、解析</p><ul><li><p>验证阶段：确保字节流信息是符合JVM要求的，不会危害虚拟机正常运行，比如文件开头是否为CAFEBABE</p></li><li><p>准备阶段：为类变量分配内存，同时将类的static变量全部先覆盖为零值</p><p>就跟对象创建过程一样，在执行构造函数之前先全部设置为零值。类初始化也是如此，它会现在这全部初始化为零值，然后在初始化阶段，执行编译字节码文件时候组装好的<code>&lt;clinit&gt;</code>函数，初始化类变量</p><blockquote><p>但是对于<strong>final static修饰的字面量</strong>，是在编译阶段就已经初始化好了，因此在准备阶段是直接赋值的，而不是先覆盖为零值</p></blockquote></li><li><p>解析阶段：将常量池中的符号引用转换为直接引用，<strong>这个我目前还不清楚，等看到后面字节码我再来分析</strong></p></li></ul><h3 id="Initialization阶段"><a href="#Initialization阶段" class="headerlink" title="Initialization阶段"></a>Initialization阶段</h3><p>在Linking阶段已经讲过了，初始化阶段其实就是执行<code>&lt;clinit&gt;</code>函数，这个要和构造函数<code>&lt;init&gt;</code>区分开，clinit函数是类静态变量的构造函数</p><p><strong>它不需要我们来写，是由编译器自动收集类信息来组装出来的</strong>。也就是说，如果这个类没有静态变量，那就收集不到信息，就不会有clinit函数！</p><blockquote><p>如果该类有父类，那么父类的clinit方法会先于子类的ciinit方法执行，因为加载子类之前会先加载父类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a=<span class="hljs-number">2</span>;<br>        b=<span class="hljs-number">2</span>;<br>        System.out.println(b);<span class="hljs-comment">//如果加上这行代码就会报错，因为先声明再调用</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，编译器就会收集这些信息，然后最终clinit函数就是：</p><p><code>a=1-&gt;a=2-&gt;b=2-&gt;b=1</code>，那为什么b的赋值可以在声明之前呢？</p><p>因为Linking的Prepare阶段已经分配内存并初始化为零值了，因此可以直接赋值，但是无法调用</p><p>此外，对于<code>&lt;init&gt;</code>方法，就是类的构造方法，如果你没有写就会有一个默认的无参构造方法，但是只要你写了，那个默认的无参构造方法就没有了。</p><p><strong>也就说一个类可能没有clinit方法，但是一定至少有一个init方法</strong></p><p>并且在clinit方法执行的时候，由于方法区是线程共享的，因此它在执行的时候会加锁，这样可以保证<strong>clinit操作只会执行一次</strong></p><blockquote><p>类的被动加载，不会执行Initialization阶段；只有主动加载才会！</p></blockquote><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM定义了两种类型的加载器：引导类加载器和用户自定义的加载器，其中JVM把用户自定义的加载器定义为继承ClassLoader抽象类的加载器都叫用户自定义加载器</p><p>因此，JVM中的类加载器只有<strong>BootstrapClassLoader和其他</strong>，即使是ExtClasLoader和AppClassLoader，也是继承自ClasssLoader抽象类的，因此也属于用户自定义的加载器</p><blockquote><p>BootstrapClassLoader加载器是C语言编写的，也就是说你直接打印它，出来的是null</p><p>比如你打印AppCLassLoader的类加载器是谁，打印出来的就是null了，并不是说它没有，而是它的ClassLoader是BootstrapClassLoader</p></blockquote><p>下面我们一个个来讲一讲JVM定义的几个类加载器吧</p><ol><li><p>BootstrapClassLoader</p><p>可以说BootstrapClassLoader就是JVM的一部分，使用C++编写，<strong>不继承ClassLoader抽象类</strong></p><p>主要用来加载java的核心类库，比如sun、java开头的类，像List、String、JUC的类都是BootstrapClassLoader加载的</p></li><li><p>ExtClassLoader</p><p>继承自ClassLoader，使用java语言编写的，由BootstrapClassLoader加载，父类加载器也是</p><p>这个加载器用于加载java.ext.dirs下的类库，或者用户编写的类放在jre&#x2F;lib&#x2F;ext目录下，也会用这个加载器加载</p></li><li><p>AppClassLoader</p><p>继承自ClassLoader，使用java语言编写的，由BootstrapClassLoader加载，父类加载器是ExtClassLoader</p><p>这个加载器负责加载classPath下的的类，也是我们用户编写的类的默认加载器</p></li></ol><p>那既然都有这三个加载器了，为什么还需要我们自定义加载器呢？</p><ul><li>隔离加载类，防止同一个包名发生冲突</li><li>修改类的加载方式：比如加载来源（从数据库加载、网络加载）；防止源码泄漏，在加载时候解密</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>JVM对class文件的使用是按需加载的方式，也就说，如果整个JVM进程中没有使用到这个class，那就不会加载，而加载某个类的时候，使用的双亲委派机制</p><p>具体来说：</p><ul><li>就是把类加载的任务先委派给parent执行，如果parent无法加载才会由当前加载器来加载。</li><li>其中，parent是ClassLoader定义的，用户自定的时候可以设置该ClassLoader的parnet是谁</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152307708.png" alt="img" style="zoom:67%;" /><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><p>这样可以保证java核心的API不会被篡改，保证程序的稳定性，不然用户自己定义一个java.lang.String，如果不是双亲委派机制，那直接由AppClassLoader加载，以后所有的String都是用户自定义的String了</p><p>但是有了双亲委派机制，可以保证java核心类库的东西都由BoostrapClassLoader加载，而BootstrapClassLoader是JVM定义的，这样保证了一定的封闭性</p></li><li><p>同时，双亲委派机制可以保证类不会重复加载，低及加载器不会在高级加载器之前加载类</p></li></ul><p>其实，保证java核心类库有两个方面：</p><ul><li>首先，核心类库只由BootstrapClassLoader加载，保证核心类库不会歧义</li><li>其次，如果用户自定义了一个java.lang的类，但是核心类库中没有，BootstrapClassLoader会拒绝加载，保证BootstrapClassLoader不受到攻击</li></ul><blockquote><p><strong>这样才能形成一个闭环，核心类由自己人加载，自己的加载器只加载自己人</strong></p><p>这个其实也是java的<strong>沙箱安全机制</strong>的一个组件，保证核心类库不会被破坏</p></blockquote><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152307442.png" alt="img" style="zoom: 50%;" /><p>这就是java运行时数据区的完整架构图：</p><ul><li>两个栈区：本地方法栈和虚拟机栈，其中虚拟机机栈很重要，这两个栈都是<strong>线程私有</strong>的</li><li>程序计数器：PC计数器，也是<strong>线程私有</strong>的</li><li>堆区：分为eden区、survivor区、old区等，这个是存放对象的地方，是<strong>线程共享</strong>的</li><li>方法区：JDK1.8以后从堆中移出来作为元空间，以前是放在堆中作为永久代，<strong>线程共享</strong></li><li>JIT编译产物：JIT会把热点代码编译好，不用JVM解释执行，那么编译的产物就放在这里</li></ul><p>Java有一个Runtime对象，这个我们就可以理解为是运行时数据区，这是一个单例，一个JVM进程只有一个</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>在这里，我们需要明确一点，这里的程序计数器虽然英文名称之为PC register，但是他并不是CPU中的那个物理PC寄存器，而是JVM的一个抽象，因此我们还是叫他程序计数器</p><p>程序计数器是放在内存里面的，由于一个线程只有一个方法正在运行，因此它指向的就是当前方法执行的JVM指令的地址，如果是native方法，则为undefined</p><p>当前JVM指令执行完后，就会更新PC为下一条指令的地址，由于执行引擎只会操作当前栈帧，因此程序计数器指向的地址就是当前栈帧中的字节码地址，不需要考虑指令index的歧义</p><h3 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h3><p>在JVM中，栈是运行时的单位，堆是存储单位，这个要分清楚。栈解决的是程序运行时问题，而堆解决的是数据存储的问题</p><p>而虚拟机栈，就是把每一个方法当作一个栈帧保存下来，保存方法的局部变量、部分结果，并参与方法的调用和返回</p><p>每个线程在创建的时候，都会创建一个虚拟机栈，其中每一个栈帧（stack frame），对应着一次次的Java方法调用，也就说栈顶就是当前运行的方法</p><p>而且相比于程序计数器，栈是有可能出现异常的，但是它不会有GC，简单的来说会出现两种异常：</p><ul><li>如果栈内出现溢出，比如无限循环的递归等，就会出现<code>StackOverFlowError</code></li><li>如果线程创建过多，导致内存无法为新线程分配栈，就会出现<code>OutOfMemoryError</code></li></ul><h4 id="栈的运行原理和存储结构"><a href="#栈的运行原理和存储结构" class="headerlink" title="栈的运行原理和存储结构"></a>栈的运行原理和存储结构</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170033580.png" alt="image-20240617003344506" style="zoom: 50%;" /><p>每个线程都有自己的栈，在栈内是以<strong>栈帧</strong>为基本单元存储的，而栈帧又是一块内存区域，里面维护着执行方法的各种数据信息，而执行引擎执行的字节码只会对当前栈帧操作</p><p>如果当前方法调用了其他方法，那么在上层栈帧返回之前会将执行结果传给底下的栈帧，然后再弹出</p><blockquote><p>要注意的是，方法的返回分为两种：正常的return；抛出异常且未处理。这两种方式都会导致栈帧弹出</p><p>也就是说<strong>往上抛出异常，其实就是出栈前返回的数据是异常类</strong>，如果最终到main函数都没有try catch，那main函数就会直接终止，因为你已经走到最后一个栈帧了</p></blockquote><p>此外，栈帧的内部还分为以下五个部分</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170055170.png" alt="image-20240617005513122" style="zoom:67%;" /><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><h4 id="存放内容"><a href="#存放内容" class="headerlink" title="存放内容"></a>存放内容</h4><p>局部变量表存放的就是，该方法的参数、方法体内的局部变量、returnAddress类型等，也就是说<strong>局部变量只存放基本数据类型和对象引用（指针）</strong></p><p>并且局部变量表的大小是在编译的时候就已经确定好了，这个是预编译好的最大的局部变量表的大小，不一定真正运行的时候，一定就是那么大，因为程序运行中会有报错、if&#x2F;else分支等操作</p><p>在局部变量表中，最基本的存储单元是slot，除了double和long占两个slot外，其他的数据类型如byte、char、boolean、对象引用（开了指针压缩）等都是会转换为int类型，在表中占一个slot</p><blockquote><p>当前方法如果不是static方法，那局部变量表的第一个index0的位置会<strong>放一个this引用</strong>，然后剩下的才会往后放到表中</p></blockquote><h4 id="长度以及内容的优化"><a href="#长度以及内容的优化" class="headerlink" title="长度以及内容的优化"></a>长度以及内容的优化</h4><p>字节码中的局部变量表很有意思：</p><ul><li><p>如果一个局部变量在代码块中只是声明了，但是没有用到，那么局部变量表就不会有这个，但是字节码中的局部变量表的最大长度会算上它，而且还会根据if else来取最大值，这个十分有意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如下面这段代码的max length是3：i，this，j或k，而局部变量表只显示：i和this，因为只是声明没有使用。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170150416.png" alt="image-20240617015041386" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170150575.png" alt="image-20240617015013519" style="zoom: 50%;" /><p>但是只有声明没有使用是代码块中，你看i也只是声明（<code>int i=0;</code>可以，但是<code>int i;</code>仍然不会写到局部变量表中）没有使用，但是它不在代码块中，因此还是会有</p></li><li><p>此外，局部变量表还有复用的情况，一旦发现有局部变量走出作用域，正好作用域后面声明了一个新的局部变量，那么这两个变量就会使用同一个slot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        i=j+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        i=k+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> h=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码的max length以为是4？，其实还是3，因为h和k、j的作用域是互斥的，然后h和j是if&#x2F;else互斥的，因此最后<strong>其实h、k、j是可以共用一块区域的</strong>。如下：全是用的slot2：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170154711.png" alt="image-20240617015400667" style="zoom:50%;" /></li></ul><h4 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h4><ul><li>它和JVM调优比较密切</li><li>方法执行的时候，使用局部变量表完成方法传递</li><li>局部变量表中的引用变量作为GC的root节点</li></ul><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每一个独立的栈帧除了有一个局部变量表以外，还有一个操作数栈</p><p>执行引擎会根据字节码，把一些数据压栈，或者取出栈中的几个数据进行计算，并将计算结果重新压栈。<strong>这也就是为什么执行引擎是基于栈的原因</strong></p><p>如果调用的方法有返回值，那么其返回值也要被压入栈中</p><p>操作数栈和局部变量表一样，也会在编译期间就已经决定了大小，但是运行期间内部的数据都会一直在变化</p><h4 id="操作数栈和局部变量表的关系"><a href="#操作数栈和局部变量表的关系" class="headerlink" title="操作数栈和局部变量表的关系"></a>操作数栈和局部变量表的关系</h4><p>在方法调用也就是栈帧刚创建的时候，操作数栈和局部变量表都是空的，执行引擎会根据字节码对操作数栈操作</p><p>那么局部变量表是如何变化的呢？</p><ul><li>执行引擎会现根据字节码把数据读到栈里，然后调用<code>store</code>指令出栈并将结果存入局部变量表</li><li>当需要局部变量表的数据的时候，会先依次将要操作的变量通过<code>load</code>指令读到栈里，再执行操作（如add）</li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>目前看来，就是当调用一个方法的时候，需要将方法的符号引用转化为运行时常量池的直接地址</p><p>那么动态链接指向的就是方法区中，运行时常量池该方法符合引用的真实地址</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406172241735.png" alt="img" style="zoom: 50%;" /><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>这个看完字节码再说吧，我现在也搞不明白</p><p>但是有一点要搞明白，就是栈帧单元中有一个方法返回地址的字段，他记录的就是上一个栈帧弹出后，底下栈帧对应的方法应该从哪行字节码运行</p><p>我个人觉得方法返回地址，应该是方法调用创建栈帧的时候把当前程序计数器的值保存到被调用方法的栈帧中，然后再将程序计数器的值改为被调用方法的入口字节码地址</p><p>方法返回地址只针对于正常return的情况，发生异常处理不一样，我们后面再看</p><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>运行时数据区里面有一个本地方法栈，所谓的本地方法调用的就是C++编写的方法</p><p>为什么要使用本地方法呢？</p><ul><li>与Java环境外交互，让我们无需去了解Java应用以外的繁琐细节</li><li>与操作系统交互，为了提高程序执行效率，比如线程的start方法，底层就调用了native的<code>start0</code></li></ul><p>既然使用了本地方法，运行时数据区就有一块本地方法栈，来供本地方法使用</p><p>本地方法栈和虚拟机栈差不多，也会出现StackOverflowError和OOM，但是不会出现GC</p><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><p>堆是运行时数据区的一部分，但是由于堆的内容很多很重要，我们这里把堆单独作为一大节</p><p>以下是堆、栈、方法区三者的关系：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406180140353.png" alt="image-20240618014058269" style="zoom:50%;" /><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>堆在JVM进程中是唯一的，一个JVM进程只有一个运行时数据区，也只有一个堆</p></li><li><p>堆的空间是固定的，在JVM进程创建的时候，堆的大小就已经确定下来了</p><ul><li>堆大小的JVM参数有两个分别是<code>-Xms</code>（堆初始大小）和<code>-Xmx</code>（堆最大大小）</li></ul></li><li><p>堆是GC的主要区域，方法区也会有GC但是比例不大，GC又是JVM调优主要的关注对象</p></li></ul><p>堆的具体内存结构如下，要注意的是JVM参数设置的堆空间大小只有新生代和老年代（JDK7和JDK8都是）</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406180150099.png" alt="image-20240618015047008" style="zoom: 40%;" /><p>以上是堆的基本理论，但是还有几个平时不会注意的问题：</p><ul><li>堆空间不一定物理上连续，但是逻辑上是连续的</li><li>所有线程共享Java堆，但是不是共享所有的堆空间。堆中可能还会划分一小块区域，作为线程的<strong>私有的堆缓冲区TLAB</strong></li><li>不是所有的对象一定会在堆中分配内存，如果逃逸分析后没有逃逸出去，可以在栈上直接分配</li><li>堆内存的实际可用空间是小于JVM参数分配的空间的，因为<strong>S0和S1区只会有一个使用</strong></li></ul><h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>Java对象可以被分为两类，分别是生命周期较短的瞬时对象和生命周期较长的对象</p><p>由于生命周期较长的对象一般不会被GC，因此<strong>为了优化GC性能</strong>，JMV把堆空间分成了新生代和老年代。</p><p>其中新生代可以进一步分为Eden区、Survivor0区、Survivor1区。新生代可以经常GC，但是老年代原则上应该GC少点</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406182334191.png" alt="image-20240618233406091" style="zoom:50%;" /><p>新生代和老年代的大小可以通过<code>-XX:NewRatio</code>参数来修改，他代表老年代和新生代大小的比例。默认是2，代表老年代是新生代的2倍，并且此参数一般不会修改</p><p>同样新生代中的Eden区和Survivor区也可以通过参数<code>-XX:SurvivorRatio</code>来调整，但是要注意的是Survivor区有两个，配置的比例是Eden区和其中一个Survivor区的比例。也就是说如果设置为8，那么就表示Eden区占8&#x2F;10，而另外两个Survivor区分别占1&#x2F;10</p><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p>首先，我们抛开特殊情况不谈，先来说一说<strong>基本流程</strong>：</p><ul><li>当一个对象创建的时候，会先放到Eden区</li><li>如果Eden区放不下，那么<strong>在Eden区创建对象之前</strong>，会做下面几件事：<ul><li>做一次YonugGC，清理掉Eden区Survivor区的垃圾，同时新生代所有对象GC年龄（存在对象头中）<code>+1</code></li><li>将原本Eden区、from区存活下来的对象放到to区，然后to变成下次的from，from变成下次的to</li><li>超过年龄阈值（默认为15，可通过<code>-XX:MaxTenuringThreshold</code>参数设置）的对象直接转移至老年代</li></ul></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190052195.png" style="zoom:67%;" /><p>这里要注意的是，<strong>Survivor区是被动GC的</strong>，只有Eden区满了才会GC整个新生代，Survivor区不会主动GC</p><p>上述是基本流程，但是仍然会有一些<strong>特殊情况</strong>：</p><ul><li><p>Young GC后，Eden区还是放不下</p><p>那就说明是超大对象，因此会直接往Old区放，如果Old区放不下就会执行Full GC</p></li><li><p>Young GC后，往to区放的时候放不下</p><p>一般来说，Young GC的时候都会往to区放，首先会看是否到年龄阈值，到了就放到old区</p><p>然后如果没到，但是往to区放的时候发现放不下，那也会直接放到old区</p></li></ul><p>因此最终，对象分配的大致流程就是下面这样：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190100664.png" alt="image-20240619010000561" style="zoom: 40%;" /><p>此外，JVM还提供了几个比较重要的晋升老年代的规则：</p><ul><li><p>大对象直接进入老年代</p></li><li><p>Survivor区晋升老年代，还有一种动态的年龄判断：这个不用等到maxTenuringThreshold才去晋升，而是那个动态年龄阈值（排序后的空间百分比）</p></li></ul><h3 id="空间担保机制"><a href="#空间担保机制" class="headerlink" title="空间担保机制"></a>空间担保机制</h3><p>在Minor GC之前，其实还有一次判断：</p><ul><li>如果发现新生代大小比老年代剩余区域小，那就说明即使Minor GC每一个垃圾且全部放到老年代都能放下，那么就说明本次Minor GC安全，可以执行</li><li>如果发现放不下且开启空间担保（<code>-XX:HandlerPromotionFailure=true</code>）则：<ul><li>要是老年代可用空间，大于以前每次MinorGC晋升到老年代空间的平均值，则进行一次有风险的Minor GC</li><li>否则直接Full GC（没开启，或者小于平均值）</li></ul></li></ul><blockquote><p>空间担保机制在JDK7以后强制开启，即使保留了<code>-XX:HandlerPromotionFailure</code>参数，但是不会使用</p></blockquote><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p>JVM的GC的时候并不是每次都会对整个堆空间GC，其实一共有三种方式：Minor GC、Major GC、Full GC</p><p>在HotpotJVM中，GC可以大致分为两种：整堆GC和部分GC</p><ul><li><p>整堆GC：Full GC，会对<strong>整个堆空间+方法区</strong>做一次GC，包括所有的新生代和老年代</p><p>因此老年代空间不足和方法区空间不足，都会触发Full GC</p></li><li><p>部分GC：Minor GC（Young GC）和Major GC（Old GC），这里一定要区别Major GC和Ful GC</p><ul><li>Minor GC是针对整个新生代，且只会由Eden区满了后主动触发</li><li>Major GC是针对整个老年代，但是目前<strong>只有CMS会有Major GC</strong></li><li>上述混合就是Mixed GC，这个是整个新生代+部分老年代，这个目前<strong>只有G1有Mixed GC</strong></li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><p>由于堆是线程共享的区域，因此当多个线程同时创建对象的时候就会出现操作同一块内存的线程不安全问题</p><p>为了解决这个问题，简单粗暴的解决办法就是加锁来实现对象创建，但是这会大大降低JVM性能</p><p>所以TLAB就出现了，它会<strong>在Eden区为每个线程分配一块私有区域</strong></p><blockquote><p>当线程把这块TLAB用掉后，就会归还给Eden区作为共享区域，然后重新分配TLAB区域</p><p><strong>分配TLAB的时候还是会CAS，因为这个时候同样也是线程不安全的</strong></p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190148915.png" alt="image-20240619014834807" style="zoom: 40%;" /><p>但是，TLAB实际上很小，如果对象占用空间大于TLAB大小，那么还是会通过<strong>CAS</strong>的方式去共享区域分配内存</p><h3 id="堆空间的JVM参数"><a href="#堆空间的JVM参数" class="headerlink" title="堆空间的JVM参数"></a>堆空间的JVM参数</h3><p>首先要说的是对于<code>-XX:-啥啥啥</code>，由于前面是减号，因此表示禁用某个功能</p><p>相反对于<code>-XX:+啥啥啥</code>，前面是加号，因此表示开启某个功能，前面没有符号默认是加号</p><ul><li><code>-Xms</code>、<code>-Xmx</code>、<code>-Xmn</code>：堆空间初始大小、堆空间最大大小、新生代大小</li><li><code>-XX:NewRatio</code>、<code>-XX:SurvivorRatio</code>：老年代和新生代的比值、Eden和Survivor的比值</li><li><code>-XX:MaxTenuringThreshold</code>：晋升Old区的年龄阈值</li><li><code>-XX:+PrintGCDetails</code>、<code>-XX:PrintGC</code>：打印GC详细日志、打印GC简略日志</li><li><code>-XX:HandlerPromotionFailure=true</code>：开启空间担保</li></ul><h3 id="堆与逃逸分析"><a href="#堆与逃逸分析" class="headerlink" title="堆与逃逸分析"></a>堆与逃逸分析</h3><p>Hotspot编译器可以通过逃逸分析，分析出对象是否只在本方法内使用</p><p>如果发现没有逃逸出去，则会<strong>考虑将对象分配在栈上</strong>，因此在开发中能定义局部变量就定义局部变量</p><p>其实逃逸分析，不仅仅只是对堆优化，它可以做到很多好处：</p><ul><li><strong>栈上分配</strong>：经过逃逸分析后发现对象没有逃逸，则可以考虑不在堆中分配对象，而是直接分配在栈上</li><li><strong>同步省略</strong>：如果一个对象只会在一个线程中被访问到，那么这个对象就可以不用考虑同步了，即<strong>锁消除</strong></li><li><strong>标量替换</strong>：标量指的就是基础数据类型，如果发现一个对象没有逃逸出去，则可以将成员变量拆出来，分成多个基础数据类型放到栈上</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈、堆、方法区的交互"><a href="#栈、堆、方法区的交互" class="headerlink" title="栈、堆、方法区的交互"></a>栈、堆、方法区的交互</h3><p>这三个是运行时数据区最重要的结构了，那么这三个在程序运行中是如何交互的呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406192323877.png" alt="image-20240619232327759" style="zoom:50%;" /><p>大概交互关系就是这样的了，栈中放的对象引用，堆中放的是对象实体，其中对象实体有一个标注该对象类型的指针，指向方法区中对应的对象类型数据块</p><p>方法区和堆一样，也会GC（JDK8并没有强制要求，但是Hotspot实现了），也会OOM，也是线程共享的</p><p>它逻辑上是堆的一部分，但是需要特殊对待，当JVM加载了太多的类，就会出现方法区OOM错误</p><h3 id="Hotspot中的方法区"><a href="#Hotspot中的方法区" class="headerlink" title="Hotspot中的方法区"></a>Hotspot中的方法区</h3><p>对于HotSpot虚拟机来说：</p><ul><li><p>JDK7以前的方法区放在堆中，定义为永久代，大小可用<code>-XX:PermSize=100m</code>，<code>-XX:MaxPermSize=100m</code>设置</p></li><li><p>JDK8以后方法区从堆移出来，定义为元空间，大小可用<code>-XX:MetaspaceSize=100m</code>，<code>-XX:MaxMetaspaceSize=100m</code>设置</p></li></ul><p>因为永久代是放在堆中的，使用的是JVM内存；而元空间从堆中移出来，直接使用<strong>本地内存</strong>（计算机的内存资源），因此永久代相比于元空间更容易OOM</p><h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p>一般来说方法区存储的就是类型信息、域信息、方法信息、运行时常量池、静态变量、JIT编译缓存等信息</p><p>但是随着JDK版本的演变，还是会对里面的一些细节做了优化，比如字符串常量池从方法区移到堆中去了</p><ul><li><p>类型信息：class、interface、annotation、enum这些都是类型。需要存放的有：</p><ul><li>全限定名</li><li>父类是什么，但是对于interface、Object这两个来说没有父类</li><li>修饰符，比如public、abstract</li><li>实现的接口列表，按照定义类时候声明的顺序</li></ul><blockquote><p>java为单继承，因此类型信息中父类是字段，而接口是列表</p></blockquote></li><li><p>域信息：就是类中声明的成员变量，域信息会按照类中成员变量声明的顺序存储，包括：名称、修饰符、类型</p></li><li><p>方法信息：就是类中定义的方法，同也会按照声明顺序保存，同样也会保存名称、类型、修饰符</p><p>但是除了这些以外，还会保存方法的字节码、操作数栈和局部变量表的大小、异常表等等</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>在方法区中，除了类型信息（类信息、方法信息、域信息）以及JIT缓存以外，还有一个很重要的内容就是运行时常量池，这块部分重要到我把他单独拎出来讲</p><p>运行时常量池是和字节码文件中的常量池是对应的，类加载的时候会把字节码文件加载到方法区，这个时候就会读取类信息，并且把常量池读取到方法区生成运行时常量池</p><p>因此在了解运行时常量池之前我们需要搞清楚字节码中的常量池</p><h4 id="字节码中的常量池"><a href="#字节码中的常量池" class="headerlink" title="字节码中的常量池"></a>字节码中的常量池</h4><p>字节码中有一个常量池表，包括<strong>各种字面量和对类型、域、方法的符号引用</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406200118005.png" alt="image-20240620011828859" style="zoom: 40%;" /><p>看起来感觉很累赘的样子，为什么要搞这个东西？</p><p>字节码往往需要数据支持，比如方法的返回值、父类等等信息，这些不可能事先一股脑全写到字节码中，这样会造成字节码文件更大。因此，就使用常量池，当动态链接的时候会让这些引用指向真正的地方</p><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>在每个类被加载后，就会为这个类生成一个运行时常量池，这个常量池就不再是符号引用了，而是指向的直接内存地址。</p><ul><li><strong>符号引用</strong>：类似常量池表中的CONSTANT_Class_info、CONSTANT_Fieldref_info这种东西，它实际上是用这样的常量代替了，因为还没有加载到内存，无法知道真正的内存地址</li><li><strong>直接引用</strong>：当被加载到内存，会根据不同的符号引用类型，解析程不同的符号引用，这其实就是连接阶段的解析过程做的事情。不同的符号引用会有不同的方式，比如：<ul><li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li><li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li><li>一个能间接定位到目标的句柄</li></ul></li></ul><blockquote><p>运行时常量池的内容并不是字节码中常量池确定好的，他虽然会加载字节码常量池的信息，但是在程序运行过程中，还会<strong>动态变化</strong>（<code>String.intern()</code>方法）</p></blockquote><h3 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h3><p>在说之前，需要明确一点：只有hotspot虚拟机有永久代；像Jrockit、J9这些只有元空间</p><p>那么HotSpot方法区到底是怎样变化的呢？</p><ul><li>JDK6及以前，用的永久代，并且字符串常量池、静态变量也放在永久代中</li><li>JDK7的时候，有永久代，但是字符串常量池、静态变量被拿出来了，放在了堆中</li><li>JDK8及以后，就从永久代转成直接内存的元空间了，但是<strong>字符串常量池和静态变量还是放在堆中</strong></li></ul><p>那为什么这就会有两个问题：</p><ul><li><p>为什么要从永久代到元空间呢？</p><p>要知道，永久代的内存大小是受JVM内存管控的，而元空间的内存使用的是直接内存和计算机内存资源挂钩</p><p>因此，永久代在设置大小的时候无法控制，而元空间满了的话就说明计算机内存不够用了，那也没有办法</p></li><li><p>为什么要把字符串常量池和静态变量放到堆中？</p><ul><li><p>首先，字符串会在程序运行中大量的缓存到常量池，很容易造成方法区空间不足造成OOM</p></li><li><p>其次，字符串常量应该被经常回收，而在方法区中只能通过full GC回收，因此转移至堆中</p></li></ul><blockquote><p>这里要注意的是，字符串常量池是放在堆中，但是静态变量是放在堆中Class对象的里面</p></blockquote></li></ul><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>Java虚拟机规范并没有强制要求JVM的方法区要做GC，但是HotSpot实现了方法区的GC</p><p>HotSpot虚拟机对方法区的GC主要是两个部分：常量池中废弃的常量以及不再使用的类</p><p>其中，废弃的常量回收很简单，就是不在引用了就直接回收，和对象的GC差不多</p><p>但是类的回收就很麻烦，需要满足下面<strong>三个条件</strong>：</p><ul><li>该类创建的所有实例（包括子类、实现类等），都被回收了</li><li>加载该类的加载器被回收了，基本只有自定义的加载器才会满足，很难</li><li>对应的Class对象没有被引用，即没有反射调用该类</li></ul><p><strong>到此，我们整个的运行时数据区就差不多了</strong>，最后我们应该能画出这样一个图出来：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406210006868.png" alt="image-20240621000559662" style="zoom: 33%;" /><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="从字节码看"><a href="#从字节码看" class="headerlink" title="从字节码看"></a>从字节码看</h4><p>当调用一个new方法的时候，会产生三个字节码：new、dup、invokespecial</p><ul><li>new：在堆中开辟一块内存，并给成员变量设置为零值</li><li>dup：开辟内存后，就会将对应的引用压栈，dup就是将栈顶的引用复制一份，因为其中有一个需要给构造方法用，用完就没了</li><li>invokespecial：调用构造方法</li></ul><h4 id="从执行流程来看"><a href="#从执行流程来看" class="headerlink" title="从执行流程来看"></a>从执行流程来看</h4><p>其实执行流程和字节码类似，就是按照字节码的三个指令来，但是会更加细化：</p><ol><li><p>查看new的类是否被加载，要是没加载就要读取字节码文件，走类加载的那三步流程</p></li><li><p>为对象分配内存，会先根据字节码计算所需空间的大小，分配有两种方法：</p></li></ol><ul><li><p>堆空间的内存是规整的，这就需要GC算法是标记-整理，那就拿一个指针记录空闲区域的起始地址</p></li><li><p>如果不规整，这就需要GC算法是标记-清除，那就需要维护一个空闲链表</p><p>当然，在分配内存的时候需要处理<strong>并发问题</strong>，同样也有两种方法：TLAB或者CAS</p></li></ul><ol start="3"><li><p>初始化分配的空间，就是设置为零值</p></li><li><p>设置对象头，也就是markword+classpointer，如果数组的话，会多一个length</p></li><li><p>执行构造函数</p><p>这里构造函数不仅仅就是你写的那个，他还会像clinit一样，收集成员变量、代码块的情况，在编译的时候也加到字节码里面去。比如下面的代码，最后的<code>&lt;init&gt;</code>方法字节码其实是id+name+account三个字段的赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-type">long</span> id=<span class="hljs-number">100L</span>;<br>    String name;<br>    Accout accout ;<br>    <br>    &#123;<br>        name=<span class="hljs-string">&quot;default name&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br>        account=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><blockquote><p>在说这个之前，我们要先讲讲Java的引用大小问题：</p><p>在64位的OS中一个指针的大小是8B的，但是Java默认开启了<strong>对象头指针压缩</strong>和<strong>成员变量对象指针压缩</strong>，压缩后的指针大小会从8B变成4B</p></blockquote><p>下面来聊一聊对象内存布局，我们以64bit的hotpot JVM为例：</p><p>对象内存布局分为两种，一个是普通对象，一个数组对象</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406032351484.png" alt="image-20240603235114382" style="zoom: 33%;" /><ul><li><p>一个对象分为三个部分：</p><ul><li><p><strong>对象头</strong>，包括markword、class pointer等</p><ul><li>markword，存储了hashcode、GC age等等，并且当成为锁对象后会重写markword（后面再说）</li><li>class pointer，指向方法区类元信息的指针（<strong>不是Class类！</strong>），标注它属于哪个类，由于开启指针压缩因此就是4B</li><li>数组对象会多一个数组长度信息</li></ul></li><li><p><strong>实例数据</strong>，存放数据的地方，但是如果这里有对象，那么就是指针的大小，由于默认开启了指针压缩，因此也是4B，<strong>数组的话就是所有数据按顺序堆叠起来</strong></p></li><li><p><strong>对齐</strong>，由于是64位的JVM，因此对齐按8B对齐</p></li></ul></li></ul><blockquote><p>注意：成员变量的long和Long占的字节分别是8B和4B</p></blockquote><h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>对象的访问方式一共有两种：直接访问和句柄访问。直接上图：</p><ul><li><p>句柄访问</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406210040767.webp" alt="img" style="zoom: 80%;" /></li><li><p>直接访问</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406210039514.webp" alt="img" style="zoom:80%;" /></li></ul><p>其中直接引用时hotSpot的实现，从对象头也可以看出来</p><p>因为句柄访问需要额外空间，并且还需要两次的地址访问，既耗时间又耗空间</p><p>但是句柄相对直接引用更灵活，可以更好的应对发生GC后对象的移动情况（晋升、标记-整理等）</p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>执行引擎是Java虚拟机的核心组成部分之一，但是和基于物理机的执行不同的是：</p><ul><li>物理机的执行引擎是直接基于机器指令和、处理器等部分的</li><li>虚拟机的执行引擎是软件实现的，不会受到硬件平台的限制</li></ul><p>也就是说JVM的执行引擎就是将Java字节码的指令解释（<strong>解释器</strong>）&#x2F;编译（<strong>JIT</strong>）为对应平台的机器指令</p><p>从运行时数据区的角度来看，执行引擎就是根据程序计数器的值，去执行对应的指令，然后根据指令对栈进行操作，比如局部变量表、操作数栈、新建一个栈帧等等</p><p>由于，执行引擎在执行字节码的时候，可能会解释执行，也可能通过JIT编译后的代码编译执行，因此Java语言是一门半解释半编译的语言</p><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>JVM设计的初衷就是跨平台性，实现跨平台性的方法就是设计了不同平台的JVM，这样可以保证对于不同平台，可以将相同的字节码翻译成对应的机器指令</p><p>那么解释器做的事情就是这个，不同平台的JVM解释器是不一样的，它可以根据当前平台的指令集，将字节码翻译成指定的指令，然后在对应平台上执行</p><p>但是这样做会导致程序运行的很低效，因为同一条字节码每次执行都需要翻译一遍。为了解决这一痛点，JIT即时编译器就出现了，它可以将部分代码提前编译好，等运行的时候直接运行就可以了</p><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="编译器分类"><a href="#编译器分类" class="headerlink" title="编译器分类"></a>编译器分类</h4><p>Java编译器可以大致分为三种，分别是Java到字节码的编译器、JIT编译器、AOT编译器</p><ul><li>Java到字节码编译的过程，一般就是用sun的javac</li><li>JIT编译器是Hotspot比较重要的，有C1和C2</li><li>AOT编译器是直接完全将字节码翻译为机器码，比如GCJ（GNU compiler for the java）</li></ul><h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><p>为什么要搞这么个东西，而且又要把两个不同模式进行穿插使用呢？</p><p>我们要明确JIT和解释器的差别：</p><ul><li>JIT是编译完在执行机器码，执行起来速度很快，但是编译会耗费一定时间</li><li>解释器是上来就可以解释执行，但是每条字节码执行起来会慢点</li></ul><p>因此，最终JVM一个也没有抛弃，逐渐演变成了一个半解释半执行的语言</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>在HotSpot虚拟机中（JRockit没有用解释器），一个<strong>Java程序启动后</strong>：</p><ul><li>首先，解释器直接开始执行字节码，可以尽可能减小启动时间</li><li>然后，随着解释器的执行，JIT会通过热点探测找出热点代码，将其编译然后存放到方法区的JIT cache中</li><li>如果在解释执行的过程中，发现该代码块边JIT编译缓存了，那么就直接拿出来执行</li><li>最后，随着时间的推移，越来越到的代码被编译成机器码，程序会越来越快</li></ul><blockquote><p>这也就是为什么，Spring程序启动后，多发几次请求，后面的请求会比第一次快的原因之一</p><p>阿里为了解决这个问题，也采用了分批启动的方式，给出冷机和热机这样的名词</p></blockquote><h3 id="热点代码及探测"><a href="#热点代码及探测" class="headerlink" title="热点代码及探测"></a>热点代码及探测</h3><p>在HotSpot中，会实时的根据执行情况分析出热点代码，然后将其翻译为机器码缓存到方法区</p><p>那么什么才是热点代码呢?</p><p>其实就是根据执行频率来定的，比如被多次调用的方法或者循环次数很多的循环体（次数是通过计数器来计算的），而这也正好分成了两种方式，方法和循环</p><h4 id="方法JIT"><a href="#方法JIT" class="headerlink" title="方法JIT"></a>方法JIT</h4><p>方法使用的计数器叫做<strong>方法计数器</strong>，，其阈值进行即时编译是通过<code>-XX:CompileThreshold</code>来人为设定的</p><p>具体替换，其实就是栈上替换，因为一个方法就是栈帧，可以直接替换掉原本的栈帧，流程如下：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406240028093.png" alt="image-20240624002809965" style="zoom: 40%;" /><blockquote><p>要注意的是，JIT的阈值<strong>并不是一个绝对次数</strong>，如果程序超过规定的时间，阈值就会减半（称之为半衰期），可用参数<code>-XX:CounterHalfLifeTime</code>来规定半衰期大小</p></blockquote><h4 id="循环JIT"><a href="#循环JIT" class="headerlink" title="循环JIT"></a>循环JIT</h4><p>循环的使用的计数器叫<strong>回边计数器</strong>，大概思路和方法JIT差不多</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="String的基本使用"><a href="#String的基本使用" class="headerlink" title="String的基本使用"></a>String的基本使用</h3><p>String可以通过字面量的形式或者new的形式构造出来，因为它很容易被我们当作是一种基本数据类型</p><p>String类实现了Serializable接口实现序列化，实现Comparable接口实现比较、排序</p><h4 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h4><p>String底层数据结构在不同JDK版本是不一样的，要注意的是JDK9及以后，从char数组改为了byte数组，因为Java团队发现大部分时候String存储的都是8字节的编码形式的数组，如果使用char会造成一半的空间浪费（相关的StringBuilder也修改了）</p><p>但是为了兼容16字节编码的字符串，JDK9及以后使用了byte+编码（决定是按1字节decode还是2字节decode）的形式来表示字符串</p><h4 id="String的不可变"><a href="#String的不可变" class="headerlink" title="String的不可变"></a>String的不可变</h4><p>String是不可被修改了，可以从两个角度来看：</p><ul><li><strong>String内部的存储结构</strong>（不管是char数组还是byte数组）是声明为final，</li><li><strong>String类也是声明为final</strong>的，因此String类无法被继承也没有暴露可修改的方法，甚至底层数据结构本身也无法修改</li></ul><h4 id="String底层的HashTable"><a href="#String底层的HashTable" class="headerlink" title="String底层的HashTable"></a>String底层的HashTable</h4><p>StringTable其实是一个key为字符串，value为堆中String对象引用的哈希表</p><p>其大小固定（可用<code>-XX:StringTableSize</code>来设置），使用拉链法解决冲突，因此字符串常量池<strong>不会存储相同的字符串</strong>。</p><p>如果字符串过多导致链表过长，就会导致调用intern时间过长</p><h3 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h3><p>Java的8大基本数据类型以及String都有一个常量池，而String的常量池比较特殊，主要使用的方法有两种：</p><ul><li>如果通过字面量的形式new一个字符串，<code>String str = &quot;aaa&quot;</code>，那就会在常量池中创建一个这样的String</li><li>如果不是通过字面量的形式创建，则可以通过<code>intern()</code>方法，会先看常量池有没有，没有则创建</li></ul><blockquote><p>Java6及以前，字符串常量池放在永久代</p><p>Java7的时候，将字符串常量池以及静态变量移到堆里面去了</p><p>Java8提出元空间，字符串常量池和静态变量也都放在堆中</p></blockquote><p>那为什么要这样移动呢，其实有两个原因</p><ul><li>放在方法区的字符串常量池大小默认比较小，容易OOM</li><li>放在堆中的常量池，可以GC的更加频繁</li></ul><h3 id="String的拼接操作"><a href="#String的拼接操作" class="headerlink" title="String的拼接操作"></a>String的拼接操作</h3><p>String拼接其实就是Java唯一一个重载了的运算符<code>+</code>做的事情</p><p>其原理是先new一个StringBuilder，然后用append方法，然后最后调用toString方法new一个String对象返回</p><blockquote><ul><li><p>StringBuilder底层是一个char数组，调用toString方法的时候，就是用这个数组去new一个String</p><p>调用append方法的时候，如果超过char数组大小，会进行扩容操作</p></li><li><p>toString方法中的new String是通过char数组去new的，不会先在常量池new一个，再在堆new一个</p><p><strong>包括String.valueOf函数也是如此</strong></p></li></ul></blockquote><p>因此，如果不对该结果调用intern方法，那么其实两个字符串值相等，但是一个在常量池一个在堆中new了一个String对象，这两个地址是不一样的</p><p>只有调用了intern方法，返回了常量池中的地址，这样才会相同，如下方代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String s1=<span class="hljs-string">&quot;ab&quot;</span>;<br>    String s2=<span class="hljs-string">&quot;a&quot;</span>;<br>    String s3=<span class="hljs-string">&quot;b&quot;</span>;<br>    String s4=s2+s3;<span class="hljs-comment">//new String(&quot;ab&quot;)</span><br>    String s5=s4.intern();<span class="hljs-comment">//&quot;ab&quot;</span><br>    System.out.println(s1==s4);<span class="hljs-comment">//false</span><br>    System.out.println(s1==s5);<span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是有几种情况，是不使用StringBuilder拼接的，会直接通过<strong>编译器优化</strong>，将结果先写到常量池中：</p><ul><li>如果是两个字面量拼接，那就直接在编译的时候写到常量池里面去</li><li>如果是final的常量并且初始化了，即使后面用的是这些final的变量，那仍然会编译器优化</li></ul><h3 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h3><p>intern就是在字符串常量池中找该String，没有的话就new一个</p><p>它可以保证同一个字符串只有一个内存，减少空间的使用</p><p>但是有一点要注意，Java7及以后由于常量池从方法区移到堆中，为了进一步节省空间，当调用intern的时候：</p><ul><li><p>如果常量池中没有并且堆中有该String对象，那么就用这个String作为常量池中的String，即一个指针</p><p>也就是说<strong>StringTable其实是一个key为字符串，value为堆中String对象引用的哈希表</strong></p></li></ul><p>因此，<strong>在Java7及以后</strong>，下面两组代码结果是不一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//new String &quot;ab&quot;但是不是常量池的value</span><br>    String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>)+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    <span class="hljs-comment">//这里intren后，常量池中&quot;ab&quot;的value就指向了这个Stirng，因为没有，value直接指向调用intern的String</span><br>    s2.intern();<br>    String s1=<span class="hljs-string">&quot;ab&quot;</span>;<br>    System.out.println(s1==s2);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//先创建一个String&quot;ab&quot;作为常量池指向的地方，然后再new String给s2</span><br>    String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br>    <span class="hljs-comment">//调用intern的时候已经有了，并且不是s2的new String，而是new String里面的&quot;ab&quot;的new String</span><br>    s2.intern();<br>    String s1=<span class="hljs-string">&quot;ab&quot;</span>;<br>    System.out.println(s1==s2);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于Java6及以前，不管堆中有没有new String，只要方法区没有，那就new一个出来</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收有三大问题，因此我们下面也基本就这三大部分：</p><ul><li>哪些内存是需要被当作垃圾回收的？（垃圾标记算法）</li><li>什么时候回收垃圾？（垃圾清除算法）</li><li>怎么回收垃圾？（垃圾回收器）</li></ul><blockquote><p><strong>内存溢出和内存泄漏</strong></p><p>如果不进行垃圾回收的话，就会导致JVM的内存溢出，即OOM；</p><p>但是，如果存在一些不使用的对象无法被回收，那就会出现内存泄漏，并最终导致内存溢出</p></blockquote><h3 id="垃圾标记算法"><a href="#垃圾标记算法" class="headerlink" title="垃圾标记算法"></a>垃圾标记算法</h3><p>垃圾标记阶段算法有两个，分别是引用计数法和可达性分析法</p><p>一般来说，如果<strong>一个对象没有引用指向</strong>了，那就可以被认为是一个垃圾，因为没有引用指向就说明这个对象已经丢失了，无法找到这个对象了。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>这个算法比较简单，就是给对象设置一个属性，记录该对象被引用的次数</p><p>每当一个引用指向了它，那就让计数器加一，引用失效的时候，就让计数器减一。如果减为零那就说明它是一个垃圾</p><p>这种算法，虽然比较简单，但是缺点也是很多的：</p><ul><li><p>无法解决循环引用问题（主要缺点，JVM也因此没有用这个算法）</p></li><li><p>需要额外的空间来存储这个计数器，并且每次引用的变更都需要修改计数器</p></li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法是通过树来实现的，它通过GC roots集合组成了一个森林，只要对象和GC roots集合中的任意一个root相连，就可以被认为它不是一个垃圾</p><p>因此，这里比较重要的是GC root集合到底是哪些：</p><ul><li>虚拟机栈、本地方法栈中的引用对象</li><li>方法区中的静态属性引用的对象</li><li>synchronized持有的对象</li><li>JVM内部引用，比如Class对象、ClassLoader对象等等</li></ul><blockquote><p>除了这些常规的GC roots以外，如果是进行分代垃圾回收，比如只回收年轻代，那么老年代中的引用也可以作为GC roots</p><p>其实，可以总结为：<strong>不在当前垃圾回收范围内的引用，都可以作为GC root</strong></p></blockquote><p>如果要使用可达性分析算法，在分析的时候需要STW，不然准确性无法保证。</p><p>即使像CMS、G1这种的也是会有STW的标记阶段，来查找root和root的直接子节点</p><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>Object基类对象有一个finalize方法，当系统要GC的时候会先调用该方法，然后才会回收</p><p>finalize方法有可能会让当前被标记为不可达的对象在GC之前有一个复活的机会，这个机会<strong>有且仅有一次</strong>，一旦调用了并被复活，下次GC的时候就不会再调用了（用户手动调用除外）</p><p>也正是因为有了这个finalize方法，对象的生命周期也进一步被细化了：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301911274.png" alt="java-lifetime-of-finalizable-object" style="zoom: 80%;" /><p>当一个对象经过可达性分析算饭被标记为不可达后，具体流程如下：</p><ul><li>查看该对象是否重写了finalize方法（因为Object的finalize方法是空的，没必要执行），如果没有重写，那就直接GC掉</li><li>如果发现没有重写，并且没有被JVM执行过（用户手动执行不算），那么就会将其加入F-Queue队列（队列中存放的是JVM专门定义的<code>FinalizerReference</code>引用类型），等待单独的线程从队列里面拿出来执行finalize方法</li><li>执行完finalize方法，如果发现和GC roots中的节点产生联系，那就复活不进行GC；但是如果仍然没有产生联系，那就还是需要GC</li></ul><p>我们可以通过以下程序试验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 最终输出：</span><br><span class="hljs-comment">* Execute finalize method!</span><br><span class="hljs-comment">* Execute finalize method!</span><br><span class="hljs-comment">* Obj alive!</span><br><span class="hljs-comment">* Obj dead!</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test obj;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;Execute finalize method!&quot;</span>);<br>        obj=<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        <span class="hljs-comment">//手动调用，不影响GC调用</span><br>        obj.finalize();<br>        obj =<span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">//第一次GC，调用finalize方法</span><br>        System.gc();<br>        <span class="hljs-comment">//finalize方法单独线程执行，需要sleep等待执行完</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span>(obj==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Obj dead!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Obj alive!&quot;</span>);<br>        &#125;<br><br>        obj=<span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//第二次GC，不执行finalize方法了</span><br>        System.gc();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span>(obj==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Obj dead!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Obj alive!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="垃圾清除算法"><a href="#垃圾清除算法" class="headerlink" title="垃圾清除算法"></a>垃圾清除算法</h3><p>当通过垃圾标记算法找到最终需要被清理的对象过后，就要开始进行释放内存，然后腾出新的空间了</p><p>但是，释放内存后，这些内存空间怎么管理，怎么个释放法，这就是垃圾清除算法要做的事</p><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>这个就是遍历两次（会STW），第一次标记垃圾，第二次清除被标记为垃圾的对象，直接释放内存</p><p>但是这个算法会有很多缺点：</p><ul><li><p>需要STW</p></li><li><p>会产生大量内存碎片</p></li><li><p>要用额外的空闲链表来维护空闲空间</p><p>也就是说，该算法对应的对象的分配方式是使用的空闲链表法</p></li></ul><h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p>将原本的内存区域分为两块，每次清理的时候将存活的对象复制到另一块去，它比标记-清除算法更简单高效，还不会产生内存碎片</p><p>但是，也十分直观的：<strong>可用内存空间减少了一半</strong>。</p><p>此外，由于移动过后对象地址变了，而Java使用的是直接引用而不是句柄引用，因此需要<strong>修改相关的引用地址</strong>。尤其是像G1这种的，更要花空间和时间来维护region之间对象引用的关系。</p><p>而且当每次GC清除对象很少的时候，复制算法往往几乎复制了所有的对象到另一块内存中，这样效率会十低下，因此一般应用于新生代（比如<strong>Survivor区</strong>）</p><h4 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark-Compact）"></a>标记-压缩算法（Mark-Compact）</h4><p>上述提到，复制算法适用于垃圾对象多，存活对象少的情况下，十分不适用于老年代</p><p>但是，使用标记-清除算法又会导致内存碎片，如果是空间担保机制，很容易OOM</p><p>为此，又提出了一个适用于老年代的标记-压缩算法：</p><ul><li>仍然是先标记，但是清除的时候不是直接释放内存，而是将存活对象往一边移动，这样可以防止内存碎片产生</li></ul><p>同样，也是有一些缺点的：</p><ul><li>移动的时候需要STW</li><li>仍然需要修改引用的地址</li></ul><h3 id="垃圾回收算法的一些优化"><a href="#垃圾回收算法的一些优化" class="headerlink" title="垃圾回收算法的一些优化"></a>垃圾回收算法的一些优化</h3><p>现有的垃圾回收算法（标记和清理），都比较单一，缺点也是十分明显的，如何融合起来做适配，就是我们下面要说的优化问题了</p><h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><p>上述三个算法都只是单纯的算法罢了，而Java堆内存是分代的，每个代都有自己的特点</p><p>比如年轻代垃圾多，存活时间短，老年代垃圾少，存活时间长等等</p><p>因此目前的JVM对于不同区的垃圾清理，一般是使用不同的算法，这也就是<strong>分代回收算法</strong></p><p>在Hotspot中，是这样做的：</p><ul><li>年轻代：<strong>复制算法</strong>。复制的target是to区，复制的source是eden区和from区</li><li>老年代：<strong>标记-压缩+标记-清除混合实现</strong>。比如CMS回收器，具体后面再说</li></ul><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>由于现有的垃圾回收算法，都需要STW挂起用户线程，一旦挂起时间过长，就会影响用户体验</p><p>为此，提出了一种增量收集算法：</p><ul><li>让垃圾收集线程和应用线程交替执行，将垃圾回收划分为多个阶段（并发标记、并发清理等）</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301908306.png" alt="CMS 收集器" style="zoom:80%;" /><p>但是，这种方法会导致线程的频繁的切换，系统性能也会下降</p><h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>将对空间划分为多个Region，然后根据停顿的时间，每次回收合适数量的Region</p><p>该算法完全颠覆了传统的JVM堆内存结构，将内存结构<strong>从物理分代转变为逻辑分代</strong>，比如G1</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301908632.png" alt="g1 GC内存布局" style="zoom:67%;" /><blockquote><p>其实这些都只是一些小的优化思想，在这里说一点是为了后面直接看垃圾回收器不懵逼，真正的垃圾回收器要复杂很多，是各种垃圾回收算法的复合和适配</p></blockquote><h3 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h3><p>在讲垃圾回收器之前，我们需要明确以下垃圾回收的一些概念，这样在后面讲垃圾回收器的时候，才能弄明白</p><ul><li><p>System.gc()方法</p><p>这个方法只是触发一次GC，但是并不会立马调用垃圾回收器去执行GC，相当于是一个异步的</p></li><li><p>内存泄露</p><p>当一些对象不再使用，但是GC无法回收，就会导致内存泄漏，在开发中有很多场景：</p><ul><li><p>单例模式，由于单例对象是static声明的类静态变量是一个GC root，如果它里面引用了某个对象，但是这个对象后面不用了，那么就会无法GC掉</p></li><li><p>数据库、socket这些连接没有手动close掉，就会泄漏</p></li><li><p>ThreadLocal中key是弱引用，但是value为强引用，一旦ThreadLocal外部的强引用没了，ThreadLocalMap中的key就会没了，无法访问到value，但是value的强引用还在，无法GC</p><p>具体看：<a href="https://zenithwon.github.io/2024/06/03/2024-06-03-JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/">JUC并发工具详解</a></p></li></ul></li><li><p>安全点和安全区域</p><p>并非所有时候，都可以STW进行GC，只有到特定位置才能停下来GC，这些位置就是全局安全点。</p><p>由于GC时间往往比较长，因此<strong>为了让用户尽可能无感知</strong>，一般安全点选在某条执行时间较长的指令地方，比如方法调用、分支或循环跳转</p><blockquote><p>如何在GC触发的时候让线程都到SafePoint停下来呢？</p><ul><li>线程被动：先让所有线程都停下来，然后告诉他们要在最近的安全点停下来</li><li>线程主动：触发GC后设置一个标志位，线程每次到一个安全点，就根据标志位判断是否需要停下来</li></ul></blockquote><p>但是有时候，并不是什么时候都可以找到最近的安全点停下来，比如sleep的时候，这时候就需要安全区域了</p><p>安全区域指的是某一段代码块不会发生对象的引用变更，那么这段代码任何地方都可以GC</p></li></ul><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p>有些对象，按道理应该是：内存够的时候就不会回收，但是内存不够的时候应该被处理掉，典型的<strong>比如缓存</strong></p><p>其实这也就是为什么ThreadLocal要用弱引用的原因</p><p>为了解决这个问题，JDK1.2以后，Java对引用的概念进行了扩充，分为了强引用、软引用、弱引用、虚引用</p><ul><li><p><strong>强引用</strong>：就是我们new出来一个对象后，赋值的那个引用，只要一个对象有强引用关联，即使OOM也不会回收</p></li><li><p><strong>软引用</strong>：如果一个对象只有软引用关联，那么当程序OOM的时候，就会GC掉这个对象，平时是不会GC掉的</p><p>但是要注意的是，软引用在GC之前，是<strong>已经进行了不可达对象的GC</strong>了，如果还是OOM才会回收软引用</p></li><li><p><strong>弱引用</strong>：如果一个对象只有弱引用关联，只要发生GC，就会被回收</p></li><li><p><strong>虚引用</strong>（<code>PhantomReference</code>）：虚引用不会干扰对象的生命周期，也无法通过虚引用去使用对象</p><p>它在构造的时候必须要传入<strong>引用队列+引用对象</strong></p><p>当对象被回收的时候，会将该虚引用放到引用队列里面，该队列可以被看做是一个DelayQueue，我们可以开启一个线程取出来做操作</p></li></ul><p>此外，JVM层面还有一个特殊引用：<strong>终结器引用</strong>（<code>FinalReference</code>），这就前面说过是调用finalize方法前放到F-Queue里面的东西</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="GC的指标"><a href="#GC的指标" class="headerlink" title="GC的指标"></a>GC的指标</h3><p>在GC中有两个比较重要，但是有相对矛盾的指标：</p><ul><li><p>吞吐量：一定时间内，用户线程活跃时间的占比，当然这个占比肯定越高越好</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424728.png" alt="img" style="zoom:67%;" /></li><li><p>延迟时间：每次停顿下来的时间的长度，这个当然越低越好</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424849.png" alt="img" style="zoom:67%;" /></li></ul><p>但是这两个指标是互相矛盾的，如果延迟时间短，那么GC次数一定会上升，相同的GC工作量会多更多的线程切换，因此吞吐量会下降</p><p>但是吞吐量提高的话，肯定要减少GC次数，因此每次GC工作量会更长，导致延迟下降</p><p>目前的目标是：<strong>保证最大吞吐量，同时降低延迟时间</strong></p><h3 id="垃圾回收器的分类"><a href="#垃圾回收器的分类" class="headerlink" title="垃圾回收器的分类"></a>垃圾回收器的分类</h3><ul><li><p>按<strong>线程数</strong>分：并行垃圾回收器和串行垃圾回收器，这里的<strong>并行指的是GC的时候是不是多线程GC</strong></p><p>相同的GC工作量，如果开启多线程GC，自然STW时间要短一点（前提是多核CPU）</p></li><li><p>按<strong>工作模式</strong>分：并发垃圾回收器和独占垃圾回收器，允许GC和用户线程并发执行，而不是STW的GC</p></li><li><p>按<strong>碎片处理方式</strong>分：压缩垃圾回收器和非压缩垃圾回收器，压缩指的是清理完垃圾后，会对内存空间整理压缩，比如使用Mark-Compact算法回收垃圾</p></li><li><p>按<strong>工作内存空间</strong>分：年轻代垃圾回收器和老年代垃圾回收器，顾名思义</p></li></ul><h3 id="七个经典的垃圾回收器"><a href="#七个经典的垃圾回收器" class="headerlink" title="七个经典的垃圾回收器"></a>七个经典的垃圾回收器</h3><table><thead><tr><th>串行回收器</th><th>并行回收器</th><th>并发回收器</th></tr></thead><tbody><tr><td>Serial、Serial Old</td><td>ParNew、Parallel Scavenge、Parallel Old</td><td>CMS、G1</td></tr></tbody></table><p>根据分代分类，这七个又可以分为：</p><table><thead><tr><th>新生代</th><th>老年代</th><th>都可以</th></tr></thead><tbody><tr><td>Serial、Parallel Scavenge、ParNew</td><td>Serial Old、Parallel Old、CMS</td><td>G1</td></tr></tbody></table><p>但是他们之间并不是可以随意一一组合，而是有这样一个组合关系：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424779.png" alt="img" style="zoom:67%;" /><p>其中CMS在JDK14已经被删掉了，具体的组合要从使用场景来分析，不能一棒子打死</p><h3 id="Serial回收器"><a href="#Serial回收器" class="headerlink" title="Serial回收器"></a>Serial回收器</h3><p>Serial回收器是针对于新生代的回收器，是JDK中最早的回收器，是Client模式下的默认选择</p><p>由于用于新生代并且是Serial，因此它采用的是<strong>复制算法、STW串行回收</strong></p><p>Serial回收器还提供了一个老年代版本：Serial Old，它采用的是<strong>标记-压缩+STW串行回收</strong></p><blockquote><p>Serial Old垃圾回收器比较特殊，它不仅仅是Client模式下的默认回收老年代回收器</p><p>同时也是使用CMS时候的兜底回收器（CMS是并发的，发生OOM时需要Seral Old来STW式的GC）</p></blockquote><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424956.png" alt="img"></p><h3 id="ParNew回收器"><a href="#ParNew回收器" class="headerlink" title="ParNew回收器"></a>ParNew回收器</h3><p>ParNew回收器相当于时Serial回收器的并发版本，使用的是<strong>复制算法+并行STW</strong></p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424007.png" alt="img"></p><p>上图是一个ParNew和Serial Old配合使用的流程图，因为新生代GC次数多并行更高效，老年代GC次数上，串行节省性能</p><h3 id="Parallel-Scavenge回收器"><a href="#Parallel-Scavenge回收器" class="headerlink" title="Parallel Scavenge回收器"></a>Parallel Scavenge回收器</h3><p>并行回收器器中，除了ParNew以外，还有一个Parallel Scavenge回收器，也是使用<strong>复制+并行STW</strong></p><p>那为什么有ParNew了，还要搞一个Parallel Scavenge呢？</p><p>因为Parallel Scavenge回收器是一个<strong>吞吐量优先的回收器</strong>，同时也不需要用户自己去寻找STW的点，<strong>具有自适应调节策略</strong>来保证高吞吐量</p><blockquote><p>你可以配置GC并行的线程数、最大STW时间、吞吐量大小等等，Parallel会<strong>尽可能</strong>满足这些要求</p><p>但不是说配置了一定会满足，你要是配置STW时间为1ms+吞吐量99.9%，那也不可能满足啊</p></blockquote><p>同样，为了保证老年代回收的吞吐量，也推出了Parallel的老年代版本：Parallel Old，采用<strong>标记-压缩+并行STW</strong></p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424567.png" alt="img"></p><h3 id="CMS回收器"><a href="#CMS回收器" class="headerlink" title="CMS回收器"></a>CMS回收器</h3><p>CMS又叫Concurrent Mark Sweep，是一种<strong>并发的标记-清理垃圾回收器</strong></p><p>CMS和Parallel回收器不同，它<strong>更注重低延迟</strong>，比如互联网的服务端十分注重响应时间就用CMS</p><p>虽然CMS注重低延迟但是还是会STW，同时使用的是标记-清理算法</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407201424503.png" alt="img"></p><p>如上图所示，CMS的工作流程分为四步：</p><ul><li><strong>初始标记</strong>：这个阶段会标记出堆中直接和GCroots相连的对象，由于这个数量较少，是<strong>STW式</strong>的</li><li><strong>并发标记</strong>：这个阶段是和<strong>用户线程并发</strong>的，CMS会进一步标记堆中和GC roots间接相连的对象</li><li><strong>重新标记</strong>：由于在并发标记期间用户线程也在工作，因此很有可能会出现引用变更，为防止错误的清理某些对象，会在这里<strong>STW式</strong>的处理变更的引用</li><li><strong>并发清除</strong>：这里会清理掉被标记为垃圾的对象，由于是mark-sweep，因此可以和<strong>用户线程并发</strong></li></ul><p>虽然CMS延迟很低，但是也还是有缺点的：</p><ul><li><p>首先CMS是并发的回收器，因此你不能等发生OOM了再GC，那并发咋并发？用户线程都没法new对象</p><p>因此，一般是堆空间到达某个阈值的时候就GC，但是如果真的并发GC的时候发生OOM了，就<strong>需要Serial Old来兜底搞一次STW的回收</strong></p><blockquote><p>这也是为什么CMS用的Mark-Sweep还是可以工作，一旦碎片无法处理的时候肯定会OOM，那么就由Serial Old通过复制算法来重新规整内存空间</p></blockquote></li><li><p>CMS由于是和用户线程并发的，并且使用的时候是多线程进行回收，因此它会和服务争抢资源导致性能下降</p></li><li><p>CMS无法处理浮动垃圾，比如在并发清理和并发标记的时候，由于用户线程的操作导致又产生新的垃圾了，那只能等到下次再回收了（要注意的是，由于使用的是<strong>三色标记法</strong>，因此不会将正常的对象标记为垃圾，但是会有概率将垃圾标记为正常对象）</p></li></ul><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>在CMS，包括后面的G1、ZGC这些有并发标记的地方，都会使用到这个方法，来保证并发标记的正确性，并且在重新标记的时候保证不会将不是垃圾的对象标记为垃圾</p><p>三色标记会将堆中的对象分成三个颜色，也就是堆中的对象会有三个集合：</p><ul><li><p><strong>黑色</strong>：黑色对象表示当前对象被访问到了（即和GC roots相连，不是垃圾），并且其所有内部引用都已经被扫描过。</p><p>我们<strong>先不考虑并发标记的修改</strong>，因为修改后会有颜色的转变：</p><p>由于黑色对象的所有内部的引用都已经被扫描过，因此<strong>不可能会有白色对象直接和黑色对象相连</strong>，黑色对象一定是会通过灰色对象间接的和白色对象相连</p></li><li><p><strong>灰色</strong>：这是对象的中间状态，表示当前对象是和GC root相连，但是它内部的引用还有没有扫描的</p><p>这个状态在STW式的重新标记后就没有了，即<strong>重新标记后只有白色对象和黑色对象</strong>。由于没有任何引用指向白色，这个对象虽然存在于堆中，但是程序不可能访问的到</p><p>因此重新标记后白色一定为垃圾，不可能在并发清理的时候会有白色转变为灰色或者黑色的情况</p></li><li><p><strong>白色</strong>：这表示GC线程还没有访问到这个对象，GC开始前所有对象都是白色，如果重新标记结束后，仍然还是白色，就说明该对象是垃圾需要被回收</p></li></ul><p>在GC过程中会通过GC roots集合通过dfs或者bfs遍历所有引用，为了防止循环依赖，如果发现dfs或者bfs到非白色对象就不会再次遍历了</p><p>三色标记会有几个问题，比如<strong>如何保证不错标</strong>，<strong>并发标记的时候新建对象怎么办</strong>：</p><ul><li><p><strong>并发标记新建对象</strong></p><p>并发标记、并发清理的时候，如果新建对象那么就直接将其置为黑色，即使GC过程中变成了垃圾也不会在本次GC处理，而是留到下次GC</p></li><li><p><strong>保证不把正常对象标记为垃圾</strong><br>首先要强调的是，<strong>这个错误只会发生在并发标记的阶段</strong>，并发清理的阶段只有黑色和白色集合，白色不会发生引用变更，因为用户线程无法通过黑色对象访问到白色对象</p><p>这个其实有两种方案，一个是增量更新（CMS）、一个是原始快照（G1）</p><ul><li><p><strong>增量更新</strong>：当一个黑色对象要和一个白色对象建立引用关系的时候，会将黑色对象改成灰色对象，如果并发标记没有再访问到这个标记为灰色对象，等到重新标记的时候STW式的扫描这些灰色对象，保证重新标记后不会出现灰色对象</p><p>这样做，可以保证疑似垃圾的对象和正常对象建立引用后，可以被察觉到。但是这个无法检测到引用删除的变化，因此一旦被标记为黑色或者灰色的节点删除引用后变成垃圾了，那就会变成浮动垃圾</p></li><li><p><strong>原始快照</strong>：由于只有删除引用才会导致对象变成垃圾，因此在并发标记过程中，直接将这些删除的引用记录下来，然后重新标记的时候，通过这些删除的引用将一些垃圾变成非垃圾</p><p>这样做，可以保证绝对不会错标，保存的删除引用相当于一个快照，但是这样<strong>会导致很多浮动垃圾，但是效率会比增量更新这种再扫描一次要高</strong></p></li></ul></li></ul><h3 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h3><p>当仅仅只是Minor GC的时候，如果通过GC roots遍历要先从老年代才能访问到年轻代对象，那岂不是还是要把整个堆查一遍，这和Minor GC的初衷不符合</p><p>因此JVM搞了一个记忆集的东西，而<strong>记忆集的一个实现就是卡表</strong></p><p>卡表是一个数组，将整个堆分成了很多卡页（512B），然后卡表中的每一个元素代表一个卡页的状态</p><p>如果一个卡页中有跨代的指针，那对应的卡表元素标记为1，否则为0</p><p>在遍历的时候，只会遍历那些被标记为1的卡页里的对象，这样可以防止全局遍历</p><h3 id="Garbage-First-G1垃圾回收器"><a href="#Garbage-First-G1垃圾回收器" class="headerlink" title="Garbage First(G1垃圾回收器)"></a>Garbage First(G1垃圾回收器)</h3>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发容器详解</title>
    <link href="/2024/06/04/%E5%85%AB%E8%82%A1/2024-06-04-JUC%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/04/%E5%85%AB%E8%82%A1/2024-06-04-JUC%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发容器详解"><a href="#JUC并发容器详解" class="headerlink" title="JUC并发容器详解"></a>JUC并发容器详解</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="Java并发的Map"><a href="#Java并发的Map" class="headerlink" title="Java并发的Map"></a>Java并发的Map</h3><p>Java可以提供并发的map的常用的有三种，分别是<code>HashTable</code>、<code>SynchronizedMap</code>（Collections.synchronizedMap方法提供）以及<code>ConcurrentHashMap</code>，那么这三者有什么区别呢？</p><p>首先，HashTable和SynchronizedMap都是直接通过synchronized关键字实现的，但是二者还是有区别的</p><ul><li><p>HashTable是直接在方法上加synchronized，但是SynchronizedMap是对方法的代码块加</p></li><li><p>而且SynchronizedMap可以自己提供synchronized的锁对象，不过默认情况下还是this</p></li><li><p>SynchronizedMap可以在不需要加锁的时候，直接使用原本的HashMap</p></li></ul><p>ConcurrentHashMap在JDK1.7和JDK1.8实现的方式是不同的，前者是分段锁+ReetrantLock，后者是synchronized+cas操作每个entry</p><blockquote><p>这样做的好处是，不用在对map操作的时候锁住整张表，而是将锁更加细化了</p><p><strong>full -&gt; segment -&gt; entry</strong></p></blockquote><h3 id="ConcurrentHashMap-JDK1-7"><a href="#ConcurrentHashMap-JDK1-7" class="headerlink" title="ConcurrentHashMap - JDK1.7"></a>ConcurrentHashMap - JDK1.7</h3><p>在1.7的ConcurrentHashMap中，使用的是分段锁的方法，对于一个key的操作，都会先根据其hashCode计算应该放到哪个Segement，然后再执行相应的get、put、remove等方法，而且扩容、上锁啥的都是以Segment为单位的，基本不会互相干扰</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406042321554.png" alt="img" style="zoom:40%;" /><p>Segment的个数是初始化的时候设置的，这个无法扩容且默认为16，并且这个Segment是继承了ReentrantLock类，可以直接使用其tryLock、lock等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span><br></code></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol><li><p>首先，会让Segment的数量往上取到$2^n$，然后根据initialCapacity平均分配到每个Segment上，如果没有给initialCapacity的话，就会给Segment容量默认值：2</p><p>要注意的是，这个分配到Segment的大小是向上取整后，再往上取到$2^n$，并且这个只是Segment[0]的初始容量，其他的Segment只会在后续使用到的时候才进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                         <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//这两个值用来计算key对应的Segemnt</span><br>    <span class="hljs-comment">//由于是取高n位，因此先右移再和全1的mask按位与</span><br>    <span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br><br>    <span class="hljs-comment">// initialCapacity 是设置整个 map 初始的大小，</span><br>    <span class="hljs-comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY; <br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 创建 Segment 数组，</span><br>    <span class="hljs-comment">// 并创建数组的第一个元素 segment[0]</span><br>    Segment&lt;K,V&gt; s0 =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>    <span class="hljs-comment">// 往数组写入 segment[0]</span><br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>那么当执行put操作的时候，会先锁定对应的Segemnt，就是取key的hashCode的高n位为index</p><p>如果发现对应的Segment为空，那就会先调用<code>ensureSegment</code>进行Segment的初始化</p><p>这个初始化使用当前Segment[0]的参数来初始化，因为Segment[0]可能已经被扩容过了，初始化的时候，会先初始化一个Segemnt，然后通过CAS赋值进去</p><blockquote><p>这个CAS只会在当前Segment还是空的时候一直循环，一旦发现不是空就说明已经并发的有线程初始化过了，那就直接返回</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title function_">ensureSegment</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br>        <span class="hljs-comment">// 由于Segemnt[0]可能已经被扩容过了，因此需要取当前Segment[0]的参数初始化</span><br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> proto.table.length;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> proto.loadFactor;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(cap * lf);<br><br>        <span class="hljs-comment">// 初始化 segment[k] 内部的数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>            == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 再次检查一遍该槽是否被其他线程初始化了。</span><br><br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);<br>            <span class="hljs-comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                   == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="hljs-literal">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h5><ol><li><p>put操作首先会根据初始化算出的segmentShift和segmentMask计算出应该使用哪个Segment，然后如果发现对应的Segment为空的时候，会执行<code>ensureSegment</code>初始化Segment</p></li><li><p>找到对应的Segment后，就会执行该Segment的put操作，这才是真正的put</p><p>要注意的是，JDK1.7的拉链法采取的是<strong>头插法，且没有红黑树</strong></p><p>因此，，JDK会从头开始遍历链表，会有两种情况：</p><ul><li><p>一种是遍历的时候发现一样的key，就看看onlyIfAbsent是否允许覆盖，允许覆盖就覆盖完返回，不允许覆盖就直接返回；要是没发现一样的</p></li><li><p>第二种就是遍历完（可能本来first节点就是null），那就是该key不存在，就直接创建一个node，将next指向以前的first，再将node放到表头</p><blockquote><p>但是，这个node可能会在获取锁的时候调用scanAndLockForPut创建出来了，那就不用再初始化了，直接修改next指针就好，再放到表头</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br>    <span class="hljs-comment">// tryLock失败了就会走scanAndLockForPut逻辑获取锁，可能会顺带创建出头节点！！</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> :<br>        scanAndLockForPut(key, hash, value);<br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这个是 segment 内部的数组</span><br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-comment">// 再利用 hash 值，求应该放置的数组下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        <span class="hljs-comment">// first 是数组该位置处的链表的表头</span><br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br><br>        <span class="hljs-comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        <span class="hljs-comment">// 覆盖旧值</span><br>                        e.value = value;<br>                        ++modCount;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 继续顺着链表走</span><br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br>                <span class="hljs-comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node); <span class="hljs-comment">// 扩容后面也会具体分析</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br>                    <span class="hljs-comment">// 其实就是将新的节点设置成原链表的表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="put操作的其他两个函数"><a href="#put操作的其他两个函数" class="headerlink" title="put操作的其他两个函数"></a>put操作的其他两个函数</h5><p>put操作会有两个比较特殊的函数，一个是tryLock失败后会进行自旋的<code>scanAndLockForPut</code>，一个是put完成后检查发现超过threshold进行的<code>rehash</code></p><ol><li><p><strong>scanAndLockForPut</strong></p><p>这个函数会做两件事儿：</p><ul><li>tryLock，然后发现超过指定自旋次数，就会lock阻塞</li><li>在第一次自旋的时候，如果发现first为空，即该entry位置没有元素，那就顺便初始化一个node返回，这也就是为什么在put的时候，node有可能被初始化好了的原因</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title function_">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value)</span> &#123;<br>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-built_in">this</span>, hash);<br>    HashEntry&lt;K,V&gt; e = first;<br>    HashEntry&lt;K,V&gt; node = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br><br>    <span class="hljs-comment">// 循环获取锁</span><br>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>        HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                    <span class="hljs-comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span><br>                    <span class="hljs-comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                retries = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>                retries = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 顺着链表往下走</span><br>                e = e.next;<br>        &#125;<br>        <span class="hljs-comment">// 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁</span><br>        <span class="hljs-comment">//    lock() 是阻塞方法，直到获取锁后返回</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>            lock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>                 <span class="hljs-comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br>                 <span class="hljs-comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br>                 (f = entryForHash(<span class="hljs-built_in">this</span>, hash)) != first) &#123;<br>            e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>            retries = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>rehash</strong></p><p>这个没什么好说的，和HashMap的rehash差不多</p><p>由于只会在put和remove的时候发生rehash，而这两个操作都是已经获取了Segment的锁了，因此不需要考虑并发问题，所以直接rehash就好了</p></li></ol></li></ol><h5 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h5><p>get操作就比较简单了，就是先获取对应的Segment，然后如果为空直接返回，不为空就找到对应的entry列表的index，然后链表遍历就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// 1. hash 值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// 2. 根据 hash 找到对应的 segment</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span><br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ConcurrentHashMap-JDK1-8"><a href="#ConcurrentHashMap-JDK1-8" class="headerlink" title="ConcurrentHashMap - JDK1.8"></a>ConcurrentHashMap - JDK1.8</h3><p>在JDK1.7中使用的分段锁的思想，但是对于同一个Segment的entryList还是只允许一个线程操作，因此在JDK1.8中，摈弃了分段锁的思想，而是大量的使用CAS操作以及少量的synchronized</p><p>并且在JDK1.8中和原本的hashMap保持一致，使用<strong>链表+红黑树+尾插法</strong></p><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406042321355.png" alt="img" style="zoom:40%;" /><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化的时候，会计算sizeCtl，就是初始容量的1.5倍+1，然后在向上取到$2^n$</p><p>这个sizeCtl比较特殊，正常情况下就是这个hashMap的容量阈值，超过就要扩容</p><p>但是在扩容的时候，就会将其置为-1，表示开始扩容，每来一个线程辅助扩容，就会-1。也就是说，$-N$就是表示有N个线程同时扩容，具体扩容后面会说</p><h5 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h5><p>这个源码就不放进去了，<strong>put操作是个大的循环</strong>，每次put失败，则表示有并发就会重新获取map的table数组，然后再次进行put，那么每次的put操作步骤如下：</p><ul><li>首先，看看table是不是空的，如果是空的则会初始化table，<code>initTable</code>方法</li><li>接着，计算hashCode对应的table的index，然后取出第一个节点进行判断：<ul><li>若为null，则直接CAS放进去</li><li>不为null，再看看hash值是不是-1，-1的hash值表示这一个ForwardingNode节点正在迁移table[i]，因此就会去辅助迁移，迁移完了，进入下一次put循环</li><li>不为null，也是正常的node，那就会锁住这个节点，然后进行修改操作。如果是链表则用尾插法，如果是红黑树就用红黑树的插入方法</li></ul></li><li>插入完如果发现满足转为红黑树条件，则转为红黑树</li><li>最后，容量加一，如果超过阈值则扩容</li></ul><h5 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h5><p>在执行put操作的时候，若发现table为空会先执行initTable方法来初始化，其实就是初始化一个数组</p><p>但是，为了防止多个线程同时初始化，需要通过CAS将sizeCtl改为-1，谁抢到谁初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 已经有线程开始初始化了</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 初始化数组，长度为 16 或初始化时提供的长度</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    <span class="hljs-comment">// 将这个数组赋值给 table，table 是 volatile 的</span><br>                    table = tab = nt;<br>                    <span class="hljs-comment">// 将sizeCtl改为容量的1.5倍</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h5><p>在JDK1.8的ConcurrentHashMap中，维持了一个nextTable，就类似Redis的ht[1]一样，平时一般都是空的，一到扩容的时候就会申请空间，然后将旧table的数据迁移过来，再将旧table的引用指向nextTable</p><p>但是和Redis不同的是，这个数据迁移并不是一个线程一批一批的迁移</p><p>在ConcurrentHashMap中，也是将整个迁移任务分为了多个，从n到0开始迁移，用一个transferIndex记录下次迁移的起始index，然后由发起迁移的线程进行一批一批的迁移，迁移完就会将对应table[index]处的头节点设置为ForwardNode类型的节点</p><blockquote><p>ForwardNode节点的hash值是-1，当后续如果在迁移过程中其他线程访问到这个table[index]，就会发现该节点是ForwardNode节点，会特殊处理</p><p>具体来说，put、remove这种修改操作会先进行helpTransfer；get操作则会去nextTable中找对应key</p></blockquote><p>在迁移的时候，会先看查看迁移地方的头节点状态：</p><ul><li><p>头节点为空，直接cas一个ForwardNode；</p></li><li><p>已经是ForwardNode，则已经迁移过了，就不管了</p></li><li><p>如果都不是，则synchronized这个地方，进行rehash并放到nextTable中，rehash完后会将旧table的头节点置为ForwardNode地方的头节点是ForwardNode</p></li></ul><p>当其他线程对这个地方put等操作的时候，会发现是ForwardNode，那么<strong>反正都是要挂起等待迁移完成，那为啥不帮着一起迁移呢？</strong>。因此，这些线程也会根据transferIndex领取一个迁移任务，进行迁移</p><p>rehash同样和HashMap一样，红黑树分完后<strong>如果节点个数小于6，也会退化为链表</strong></p><h5 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h5><p>在put操作后，会通过addCount将map的size+1，然后判断是否超过sizeCtl，若超过则也进行扩容</p><p>但是这里的加一，并不是直接暴力CAS让baseCount+1，因为要考虑多线程问题，所以为了提供效率，这里的addCount借鉴了LongAdder思想，一旦CAS失败就会存到一个CountCell数组里面</p><p>这里还是有很多特殊情况的，我们一个一个分析</p><ol><li>首先，最简单粗暴的就是，先CAS 让baseCount+1一下，如果成功就直接返回了</li><li>失败，那就要查看CountCell了，但是这个CountCell初始是空的，因此发现是空的就会执行<code>fullAddCount</code>函数；如果不为空，那就会找到相应的CountCell位置，若这个地方的CountCell为空还是会<code>fullAddCount</code>一下，不为空则CAS修改CountCell的值，失败还是会<code>fullAddCount</code></li></ol><p>总的来说，就是先CAS baseCount，失败了就会去CAS countCell，如果<strong>CountCell数组没有初始化或者CountCell[i]没有初始化</strong>，就会直接进入<code>fullCount</code>，同样<strong>CAS countCell失败也会</strong></p><blockquote><p>那么如果计算当前线程应该操作哪个CountCell呢？</p><p>会通过ThreadLocalRandom这个类来为当前线程生成一个随机数，然后拿这个随机数去取模</p></blockquote><h5 id="fullAddCount"><a href="#fullAddCount" class="headerlink" title="fullAddCount"></a>fullAddCount</h5><p>如果addCount失败，那就会进入fullAddCount，这里总的可以分为两种情况：</p><blockquote><p>在此之前，我们要知道：如果线程需要操作CountCell，那就需要先CAS cellBusy将其置为1，然后才能去操作，否则就会自旋，重新case下面三种情况</p></blockquote><ol><li><p>CountCell数组不为空，这个情况比较复杂</p><ul><li>先看看当前位置是不是空，为空则先抢cellBusy，抢到就创建一个CountCell放到指定位置</li><li>不是空的话，就先CAS countCell，如果失败，就说明也有线程跟当前线程操作的是一个CountCell单元，那就就会有两种解决措施：<ul><li>如果CountCell个数没有达到根据CPU核数计算出来的阈值，那就<strong>翻倍扩容</strong></li><li>达到了，那就说明无法扩容，只能重置随机数，自旋</li></ul></li></ul></li><li><p>CountCell数组为空</p><p>那就CAS cellBusy，抢到就将CountCell初始化为CountCell[2]</p><p>如果CAS失败，那就说明有其他线程在操作CountCell，那就直接CASbaseCount，失败就自旋</p></li></ol><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue是一个线程安全的队列，它和ConcurrentHashMap不一样，不使用synchronized这种会阻塞线程的锁，而是使用CAS来实现</p><p>在讲这个之前，<strong>我们要知道一点</strong>：</p><p>ConcurrentLinkedQueue的节点被封装为一个内部类Node，既然是queue那肯定是有一个head节点和一个tail节点，由于ConcurrentLinkedQueue底层是基于CAS的非阻塞形式，因此它<strong>对于head和tail的更新是采用一种延迟加载的策略</strong></p><p>这种延迟加载的策略会导致head或者tail并不是真正的head和tail，极有可能会出现下面这种情况：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406052317031.png" alt="img" style="zoom:67%;" /><p>这一点会贯穿整个底层实现，到底是如何这种延迟加载的，后面会说到。</p><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>在ConcurrentLinkedQueue中，定义了一个内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">volatile</span> E item;<br>    <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，还定义了两个链表的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure><blockquote><p>再次提醒一下，这个head和tail不是真实的head和tail，而是采用一种延迟加载的机制</p></blockquote><h3 id="poll操作"><a href="#poll操作" class="headerlink" title="poll操作"></a>poll操作</h3><p>为了方便offer更好的理解，我们先从poll操作讲起，我们不一定按照代码逻辑判断的顺序来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    restartFromHead:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> p.item;<br><br>            <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span> &amp;&amp; p.casItem(item, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (p != h)<br>                    updateHead(h, ((q = p.next) != <span class="hljs-literal">null</span>) ? q : p);<br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                updateHead(h, p);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                <span class="hljs-keyword">continue</span> restartFromHead;<br>            <span class="hljs-keyword">else</span><br>                p = q;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>首先，会先拿出当前维护的head节点，并将其赋值给p，然后拿出p里面的item</p></li><li><p>如果拿出来的item不是null并且CAS成功，那就返回item</p><p>但是返回之前，看看需不需要加载一下head：</p><ul><li>如果发现在p和head不相等了，那就说明p往后找了几个节点（有线程已经poll了几个但是没有更新head），那就要更新head为p后面的那个，执行updateHead(p.next)，当然，如果后面的节点是null的话，那就没必要更新为p.next了，直接updateHead(p)</li></ul></li><li><p>如果是null的话，那就说明已经到了队尾，那就返回null，但是在返回之前需要更新一下head</p></li><li><p>如果发现p&#x3D;q，那就是有其他队列已经更新了head，发生并发，那就要重新读取head，然后再次循环，为什么更新head会发生p.next&#x3D;q呢？</p><blockquote><p>在updateHead代码中，cas更新完head后，会讲原本的head指针的next指向自己，表示这个节点已经废了，如果有的线程发现了这个节点，那就需要重新读取</p></blockquote></li><li><p>最后，发现当前节点已经被读过了，并且当前head也是正常的，那就进入下一个节点继续判断</p></li></ol><h3 id="offer操作"><a href="#offer操作" class="headerlink" title="offer操作"></a>offer操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br><br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>        Node&lt;E&gt; q = p.next;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// p is last node</span><br>            <span class="hljs-keyword">if</span> (p.casNext(<span class="hljs-literal">null</span>, newNode)) &#123;<br>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span><br>                    casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// Lost CAS race to another thread; re-read next</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>            p = (t != (t = tail)) ? t : head;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// Check for tail updates after two hops.</span><br>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>offer之前先检查是否为空，然后将tail赋值t和p，new一个待插入的节点，开始循环</p></li><li><p>如果p的next是空，那就尝试cas将p的next改为newNode，修改next失败，那就自旋</p><p>修改成功，那就看看有没有往后找了，有的话就要casTail，但是失败了不会自旋（CAS失败表示有线程更新成功了，即使和当前不一样，但是后续的poll还是会延迟加载）</p><blockquote><p>但是这里要注意的是，只要cas改掉了p的next，不管修改cas修改tail是否成功，都会返回true，因为即使没有改成功，后面也会延迟加载tail</p></blockquote></li><li><p>如果p和q相等，那就是head已经到tail后面去了，tail目前指向的是废弃节点（因为更新head 的时候，会把以前的head的next指向自己），那么就需要将从head节点开始一个一个往后找了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406052317376.png" alt="Node2从队列中出队后的状态" style="zoom:67%;" /><p>但是，在直接将p改为head之前，需要看看t和tail是否相等，因为很有可能就在<strong>这一刹那有一个线程已经将tail更新为正确的tail了</strong>，因此修改p的表达式为：<code>p=(t != (t = tail)) ? t : head</code></p></li><li><p>那走到最后，还是没有问题，那就说明已经有别的线程在该线程之前offer了一个节点，那就往后找，往后找同样需要判断在这一刹那是否已经有线程更新了tail，更新了那就直接将p改成新的tail，没更新，那就改为p.next（即q）：<code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code></p></li></ol><h3 id="延迟加载策略"><a href="#延迟加载策略" class="headerlink" title="延迟加载策略"></a>延迟加载策略</h3><p><strong>延迟加载是ConcurrentLinkedQueue非阻塞更新队列的核心</strong>，既然整篇都是延迟加载，那么就来讲一讲head和tail是什么时候延迟加载的吧</p><ul><li><p>head延迟加载：当发现当前head指向的节点为null，在返回item数据之前需要<strong>updateHead</strong>一下，</p><blockquote><p>不同于更改tail的一次CAS，更改head在CAS过后，为了标记出队的节点不可用，需要将原head的next指向自己</p><p>这样，当其他的offer、poll操作的时候，就会发现这个问题</p></blockquote></li><li><p>tail的延迟加载：若tail指向的不是最后一个节点（有线程已经插入了，或者前面很多次poll操作导致tail指向了废弃节点），那就会尝试CAS一下tail，但是不会管成功还是失败</p></li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列和前面刚刚提到的ConcurrentLinkedQueue不同，它是用于“生产者-消费者”模式的问题</p><p>当队列put满了，就会阻塞调用put的生产者线程；当队列take空了，就会阻塞调用take的消费者线程</p><p>而BlockingQueue是一个接口，它定义了如下操作：</p><p>&lt; img src&#x3D;”<a href="https://cdn.tobebetterjavaer.com/stutymore/BlockingQueue-20230818143620.png">https://cdn.tobebetterjavaer.com/stutymore/BlockingQueue-20230818143620.png</a>“ alt&#x3D;”img” style&#x3D;”zoom:70%;” &#x2F;&gt;</p><p>JUC提供了很多BlockingQueue的实现类，比如ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque等等</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue底层是通过ReentrantLock+Condition实现的，有两个Condition和一个lock</p><p>它是一个有界队列，在初始化的时候，必须传入capacity参数，表示队列容量且不能修改</p><p>此外，这一个循环队列，并且使用count的额外遍历来记录队列实际大小同时用于判断队列是否已满，而不是通过start&#x3D;end-1来判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Main lock guarding all access */</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure><p>put和take操作都会先通过ReentrantLock获取锁，然后才能进行队列操作</p><p>在进行put的时候：</p><ul><li>如果发现队列满，则会通过notEmpty阻塞，等到take出队成功就会调用notEmpty唤醒</li><li>如果队列没有满，则会调用enqueue函数，加入队列并调用notFull的signal，唤醒一个阻塞的take进程</li></ul><p>take方法则相反：</p><ul><li>如果发现队列空，则会通过notFull阻塞，等到put入队成功就会调用notFull唤醒</li><li>如果队列没有满，则会调用dequeue函数，加入队列并调用notEmpty的signal，唤醒一个阻塞的put进程</li></ul><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockQueue底层使用链表的数据结构，可以支持无界队列（不传capacity就是无界的），并且底层用的是两把ReentrantLock+两个Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Lock held by take, poll, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">/** Wait queue for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<br><br><span class="hljs-comment">/** Lock held by put, offer, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">/** Wait queue for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<br></code></pre></td></tr></table></figure><p>和ArrayBlockingQueue不一样的是，LinkedBlockingQueue将put和take两个操作用两把锁，这样可以提高并发量，并且为了防止两个线程的并发问题，count使用的是AtomicInteger来保证安全性</p><p>其他的出队和入队的基本流程和ArrayBlockingQueue差不多</p><blockquote><p>ArrayBlockingQueue和LinkedBlockingQueue：</p><ul><li>二者都是基于ReentrantLock+Condition实现的</li><li>前者底层用的是数组并且有界，后者用的是链表可以支持无界</li><li>后者的锁粒度更细（put、take分离），并发量更大</li></ul></blockquote><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>这是一个无界的队列，底层是通过<code>PriorityQueue</code>+<code>ReentrantLock</code>+<code>Condition</code>实现，里面的元素需要实现Delayed接口因为需要获取延迟时间</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过优先队列根据<strong>任务到期时间</strong>（入队的currentTime+delayime）升序排序，这样可以保证每次出队的元素是最紧急需要执行的</p><p>每次出队的时候需要看看出队的元素是否到了执行时间，由于元素实现了Delayed接口，因此可以调用<code>getDelay</code>方法获取剩余的delayTime，$\le 0$则代表到期</p><p>当然这只是基本思想，由于每次入队一个元素需要唤醒所有线程，但是最终仍然只有一个线程会抢到任务，因此DelayQueue使用leader-follower模式，保证在有leader线程的情况下只会唤醒一个线程</p><h4 id="leader-follower模式"><a href="#leader-follower模式" class="headerlink" title="leader-follower模式"></a>leader-follower模式</h4><p>在这个模式中，如果有leader的情况下，任务会优先给leader消费，leader消费完后就会释放这个位置，唤醒所有的follower去竞争这个leader</p><p>这样的话，在有leader的情况下，不会调用signal的情况，减小CPU开销</p><h4 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h4><blockquote><p>要注意的是take和poll不一样，take在没有元素的情况下会一直等待，而poll会直接返回null</p><p>即使poll传入了等待时间，超过这个时间仍然会返回空</p></blockquote><ul><li><p>先拿出队首的元素，如果为空直接await()，因为队列为空，为了保证公平性不会设置leader</p></li><li><p>不为空，则看看是否到期，如果到期那就直接拿出来返回了</p></li><li><p>还没有到期，那就看看有没有leader，已经有leader在等这个任务那就await自己，等待全局唤醒</p></li><li><p>还没到期，而且还没有leader，那就把自己设为leader，<code>awaitNanos(delayTime)</code>时间就醒来拿这个任务</p></li><li><p><strong>最后有个finally操作</strong>，当leader的awaitNanos到了，如果发现leader还是自己，那就将leader置为空，并去拿任务，拿到了执行完了就会检测leader是否还是空并且队列是否还有元素，如果满足那就全局唤醒所有follower去争抢</p></li></ul><blockquote><p>awaitNanos(waitTime)返回的是剩余的等待时间，如果正常到期唤醒那就返回0，如果被提前signal唤醒，那就返回剩余的等待时间</p></blockquote><h4 id="offer操作-1"><a href="#offer操作-1" class="headerlink" title="offer操作"></a>offer操作</h4><p>是不是前面的take操作把自己设为leader后，就百分百锁定这个待到期的任务了呢？其实并不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        q.offer(e);<br>        <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>            leader = <span class="hljs-literal">null</span>;<br>            available.signal();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在offer的时候，会先入队，然后看看队列的第一个是不是刚入队的，如果是那就说明最紧急的任务发生了变化，那么以前的leader就不能再等到上一个任务到期的时间了，这个时候就会将leader置为空，然后全局唤醒</p><p>因此，很有可能在<code>awaitNanos(delayTime)</code>这个时间内，来一个更早执行的任务，那就会全局唤醒来争抢这个任务，争抢不到的第一个任务会更改leader为自己，其他线程全部await无限期阻塞</p><h4 id="poll操作-1"><a href="#poll操作-1" class="headerlink" title="poll操作"></a>poll操作</h4><p>不带等待时间的poll很简单，就是拿出来看看第一个任务有没有到期，到期直接返回任务；没到期或者队列空，那就直接返回null</p><p>我们重点来看看有等待时间的，同时还是先拿出第一个元素</p><ul><li><p>如果第一个元素为空，那就阻塞waitTime，如果有入队的元素全局唤醒会提前唤醒的</p><blockquote><p>阻塞waitTime的函数是<code>awaitNanos(waitTime)</code>，这个函数返回的是剩余的等待时间，如果正常到期唤醒那就返回0，如果被提前signal唤醒，那就返回剩余的等待时间</p></blockquote></li><li><p>如果不为空，那就取出来，发现已经到期了，那就直接返回</p></li><li><p>没到期，则就看看最紧急任务的剩余时间是不是大于等待时间，并再看看leader是否为空：</p><p><code>nanos &lt; delay || leader != null</code></p><p>只要二者条件满足一个就要awaitNanos(waitTime)，后者的判断是因为leader会先执行，执行完在finally中会全局唤醒</p></li><li><p>没有leader，并且最紧急任务的剩余时间小于等待时间，那就awaitNanos(delayTime)，并将leader设置为自己，并且如果被提前唤醒，需要更新下次等待的总时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">timeLeft</span> <span class="hljs-operator">=</span> available.awaitNanos(delay);<br>nanos -= delay - timeLeft;<br></code></pre></td></tr></table></figure></li></ul><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList使用的和Linux的fork函数一样的写时复制技术，用来处理多线程ArrayList的并发问题</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>内部维护一个Object数组（volatile修饰），然后读的时候就直接从这里面读</p><p>写的时候，会先获取锁（<strong>防止多个线程都复制一份，出现并发问题</strong>），然后将Object数组copy一份往里写，写完再将原本的Object数组引用换成写完后的新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The array, accessed only via getArray/setArray. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>就是从数组中正常的读元素，没啥其他的</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先获取锁，这是ReentrantLock实现的锁，防止多个线程同时复制，由于setArray不是CAS而且同时复制更容易OOM，因此只用一把写锁</li><li>拿到锁后，就复制一份，但是这一份</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发工具详解</title>
    <link href="/2024/06/03/%E5%85%AB%E8%82%A1/2024-06-03-JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/03/%E5%85%AB%E8%82%A1/2024-06-03-JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发工具详解"><a href="#JUC并发工具详解" class="headerlink" title="JUC并发工具详解"></a>JUC并发工具详解</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="进程、线程、管程"><a href="#进程、线程、管程" class="headerlink" title="进程、线程、管程"></a>进程、线程、管程</h3><p>太经典了，这个问题</p><p>进程是系统资源分配的单位，而线程是执行的最小单位</p><p>管程可以理解为monitor，只有一个线程持有管程的时候，才可以进入同步代码块</p><h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><p>用户线程是用户创建的，最典型的就是main方法的主线程</p><p>守护线程是为用户线程提供服务的，在后台运行，最典型的就是垃圾回收线程</p><p>假设当前JVM只有守护线程时，那么JVM就会退出</p><blockquote><p>即使main方法的主线程运行完了，但是里面创建的子线程还在运行，那么JVM仍然不会退出</p></blockquote><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="线程是如何创建的？"><a href="#线程是如何创建的？" class="headerlink" title="线程是如何创建的？"></a>线程是如何创建的？</h3><p>这是一个老生常谈的问题了，都是说三种方法：继承Thread类、实现Runnable接口、实现Callable接口</p><p>但是实际上你看一看线程的构造函数，其实只有一个Runnable接口的构造注入，也就是说Thread除了你去继承他，实际上只有一个传入Runnable方法去构造Thread</p><p>也就是说调用线程的start的方法的时候：</p><ul><li>如果你是继承Thread类，那么你就是重写了run方法，没有Runnable对象</li><li>如果你是实现Runnable接口，并构造注入一个Thread类，那用的原生的Thread的run方法，这里会直接调用Runnable的run方法</li></ul><p>附代码：Thread类的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//这个target就是构造方法注入的Runnable对象</span><br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>        target.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，其实启动线程说到底就两种方法，那Callable是如何启动线程的呢？</p><h3 id="Callable接口如何启动线程的"><a href="#Callable接口如何启动线程的" class="headerlink" title="Callable接口如何启动线程的"></a>Callable接口如何启动线程的</h3><p>Callable接口其实没有办法直接启动线程，而是通过构造注入FutureTask类，然后FutureTask实现了Runnable接口，从而通过FutureTask类构造注入Thread，来启动线程的</p><p>那为什么要搞这么麻烦呢？</p><p>这个Callable接口设计出来，就是为了获取线程执行的结果的，如果一个FutureTask构造注入了Callable方法，那么它实现的Runnable接口的run方法就会做两个事儿：</p><ul><li>执行callable的call方法</li><li>将callable方法的返回值赋给futureTask的返回值，这样你get的时候就能得到“所谓的线程执行的结果”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...省略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>            V result;<br>            <span class="hljs-type">boolean</span> ran;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//执行call，然后set结果</span><br>                result = c.call();<br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                result = <span class="hljs-literal">null</span>;<br>                ran = <span class="hljs-literal">false</span>;<br>                setException(ex);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ran)<br>                set(result);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//...省略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>既然知道了Callable是通过FutureTask来启动线程的，那么为啥要非这么多力气去搞一个FutureTask？</p><p>FutureTask实现了RunnableFuture接口，这个接口继承了Runnable和Future接口</p><p>Runnable接口就是用来创建线程的，Future接口做任务控制的（定义查看任务状态、获取任务结果等方法）</p><p>其次FutureTask还通过构造注入了Callable接口，尽管支持注入Runnable+result的方式，但是底层还是会通过这两个构造一个callable</p><p>那么既然搞了这三个东西，那这个futureTask可想而知，是一个<strong>三功能综合体</strong>：</p><ul><li>开启线程（Runnable接口）</li><li>实现任务管理（Future接口）</li><li>获取线程执行结果（Callable接口）</li></ul><p><strong>但是FutureTask获取执行结果有两个问题</strong>：</p><ul><li>使用get方法直接获取结果，就会导致线程阻塞</li><li>如果使用isDone方法轮询再获取结果就会占用CPU资源</li></ul><p>因此，如何解决这两个问题呢，就用到了CompletableFuture类</p><blockquote><p>在将CompletableFuture之前需要知道函数式接口，Java8函数式编程提供了四个接口：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406110034513.png" alt="image-20240611003414325" style="zoom: 33%;" /></blockquote><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>线程池是一个典型的池化技术实现，可以实现线程资源的复用，避免带来重复创建和销毁带来的性能上的开销</p><p>其实线程池不仅可以实现线程资源的复用，而且还可以实现线程资源的管控，防止不规范的创建使用线程</p><h3 id="线程池的构造参数"><a href="#线程池的构造参数" class="headerlink" title="线程池的构造参数"></a>线程池的构造参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池创建的核心线程数，线程池维护线程的最少数量，即使没有任务需要执行，也会一直存活</td></tr><tr><td>maximumPoolSize</td><td>最大线程池数量，当线程数&gt;&#x3D;corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务</td></tr><tr><td>keepAliveTime</td><td>当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量&#x3D;corePoolSize</td></tr><tr><td>TimeUnit</td><td>时间单位</td></tr><tr><td>workQueue</td><td><strong>阻塞队列</strong>：当核心线程数达到最大时，新任务会放在队列中排队等待执行，就是BlockingQueue</td></tr><tr><td>threadFactory</td><td>线程创建的工厂，一般用默认的 Executors.defaultThreadFactory()</td></tr><tr><td>handler</td><td><strong>拒绝策略</strong>：当pool已经达到max size的时候，如何处理新任务</td></tr></tbody></table><p>这里我们需要提一下拒绝策略：</p><ul><li><p>AbortPolicy：直接抛出异常</p></li><li><p>DiscardPolicy：丢弃新的任务，我们是不知道的！</p></li><li><p>DiscardPolicyOldestPolicy：这个是丢掉最老的任务，即FIFO</p></li><li><p>CallerRunsPolicy：让提交任务的线程去执行，比如异步功能，想要让线程池去做，但是线程池饱和了，线程池说，我不做，你自己做。<strong>其实就是从异步变成同步了</strong></p></li><li><p>自定义：实现接口RejectedExecutionHandler，重写<code>rejectedExecution</code>方法就行了</p></li></ul><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>首先要知道的是，线程池有一个字段ctl，这个字段的高三位代表线程池的状态（RUNNING、SHUTDOWN、STOP、TERMINATED等），低29位代表线程池的线程个数</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406130102857.png" alt="img" style="zoom: 67%;" /><ul><li><p>在调用shutdown的时候，就会将线程池的状态置为SHUTDOWN，然后等待所有已经提交的任务（正在运行以及队列中阻塞的）都运行完，就会变为TIDYING状态，调用terminated才会置为TERMINATED</p></li><li><p>在调用shutdownNow的时候，就会将状态置为STOP，不会再运行队列中的任务了，只会等待正在运行的任务运行完，就会变为TIDYING状态，调用terminated才会置为TERMINATED</p></li></ul><h3 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h3><p>线程池有两种提交方式，一个是execute一个是submit，submit会返回一个Future对象用于获取结果</p><p>其实submit底层就是将Callable或者Runnable包装成了一个FutureTask类，然后再调用execute</p><p>因此我们来讲讲execute方法</p><p>这个方法就是整个任务提交的策略，很简单，直接上图</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406130119152.jpeg" alt="img" style="zoom:50%;" /><h3 id="如何实现线程复用的"><a href="#如何实现线程复用的" class="headerlink" title="如何实现线程复用的"></a>如何实现线程复用的</h3><p>线程提交后，会被封装到Work中调用，Work类继承了Runable接口，run方法就是执行worker的runWork方法</p><ul><li>当runWorker开启后，会先执行提交的第一个任务，即firstTask属性，这个会在创建的时候就初始化好了，因为只有提交了任务才有可能会触发创建线程</li><li>然后就会进入while无限循环，一直调用getTask方法拿任务，然后执行task的run方法</li><li>这个getTask方法很特殊，它对于当前线程是否是核心线程采用的不同的策略，当然他还会根据当前线程池的状态决定从不从阻塞队列里面拿，比如如果是STOP，那就直接返回null，然后销毁线程<ul><li>核心线程就是用take</li><li>非核心线程用的时候有时间的poll，这样当达到keepAlive时间还没有拿到就会返回null，然后就会销毁线程</li></ul></li></ul><h4 id="Excutors的四个典型的线程池"><a href="#Excutors的四个典型的线程池" class="headerlink" title="Excutors的四个典型的线程池"></a>Excutors的四个典型的线程池</h4><ol><li>newFixedThreadPool：固定个数，不会加也不会减，采用的无界队列容易OOM</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>newSingleThreadExecutor：相当于newFixedThreadPool特殊版本，只有一个线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>newCachedThreadPool：来一个任务就开启一个线程，因此使用的是直接队列，并且maximumPoolSize没有上限，同样会OOM</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>newScheduledThreadPool：支持定时，周期型的执行任务，使用的延时队列，同样会OOM</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE,<br>              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，用于为任务提供周期执行以及延迟执行的功能，可以认为是一种本地的任务调度系统，但是他和ThreadPoolExecutor还是有点不一样，它底层实现了很多东西：</p><ul><li>定义了内部类ScheduledFutureTask，用于执行周期任务、延迟任务、当然同样也兼容不需要时间调度的任务</li><li>写了一个BlockingQueue：DelayedWorkQueue，这是为该线程池定制的，这是一个无界队列</li></ul><h3 id="三种任务提交方式"><a href="#三种任务提交方式" class="headerlink" title="三种任务提交方式"></a>三种任务提交方式</h3><p>这个FutureTask的run方法需要支持周期任务、延迟任务、非周期任务三种形式</p><p>同样，ScheduledThreadPoolExecutor也提供了三种提交任务的函数，分别对应这三种任务性质：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安排一个Callable任务在给定的延迟后执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit&#123;</span><br><span class="hljs-params">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="hljs-params">        new ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安排一个Runnable任务在给定的初始延迟后首次执行，随后每个period时间间隔执行一次。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                              <span class="hljs-type">long</span> initialDelay,<br>                                              <span class="hljs-type">long</span> period,<br>                                              TimeUnit unit)&#123;<br>    ScheduledFutureTask&lt;Void&gt; sft =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>                                      <span class="hljs-literal">null</span>,<br>                                      triggerTime(initialDelay, unit),<br>                                      unit.toNanos(period));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安排一个Runnable任务在给定的初始延迟后首次执行，随后每次完成任务后等待指定的延迟再次执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                 <span class="hljs-type">long</span> initialDelay,<br>                                                 <span class="hljs-type">long</span> delay,<br>                                                 TimeUnit unit)&#123;<br>    ScheduledFutureTask&lt;Void&gt; sft =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>                                      <span class="hljs-literal">null</span>,<br>                                      triggerTime(initialDelay, unit),<br>                                      unit.toNanos(-delay));<span class="hljs-comment">//计算任务的执行周期</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：为了将三者区分开，period设置为了正数、0、负数三种，正好代表了这三种类型的任务</strong></p><p>这就是三种任务的提交方式，其实这三个方式最终都是构造了一个ScheduledFutureTask对象，然后调用delayExecute函数，放入队列或者开启新线程运行任务</p><p>delayExecute函数具体做法就是：</p><ul><li>如果发现线程已经处于关闭状态，那就拒绝任务执行拒绝策略</li><li>没什么问题的话，就放入队列中，然后在确保线程数</li></ul><blockquote><p>这和原始的ThreadPoolExecutor不一样，传统的线程池在加入任务的时候会先看看核心线程数是否达到，没到就直接将当前任务设置为新worker的firstTask然后直接运行</p><p>但是定时任务线程池是直接放到队列，然后开启一个线程自己从队列中取，<strong>因此新开的线程不一定就是运行当前这个任务</strong></p></blockquote><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>这个是提交任务，那么提交过后是如何实现周期运行的呢？这个是在ScheduledFutureTask的run方法中实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<span class="hljs-comment">//是否为周期任务</span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<span class="hljs-comment">//当前状态是否可以执行</span><br>        cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        <span class="hljs-comment">//不是周期任务，直接执行</span><br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>        setNextRunTime();<span class="hljs-comment">//设置下一次运行时间</span><br>        reExecutePeriodic(outerTask);<span class="hljs-comment">//重排序一个周期任务</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-comment">// p &gt; 0，说明是固定速率运行的任务</span><br>    <span class="hljs-comment">// 在原来任务开始执行时间的基础上加上p即可</span><br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>      time += p;<br>    <span class="hljs-comment">// p &lt; 0，说明是固定时延运行的任务，</span><br>    <span class="hljs-comment">// 下次执行时间在当前时间(任务执行完成的时间)的基础上加上-p的时间</span><br>    <span class="hljs-keyword">else</span><br>      time = triggerTime(-p);<br>&#125;<br></code></pre></td></tr></table></figure><p>在run方法中：</p><ul><li>首先会判断period是否等于0（即<code>isPeriod</code>方法）是不是周期任务，如果不是那就直接调用FutureTask的run方法直接执行</li><li>如果是的话就需要执行runAndReset方法执行，执行完还需要重新设置下次运行时间，并重新放入队列</li><li><strong>在设置时间的时候</strong>，仍然会进行区分:<ul><li>如果$period&gt;0$，那就说明是固定速率执行，那就是<code>time+period</code></li><li>如果$period&lt;0$，那就是每隔period执行，那就是当前时间<code>now()+(-peirod)</code></li></ul></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h4 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h4><ol><li>当一个线程中某个对象需要使用很多次，为了避免每次使用都要new一个的开销，我们可以用ThreadLocal给它存起来，后面用直接取就行了</li><li>线程内需要保存全局变量，来避免传参麻烦。就比如token的身份校验，一个请求中用户的身份应该都是同一个，那么我们可以将用户的身份解析出来然后存到threadLocal中</li></ol><blockquote><p>但是，在第二种场景中，我们在拦截器退出操作的时候，要记得ThreadLocal的remove，否则会<strong>内存泄漏</strong></p></blockquote><h4 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h4><p>基于Thread私有变量threadLocals，这个threadLocals是ThreadLocal类中定义的ThreadLocalMap变量，这个map的key是threadLocal对象实例，value就是这个ThreadLocal的值，那么我们就应该知道了ThreadLocal、Thread、ThreadLocalMap的关系了吧：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405191518040.png" alt="image-20240519151814888" style="zoom: 33%;" /><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>这个Map和HashMap可不一样，实现方式都是不同的</p><ul><li>首先，它处理哈希冲突的方式不是拉链法，而是开放定址法</li><li>其次，动态扩容的阈值也不一样，HashMap是数组容量的0.75，而ThreadLocalMap是$\frac{2}{3}$</li><li>最后，ThreadLocalMap的key是ThreadLocal变量的弱引用</li></ul><p>也就是说，如果发生GC，那么这个threadLocal的key就没了</p><blockquote><p>那为什么，我们ThreadLocal调用get为什么还是能拿到，不是发生GC就没了吗？</p><p>因为弱引用发生GC回收对象，只会出现在<strong>这个对象有且只有弱引用</strong>。如果有强引用指向它，那么仍然不会被GC掉，因此我们ThreadLocal变量一般声明为static final，这样强引用一直在，就不会被回收了</p></blockquote><h4 id="Thread-Local源码"><a href="#Thread-Local源码" class="headerlink" title="Thread Local源码"></a>Thread Local源码</h4><ul><li><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果从map里面get出来为空，那么我们就执行threadLocal的initialValue方法，初始化变量，否则只要你set过了，那么就算你重写了initialValue也不会执行，initialValue方法是<strong>懒加载的</strong></p></li><li><p>set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前线程的threadLocalMap，然后调用set方法</p></li></ul><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><blockquote><p>这里先理清一下内存泄漏和内存溢出的区别</p><p>内存泄漏指的是：对象不使用了，应该被回收，但是没被回收</p><p>内存溢出指的是：就是申请的内存不够用，造成outofMemory</p></blockquote><p>ThreadLocal中key是弱引用，但是value为强引用，一旦ThreadLocal外部的强引用没了，ThreadLocalMap中的key就会没了，无法访问到value，但是value的强引用还在，无法GC</p><p>TheadLocal的ref没了，key对应的ThreadLocal确实会被回收掉，但是value还存在一条链路：</p><p><code>threadRef—&gt;thread-&gt;ThreadLocalMap-&gt;Entry-&gt;value</code></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406302341634.png" alt="img" style="zoom:67%;" /><h2 id="AQS抽象队列同步器"><a href="#AQS抽象队列同步器" class="headerlink" title="AQS抽象队列同步器"></a>AQS抽象队列同步器</h2><p>AQS全程是AbstractQueueSynchronizer，即抽象队列同步器。</p><p>既然是抽象的，那肯定就是某一类组件的公共基础部分的抽取，其实AQS就是JUC并发工具的基石框架，主要解决的问题就是：<strong>多线程下锁的分配问题</strong></p><p>AQS本质就是，通过一个FIFO的队列完成对资源state的管控，完成对多线程的控制同步</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406050105638.png" alt="CLH 队列" style="zoom:50%;" /><h3 id="AQS模版方法"><a href="#AQS模版方法" class="headerlink" title="AQS模版方法"></a>AQS模版方法</h3><p>在AQS中，定义了很多final方法，比如acquire、release</p><p>在这些方法中，定义了获取和释放资源的执行逻辑，但是需要用户去自定义如何去获取和释放资源</p><p>这是AQS提供的几个可以重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">tryAcquire(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><p><strong>用户可以自定义如何去获取资源，但是获取失败后的入队、唤醒、阻塞的逻辑AQS已经帮你写好了，并且声明为final接口，不可被重写</strong></p><p>并且这些方法必须重写，不重写就会执行默认的方法：直接抛出UnsupportedOperationException</p><h3 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h3><p>AQS将每个线程封装在一个Node类中，这个Node对象就是AQS队列中的每个节点，它按照入队的顺序进行存储，并且对于<strong>某个节点只能由其前驱节点唤醒</strong></p><blockquote><p>虽然说ReentrantLock有公平和非公平两种实现形式，<strong>但是最终如果入队了，还是按照入队的顺序一个一个获取锁</strong>，只是说在tryAcquire的时候非公平锁只要发现可以占有就直接占有，而公平锁就算可以占有，但队列有节点在排队还是不会占有。</p></blockquote><p>对于Node对象，除了封装了等待的Thread类以外，还有一个叫waitStatus，这个很重要，一共有五个值：</p><ul><li><code>CANCELLED</code>，值为1，表示当前的线程被取消。</li><li><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。</li><li><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中。</li><li><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。</li><li>初始，值为0，表示当前节点在sync queue中</li></ul><h3 id="acquire函数"><a href="#acquire函数" class="headerlink" title="acquire函数"></a>acquire函数</h3><p>在AQS中，提供了一个模版函数acquire，用于获取资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数由三个部分组成：<code>tryAcquire</code>+<code>addWaiter</code>+<code>acquireQueued</code></p><p>其中<strong>tryAcquire函数</strong>是需要在子类中被重写，并且是必须重写的，因为在AQS中这个tryAcquire函数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquire函数是通过用户定义的方式来获取资源，即改变state，如果不满足获取条件就会返回false，接下来就会调用AQS定义的<code>addWaiter</code>+<code>acquireQueued</code>这两个函数，处理入队、阻塞等逻辑</p><p>而这两个函数是AQS中被声明为final的函数，也就是说这些阻塞、入队逻辑由AQS提供，用户只需要考虑如何获取资源就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//private是隐式的final</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是acquire函数的大致思想（模版方法），具体这两个函数怎么工作的后，下面会详细介绍</p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>这个函数会创造一个新的节点，然后将这个节点入队，具体入队操作就是：</p><ul><li>将tail的next指向新节点，再CAS将tail指针指向新节点</li></ul><p>这个操作只会在tail不为空的时候进行，如果AQS队列还没有初始化或者CAS失败了，那就要进入enq函数，进行自旋直至替换tail成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果发现队列还没有初始化，就说明tail和head都是null，那就需要在第一次循环中先创建一个虚拟头节点，将tail和head都指向它，然后在进入第二次循环</p><p>在后面的循环中，重复执行入队操作直至CAS成功</p><blockquote><p>为什么要创建虚拟头节点？</p><p>因为队列中被阻塞的节点都需要被前驱节点唤醒，如果把搞一个虚拟头节点，那么第一个入队的节点就没人唤醒了，导致整个队列都无法被唤醒！</p></blockquote><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>这个函数就是阻塞等待唤醒，唤醒后获取资源的函数，这个函数返回值是 该线程在park的时候有没有被inturrpt唤醒。如果被唤醒了就会返回true，并且会在获取资源后，执行<code>selfInterrupt</code>方法，再次把中断标记置为true</p><p>在每次循环中：</p><ul><li>如果发现其前驱是头节点，那么就tryAcquire一下，成功了就把自己设为头节点，因为头节点的任务已经完成了（唤醒了后继节点），那么接下来就由抢到资源的节点去唤醒下一个头节点了</li><li>如果发现不是头节点，那么要做两件事：<ul><li>一个是将其前驱节点的waitStatus设置为SIGNAL，让其释放锁的时候去唤醒它；如果前驱节点是cancle状态，那就找到前面第一个不是cancle的节点修改其为自己前驱，然后再设置为SIGNAL</li><li>第二件事就是park，在park的时候为了防止被inturrpt唤醒，一旦被唤醒就会通过Thread.interrupted操作将其中断标记改为false并返回true，然后一直死循环到其前驱节点是头节点，才会出去</li></ul></li></ul><blockquote><p>这样做的原因是，由于AQS是不允许inturrupt唤醒线程的，因此一旦被唤醒就直接让其进入死循环，这样还是相当于什么事也干不了，让用户对于被inturrupt唤醒这件事无感知（以为还是阻塞，其实已经被inturrupt唤醒在里面死循环）</p><p>但是，有时候又需要知道这个线程是否被inturrupt过，因此在获取到资源后，如果被打断过，就需要<code>selfInterrupt</code>一下，重新把打断标记置为true</p></blockquote><h3 id="release函数"><a href="#release函数" class="headerlink" title="release函数"></a>release函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放成功</span><br>        <span class="hljs-comment">// 保存头节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空并且头节点状态不为0</span><br>            unparkSuccessor(h); <span class="hljs-comment">//释放头节点的后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>release方法也是一个模版方法，用户自定义AQS同步器的时候，需要重写tryRelease方法，来对state操作，但是释放后，如何去唤醒其他线程那是AQS自己定义的</p><p>操作完资源后，就会让头节点去唤醒它的后继节点，执行<code>unparkSuccessor</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span><br>        <span class="hljs-comment">// 比较并且设置结点等待状态，设置为0</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-comment">// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span><br>        s = <span class="hljs-literal">null</span>; <br>        <span class="hljs-comment">// 从尾结点开始从后往前开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>             <span class="hljs-comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>) <br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 该结点不为为空，释放许可</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果后续节点是cancel状态，那就找到后面的第一个不是canel的节点，将其唤醒；如果是那就唤醒</p><p>唤醒的节点就会重新开始acquireQueued中的死循环，由于是被头节点并且还是前驱节点唤醒的，因此就会执行tryAcquire获取资源，拿到资源就会把自己设置为头节点，方便唤醒后继节点</p><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>如果想像synchronized一样，在执行的时候调用wait函数来释放锁，并在别的线程中通过notify函数重新唤醒来重新去争抢锁</p><p>那就需要通过AQS中的ConditionObject来实现，它提供的await和signal方法就分别对应了wait和notify方法，下面一个一个介绍吧</p><h4 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h4><p>这个就不放源码了，比较简单</p><ul><li>首先会创建一个waitStatus为CONDITION的节点，然后将其放入Condition的等待队列中</li><li>然后就会释放持有的锁，就是调用AQS提供的release方法释放，释放完就park自己</li><li>一旦park结束就会先校验是不是意外打断导致的唤醒，如果是就继续park，否则就开始重新获取资源，调用acquireQueued方法</li></ul><h4 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h4><p>那么await中被park住的线程是如何被唤醒的呢？就是通过signal调用unpark方法释放</p><ul><li>首先，它会找到waiter队列中的第一个节点，取出来然后更新队列</li><li>更新完了后，就将该节点放到AQS队列中，然后unpark一下去竞争，这个时候刚刚await方法中的park结束继续执行下去，调用acquireQueued方法（其实这个方法执行中该阻塞还是会阻塞）</li></ul><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch底层用到的是共享锁的acquire和release，正好接着这个来看一看共享锁是如何acquire和release的</p><p>CountDownLatch基本思想就是，初始化state为n，然后n个线程分别调用countDown使state减1，接着如果调用了await函数，就会阻塞，直到state为0的时候就会释放</p><p>由于await操作是共享的，当队列里有多个节点被await阻塞了，应该以传播的方式依次唤醒，所以整个CountDownLatch使用的是共享的acquire和release</p><h3 id="acquireShared方法"><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h3><p>当调用await的时候实际上调用的是acquireSharedInterruptibly，但是这个和acquireShare差不多，我们就拿acquireShared来分析分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法调用Sync的tryAcquireShared以及AQS的doAcquireShared，而在countDownLatch中的tryAcquireShared就是看看state是不是0，是就返回1，不是就返回-1</p><p>接着如果发现小于0就说明无法获取共享资源，那就需要执行AQS提供的doAcquireShared方法</p><p><code>doAcquireShared</code>方法和以前tryAcquire方法类似，也是先addWaiter，但是这里创建的Node的waitStatus是<code>Node.SHARED</code>，一样如果发现是头节点就会尝试获取锁，不然就shouldPark再park阻塞</p><p>但是不同的是，当doAcquireShared成功tryAcuqireShared后，就不是单纯的setHead，而是<code>setHeadAnPropagate</code>，这个操作不但会把当前节点设置为头节点，并且如何其后继节点也是因为SHARED状态，也会释放（<strong>因为是共享阻塞，一旦共享锁可获取，因为此等待的线程都应该被唤醒去尝试获取</strong>）</p><h3 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h3><p>当调用CountDownLatch的countDown方法，就会调用releaseShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法同样也是模版方法，会先调用CountDownLatch重写的tryReleasedShared方法，在调用doReleaseShared方法</p><p>tryReleasedShared会将当前state减1，然后看看state是否到0，如果到了就需要返回true，这样才能调用doReleaseShared去唤醒阻塞线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个释放会释放后续所有的为SIGNAL线程，因为每次释放后，其他线程都会去抢锁把自己设置为head</p><p>因此最后只有发现释放完原本的没有变化就说明释放完了，不然的话一旦unpark了一个节点就会tryAcuqireShared一次然后再次更新head，，这样刚开始拿到的h和现在的head不想等，无法break出去；只有后续没有节点释放了，先开始拿到的head还是head，这样最后满足条件，才会break出去</p><p>也就说<code>doReleaseShared()</code>方法会以一种风暴的形式唤醒后续的第一个获取写锁之前的所有获取读锁的节点，没有写锁将会唤醒整个队列</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM内存模型理解</title>
    <link href="/2024/05/30/%E5%85%AB%E8%82%A1/2024-05-30-JMM%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/"/>
    <url>/2024/05/30/%E5%85%AB%E8%82%A1/2024-05-30-JMM%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JMM内存模型理解"><a href="#JMM内存模型理解" class="headerlink" title="JMM内存模型理解"></a>JMM内存模型理解</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p>在计算机底层系统中，都知道是有主存-&gt;cache-&gt;寄存器这样一个等级的，但是在多核高并发的情况下，就会出现内存的读写不一致的问题，那么该如何解决呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406010153682.png" alt="image-20240601015358523" style="zoom: 33%;" /><p>首先，要知道的是OS对于读写一致性是由解决方法的，比如总线嗅探机制的MESI协议</p><p>但是，对于不同的硬件平台和OS搞出一套不同的解决方案那是不可行的，并且这些协议是由OS将数据写回主存，<strong>为了屏蔽硬件和操作系统的差异并且可以自己决定写回内存的时机</strong>，JMM定义了一堆东西比如volatile、synchronized，定义了一个变量的读写方式、可见性、原子性、有序性等等问题，由用户通过JMM提供的这些方式进行同步</p><p><strong>因此，JMM是一种抽象的概念和规范</strong>，有了JMM你只需要考虑线程工作内存、主内存这两个东西，你不需要考虑寄存器、这个CPU有几级cache那些玩意儿一层层的同步。</p><p>JMM告诉你，要想实现可见性，你就可以用volatile、synchronized</p><blockquote><p>其实，JVM底层这些关键字的实现还是对于不同平台有不同的实现，只不过对用户屏蔽了</p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406010129724.png" style="zoom: 33%;" /><h3 id="JMM三大特性：原子性、有序性、可见性"><a href="#JMM三大特性：原子性、有序性、可见性" class="headerlink" title="JMM三大特性：原子性、有序性、可见性"></a>JMM三大特性：原子性、有序性、可见性</h3><ol><li><p><strong>原子性</strong>：要和数据库事务区别，在并发中指的是多个指令的执行不允许被中断</p><p>在java中如果有一个<code>i++</code>操作，其实分为了三步 load 、add、store，如果运行完load执行后其他线程抢占了时间片，先一次性执行了这三个操作修改了i的值，那么等到原线程回来恢复寄存器后，执行add操作那么add的src操作数还是先开始修改前的值在store回去，那就出问题了，相当于只修改了一次。</p><blockquote><p>那么该如何保证操作的原子性呢？</p><p>通过<strong>锁</strong>实现：<strong>synchronized、lock、AomicInteger（CAS锁）</strong></p></blockquote></li><li><p><strong>有序性</strong>：指令在CPU调度执行时，CPU为了提升效率（比如缓存局部性原理重排后提高cache命中），在不影响结果的前提下，对CPU指令重排序</p><p><strong>重排的原则必须遵循happens-before</strong>，不满足会导致运行结果不同，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">11</span>;<span class="hljs-comment">//1</span><br>    <span class="hljs-type">int</span> y=<span class="hljs-number">11</span>;<span class="hljs-comment">//2</span><br>    x=x+<span class="hljs-number">5</span>;   <span class="hljs-comment">//3</span><br>    y=x*x;   <span class="hljs-comment">//4</span><br>    <span class="hljs-comment">//为了增加cache命中，搞不好顺序就会被重排为1324，但是绝对不会重排为4123（影响结果了）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是指令重排对于单线程是没有问题的，一旦开启多线程就会出现问题,最典型的问题就是单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">//分为三步：1.申请内存空间 2.构造函数 3.返回指针赋值给引用instance</span><br>         <span class="hljs-comment">//原则上，123和132结果都一样</span><br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是多线程情况下，如果new对象的时候三步发生指令重排，<strong>导致2排在3后面</strong>，那么就会出现引用已经拿到对象地址，但是对象还没有执行构造函数，如果其他线程获取到了这个未初始化的引用，那么执行get方法获取属性就有可能会出问题</p><p>如果不希望CPU重排序，JMM给你规范了，可以对属性追加volatile修饰，禁止对该属性的操作指令重排序</p></li><li><p><strong>可见性</strong>：CPU处理时，需要从内存读取数据，走总线传到寄存器中，然后进行计算，算完后将结果写回内存。</p><p>但是，从寄存器写回内存，并不是立即写回而是会遵循MESI协议。这就会导致内存不同步的问题。</p><p>解决方法：volatile每次操作就会写回主存、synchronized触发和释放的时候会同步一次</p></li></ol><h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>happens-before是对有序性和可见性的约束，它是对程序员的承诺，如果你的顺序满足happens-before条件，你就不需要考虑可见性问题，就不要每个变量都要volatile、synchronized</p><p>如果一个操作happens-before另一个操作，那么第一个操作执行结果对第二个操作可见，如果重排序后的结果不会影响满足happens-before规则的执行结果，那么就可以重排序。</p><p>但是JMM对于不会影响happens-before结果的重排序不进行保障，因此还是需要volatile保证有序性，这也被写在happens-before原则中了。</p><blockquote><p>也就说，happens-before其实保证了有序性和可见性，如果发生重排序导致结果不对，那是因为你没有充分利用happens-before，因为你可以利用volatile规则来约束有序性</p><p>happens-before无法保证原子性，即使执行顺序对，但多线程中指令的穿插执行仍然会导致不符合预期的结果</p></blockquote><p>happens-before规则一共有8条</p><ol><li><p><strong>次序规则</strong>：一个线程内，按照代码的顺序，前面的操作先行发生于后面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">11</span>;<span class="hljs-comment">//1</span><br>    <span class="hljs-type">int</span> y=x;<span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中：x&#x3D;11对y&#x3D;x可见这个虽然从直观角度没啥问题，但这个其实是JMM规定的，如果不限制很可能2重排到1前面了</p></li><li><p><strong>锁定规则</strong>：unlock操作发生于<strong>后面</strong>对同一个锁的lock操作</p><blockquote><p>这里后面是指：<strong>多线程下，只要当前unlock时间发生在其他线程lock前面</strong>，那么其他线程看到的一定是解锁的状态</p><p>在后续规则中，凡是涉及<strong>后面</strong>，不做说明都是指多线程中发生时间上的先后，不是代码指令顺序的先后</p></blockquote></li><li><p><strong>volatile变量规则</strong>：对一个volatile的写操作先行发生于<strong>后面</strong>对这个变量的读操作</p></li><li><p><strong>传递规则</strong>：A happens-before B &amp;&amp; B happens-before C -&gt; A happens-before C</p></li><li><p><strong>线程启动规则</strong>：线程的start方法，先行于线程中run方法中的所有指令</p></li><li><p><strong>线程终端规则</strong>：线程的interrupt方法，先行于线程检测到中断事件</p></li><li><p><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测</p></li><li><p><strong>对象终结规则</strong>：一个对象的构造函数先行发生于它的finalize方法</p></li></ol><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="Volatile用处"><a href="#Volatile用处" class="headerlink" title="Volatile用处"></a>Volatile用处</h3><p>被volatile修饰的变量可以保证变量的可见性和有序性，因为加了volatile就相当于对于这个变量操作加了一条happens-before规则的约束，这个规则可以保证可见和有序</p><p>从<strong>内存访问角度</strong>看：volatile变量的写是直接写到主内存中，读是先让本地内存的旧值无效，再从主内存中读</p><p>那底层是怎么实现的呢？那就是<strong>内存屏障</strong></p><h3 id="从JVM看：内存屏障"><a href="#从JVM看：内存屏障" class="headerlink" title="从JVM看：内存屏障"></a>从JVM看：内存屏障</h3><p>JMM给了8条happens-before规则，那么底层到底是怎么实现的的呢？从JVM层面来看，就是使用内存屏障</p><p>JVM规定了任何虚拟机的实现都需要实现四种内存屏障：LoadLoad、LoadStore、StoreLoad、StoreStore</p><p>就是说这两个操作不能交换顺序，即不允许重排序</p><p>那么对于volatile修饰的变量，就是在读写操作时，加这两个内存屏障就可以保证可见性和有序性</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406022252939.png" alt="image-20240602225236798"></p><h3 id="从Hotpot和CPU看"><a href="#从Hotpot和CPU看" class="headerlink" title="从Hotpot和CPU看"></a>从Hotpot和CPU看</h3><p>volatile有不同的实现方式，比如对于不同的CPU写汇编，插入mfence（全屏障）、lfence（读屏障）、sfence（写屏障），或者就是直接简单粗暴的lock总线，保证同一时间只有一个线程在访问内存</p><p>那么hotpot为了开发更加简单，选择了后者，因为lock指令是不同CPU都提供的指令，更具有普适性</p><h3 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h3><p>最典型的就是DCL单例实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;单例初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-literal">null</span>)&#123;<br>                    singleton=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>禁止创建对象的重排序，防止出现先赋值引用再执行初始化的情况</p><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><h3 id="从JMM角度来看"><a href="#从JMM角度来看" class="headerlink" title="从JMM角度来看"></a>从JMM角度来看</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405302238988.png" alt="image-20240530223817853" style="zoom: 33%;" /><p>对于AQS的lock以及synchronized锁，都有可能阻塞线程发生用户态到内核态的转换，因此<strong>CAS更轻量</strong></p><p>CAS全称叫CompareAndSwap，由于一个进程管理资源，当多个线程访问一个资源并且想要修改的时候:</p><ul><li>首先会先把旧值读到工作内存中并保存，然后根据这个值计算，并将结果放入同样保存一份到工作内存</li><li>根据offset和对象本身地址计算目标数据在主内存中的位置，将主存的值和上一步读入工作内存的值比较，如果一样就将计算结果直接写进内存中，否则自旋</li></ul><h3 id="从CPU角度看"><a href="#从CPU角度看" class="headerlink" title="从CPU角度看"></a>从CPU角度看</h3><p>由于Java不用户提供操作内存方法，因此Java的CAS只是给native方法传四个值：</p><p>读到工作内存的值、对象在主存的地址、目标数据相对于对象的偏移、想写入主存的值</p><p>然后根据这四个值，调用<code>CMPXCHG</code>指令，但是不同的CPU平台实现是不一样的，因此会有很多实现</p><p>但是要注意的是，<code>CMPXCHG</code>本身并不能保证原子性，因为对于多核而言<strong>真的会并行</strong>，所以如果是多核CPU那么就要在前面加上lock指令防止别的线程在执行该条指令的时候修改内存</p><blockquote><p>比如，正在从总线往内存写的时候，别的线程也改了，那么还是会覆盖，因此需要加入lock指令，lock指令只允许一个核对同一处内存操作</p></blockquote><p>因此最终CAS的底层实现最终是指令<code>LOCK CPMXCHG CX DX</code>实现的</p><p>CAS虽然不会阻塞线程性能更高，但是会带来一下几个问题：</p><ol><li>只能对一个变量修改保证原子性，无法实现同步代码块</li><li>ABA问题，版本号解决</li><li>如果并发太夸张，导致CAS一直在自旋，占用CPU资源</li></ol><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>由于synchronized的实现和对象头中的markword息息相关，因此先来看看一个java对象的内存组成有哪些</p><h3 id="宏观来看"><a href="#宏观来看" class="headerlink" title="宏观来看"></a>宏观来看</h3><blockquote><p>在说这个之前，我们要先讲讲Java的引用大小问题：</p><p>在64位的OS中一个指针的大小是8B的，但是Java默认开启了<strong>对象头指针压缩</strong>和<strong>成员变量对象指针压缩</strong>，压缩后的指针大小会从8B变成4B</p></blockquote><p>下面来聊一聊对象内存布局，我们以64bit的hotpot JVM为例：</p><p>对象内存布局分为两种，一个是普通对象，一个数组对象</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406032351484.png" alt="image-20240603235114382" style="zoom: 33%;" /><ul><li><p>一个对象分为三个部分：</p><ul><li><p><strong>对象头</strong>，包括markword、class pointer等</p><ul><li>markword，存储了hashcode、GC age等等，并且当成为锁对象后会重写markword（后面再说）</li><li>class pointer，指向方法区类元信息的指针（<strong>不是Class类！</strong>），标注它属于哪个类，由于开启指针压缩因此就是4B</li><li>数组对象会多一个数组长度信息</li></ul></li><li><p><strong>实例数据</strong>，存放数据的地方，但是如果这里有对象，那么就是指针的大小，由于默认开启了指针压缩，因此也是4B，<strong>数组的话就是所有数据按顺序堆叠起来</strong></p></li><li><p><strong>对齐</strong>，由于是64位的JVM，因此对齐按8B对齐</p></li></ul></li></ul><blockquote><p>注意：成员变量的long和Long占的字节分别是8B和4B</p></blockquote><h3 id="Markword"><a href="#Markword" class="headerlink" title="Markword"></a>Markword</h3><p>Markword具体内容和锁的级别息息相关</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406040003561.png" alt="image-20240604000307369" style="zoom: 45%;" /><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p>早期的Synchronized一上锁就是重量级，但是后面lock出来、CAS出来，Java团队在JDK1.6不得不对synchronized进行了优化，优化总共分为三部分：<strong>锁升级、锁消除、锁粗化</strong></p><p>其中<strong>锁升级</strong>极为重要！！！</p><h3 id="锁升级总体过程"><a href="#锁升级总体过程" class="headerlink" title="锁升级总体过程"></a>锁升级总体过程</h3><p>由于原本的synchronized过于庞大，一使用直接干到内核态，十分消耗时间和资源，因此在JDK1.6中，为了尽可能减少进入内核态的次数，并且<strong>主观上认为synchronized同步的代码块往往并发量不高且运行时间不长</strong></p><p>JDK1.6团队提出了锁升级的概念：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong></p><p>那么我们先一个一个介绍这几个锁吧</p><p>（太难了，我就自己理解理解，写出来很有可能是错的，有时间把JVM源码看明白了再写）</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>延时、hashCode</p><p>cas_set_mark(mark,header)：查看对象的header是否和mark一样，一样就swap</p><p>偏向锁也会生成lock record（第一次进入都是一个无锁的markword+ref_object，和轻量级锁一样），并且重入一次就会再生成一个</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JIT会对方法进行逃逸分析，如果锁对象并没有出现在调用方法外，那么synchronized(object)就会被JIT无视</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">//该锁对象不会出现在该方法外</span><br>    <span class="hljs-keyword">synchronized</span> (o)&#123;<br>        System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果连续很多个代码块，用的同一个锁对象，那么不会synchronized多次，而是只会synchronzied一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">5000</span>);<br>    Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-comment">//连续三个synchronized</span><br>        <span class="hljs-keyword">synchronized</span> (o)&#123;<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (o)&#123;<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (o)&#123;<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch总结</title>
    <link href="/2024/05/18/%E5%85%AB%E8%82%A1/2024-05-18-ElasticSearch%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/18/%E5%85%AB%E8%82%A1/2024-05-18-ElasticSearch%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch总结"><a href="#ElasticSearch总结" class="headerlink" title="ElasticSearch总结"></a>ElasticSearch总结</h1><h4 id="ES和MySQL"><a href="#ES和MySQL" class="headerlink" title="ES和MySQL"></a>ES和MySQL</h4><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>相比于MySQL的文档id找text的方式，es是将text分词过后，通过每个term去找对应文档</p><p>ES中分词后的word叫做term，所以我们这里也&#x3D;都就这么叫了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405180055247.png" alt="image-20240518005521205" style="zoom:50%;" /><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>term是经过排序的一个字典列表，我们称为term dictionary，当然如果把这个放在内存中，一旦数据海量了，必然内存会爆，那么该如何实现搜索呢？</p><p>用的是字符串前缀树，它可以快速锁定前缀在term dictionary中的位置，然后顺序往下找，因此lucence的倒排索引其实最终是长这个样子的：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405180053048.jpeg" alt="img" style="zoom:50%;" /><p>此外，lucence对于term dictionary还有两个优化点：</p><ol><li>term dictionary是以block存储在文件中的，如果block中的term具有相同前缀，可以把term的公共前缀删掉，比如block里面都是 Ab 开头的单词就可以把Ab省去，开头记录一次</li><li>term index底层使用FST存储的（FST后续会看看）</li></ol><h2 id="postings-list"><a href="#postings-list" class="headerlink" title="postings list"></a>postings list</h2><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>对于term dictionary、term index ，ES都进行了底层优化，那么每个term对应的id list（这里叫posting list），肯定也得优化，具体的痛点有这几个：</p><ul><li>虽然说id只是一个唯一标识的字段，但是如果有海量数据，那么id存储空间还是会比较大的，因此如何压缩也是个问题</li><li>对于联合查询，比如and 、or，这些，我们如何对postinglist做交集并集运算？</li></ul><h4 id="存储压缩"><a href="#存储压缩" class="headerlink" title="存储压缩"></a>存储压缩</h4><p>posting list的压缩主要用到了两个技术，分别是FOR（Frame Of Reference）和稀疏位图（Roaring Bitmaps）</p><ul><li><p>FOR</p><p>lucence的FOR就是单纯的做增量存储，由于差值不会特别大，相比于直接存储id，所需的存储空间更小，比如<code>[73, 300, 302, 332, 343, 372]</code>增量存储形式就是<code>[73, 227, 2, 30, 11, 29]</code>。在这个增量列表里面，每个元素都小于255，那么理论上可以只需要8bit就可以存下来了。</p><p>但是ES对于这个做的更精细，他首先将这个posting list同样分成多个block，每个block规定包含256个id，对这些id做增量存储，然后<strong>它会计算这些元素表示所需要的最大bit数是多少</strong>，算出来放在block头里面，进一步实现了位压缩。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405180053261.jpeg" alt="img" style="zoom: 50%;" /><p>比如对于增量列表<code>[73,227,2]</code>，那么最大的227需要8bit存储，因此block头置为8</p><blockquote><p>实际上就是把整型的存储从32位这样的一种表达形式，改成了一个用冗余字段表示的多种表达形式了</p></blockquote></li></ul><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ</title>
    <link href="/2024/05/17/%E5%85%AB%E8%82%A1/2024-05-17-RocketMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2024/05/17/%E5%85%AB%E8%82%A1/2024-05-17-RocketMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405170111562.png" alt=" "></p><ul><li>Producer Group：同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</li><li>Consumer Group：同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。<strong>广播模式</strong>下，一个队列的消息会发给每一个消费者，<strong>集群模式</strong>下，每个队列只会和一个消费者绑定，只会被消费一次。</li><li>NameServer Cluster：一个Broker与Topic路由的注册中心，Broker需要和NameServer保持长连接，定时发送心跳检测。并且还保存Broker路由信息以及队列信息，方便Consumer和Producer拉取信息消费。</li><li>BrokerCluster：Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。</li></ul><blockquote><p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的<br>Consumer将不能消费消息。</p><p>此外：</p><ol><li>消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息</li><li>一个消费者组中的消费者必须订阅完全相同的Topic</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405170114120.jpeg" alt="img"></p><h2 id="消息生产和存储"><a href="#消息生产和存储" class="headerlink" title="消息生产和存储"></a>消息生产和存储</h2><h4 id="消息生产"><a href="#消息生产" class="headerlink" title="消息生产"></a>消息生产</h4><p>Producer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：</p><ol><li>向NameServer发出获取消息Topic的路由信息的请求</li><li>NameServer返回该Topic的路由表及Broker列表</li></ol><blockquote><ul><li>路由表：key为topic，value是<strong>队列列表</strong>，但是这个队列列表的元素是按broker为单位分的，也就是说队列列表是一个二维列表</li><li>Broker列表：key为topic，value是<strong>Broker列表</strong>，Broker列表中的元素是一个Broker的主从集群作</li></ul></blockquote><ol start="3"><li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</li><li>Producer向选择出的Queue所在的Broker发出<strong>RPC</strong>请求，将消息发送到选择出的Queue</li></ol><h4 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h4><ol><li><p>commitLog文件</p><ul><li><p>commitLog存放了所有发到这个Broker上的消息（不区分topic），在RocketMQ的commitlog目录中存放着很多的mappedFile文件，每个文件大小为1G，文件名由20位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p></li><li><p>当一条消息进来后，就会<strong>顺序写入</strong>commitLog，当前mppedFile满了，就会创建新的继续写入</p></li><li><p>其中存放的最小单元是消息单元，</p></li><li><p>包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近20余项消息相关属性。</p></li></ul></li><li><p>consumequeue</p><ul><li>RokcetMQ同样也会为每个topic创建一个目录，每个topic目录下会为每个队列创建目录，目录名为queueId</li><li>每个队列目录下放了多个consumequeue文件，它里面存放的每个单元是该消息在commitLog中的偏移量，即存放的是索引</li></ul><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405170134407.png" alt="image-20240517013452373"></p></li></ol><h4 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h4><p>一条消息进入到Broker后经历了以下几个过程才最终被持久化。</p><ul><li>Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即<br>QueueOffset</li><li>将queueId、queueOffset等数据，与消息一起封装为消息单元，写入到commitlog，形成消息索引条目</li><li>将消息索引条目分发到相应的consumequeue，如果消息包含key，则写入indexFile</li></ul><h2 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h2><h4 id="IndexFile结构"><a href="#IndexFile结构" class="headerlink" title="IndexFile结构"></a>IndexFile结构</h4><p>每个Broker都有一组IndexFile文件，名称是该文件创建时候的时间，一个IndexFile文件分为三个部分，分别是：indexHeader，slots槽位，indexData索引数据</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172344006.png" alt="img"></p><ul><li><p>indexHeader存放的是该索引文件的信息，比如索引条目个数、填充的slot条目个数等等</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172344431.png" alt="img"></p></li><li><p>slots就是一个hsh表，存放的是该索引条目在indexData中的位置，其底层处理冲突的方式是拉链法</p></li><li><p>indexData存放的是索引数据，存放对应msg在commitLog中位置等信息</p></li></ul><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172344523.png" alt="img"></p><blockquote><p>timeDiff是插入这条index时候距离索引创建时间（索引文件名获取）的偏移，方便按时间查找</p></blockquote><h4 id="IndexFile写入"><a href="#IndexFile写入" class="headerlink" title="IndexFile写入"></a>IndexFile写入</h4><p>当一个消息需要存到indexFile中的时候，会经过一下几个步骤：</p><ol><li><p>计算key的hash值，然后试图存放到indexFile中，会有两种情况需要新建一个indexFile：</p><ul><li>当前为第一个消息，还没有indexFile</li><li>indexFile的索引个数达到2000W，那么也需要新建</li></ul></li><li><p>存放的时候，会将hash(key)%500w，结果为存放的slots位置</p><ul><li><p>如果没有发生冲突，那么直接存放到indexData中，前驱indexDataNo置为空，并将该slots对应的indexNo置为存放的位置</p></li><li><p>如果发生冲突，就需要使用拉链法处理，构建indexData后，需要将原本slot底下的indexData的前驱indexDataNo置为新的indexDat的位置，然后slot也存放新的indexDataNo</p><blockquote><p>slot只存放最新的indexData在index部分的位置，类似undo log，index存放的才是实际拉链的链表顺序结构</p></blockquote></li></ul></li></ol><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><h4 id="维护顺序"><a href="#维护顺序" class="headerlink" title="维护顺序"></a>维护顺序</h4><p>对于<strong>集群模式</strong>而言：在RocketMQ的服务端有一个<code>ConsumserOffset.json</code>文件，他保存了每个消费者组对于每个消费队列的消费进度，每次发送pull request都会先找broker要offset</p><p>对于<strong>广播模式</strong>而言：由于每个消费者都要去消费topic的每个消息，因此这个offset保存在本地，不用去远程拉</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172353960.png" alt="image-20240517235309926"></p><h4 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h4><p>当一个消费者start后，就会调用pullMessageService.start()，这个就就会开启一个线程，做的事情就是从一个阻塞队列里面去读，读到一个pullRequest就拉去消息，然后回调pushCallBack函数处理消息，处理完就会更新pullRequest然后再放回去，这就实现了推送型接收</p><p>那么还有两个问题：</p><ol><li><p>pullRequest怎么放进去的？</p><p>负载均衡的时候，会重新分配一个队列，分配完就会将这个队列对应的pullRequest放进去</p><p>也就是说，一个队列对应一个pullRequest</p></li><li><p>如果pull的时候没有消息怎么办？</p><p>Broker的<strong>长轮询机制</strong>，Broker收到pullRequest后先根据tag过滤，然后看看对应的offset有没有新消息，有就立刻返回，没有就保留pullRequest，每五秒查询一次，查到再返回</p></li></ol><blockquote><p>pullConsumer就是单纯的从某个地方拉取多少条消息，没啥好说的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团面试笔试题</title>
    <link href="/2024/05/11/%E7%AC%94%E8%AF%95%E9%A2%98/2024-05-11-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2024/05/11/%E7%AC%94%E8%AF%95%E9%A2%98/2024-05-11-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团面试笔试题"><a href="#美团面试笔试题" class="headerlink" title="美团面试笔试题"></a>美团面试笔试题</h1><h2 id="多线程求和"><a href="#多线程求和" class="headerlink" title="多线程求和"></a>多线程求和</h2><p>输入一个int数组，和线程个数K，多线程求和输出最终sum</p><p>这题其实就是多线程，要注意的是如何给每个线程分配要求和的部分。其实可以有很多种方法，比如取模，或者直接暴力顺序拆分，而我在面试中使用的就是取模方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zenith.example.solution;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SumCalculator [] threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SumCalculator</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            threads[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SumCalculator</span>(i);<br>            threads[i].start();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(SumCalculator thread:threads)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (SumCalculator thread : threads) &#123;<br>            sum += thread.getSum();<br>        &#125;<br><br>        System.out.println(sum);<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SumCalculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sum;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SumCalculator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>            <span class="hljs-built_in">this</span>.index=index;<br>            <span class="hljs-built_in">this</span>.sum=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i*k+index&lt;array.length;i++)&#123;<br>                sum+=array[i*k+index];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="前K个频率最高数字"><a href="#前K个频率最高数字" class="headerlink" title="前K个频率最高数字"></a>前K个频率最高数字</h2><p>给你一个数组，和一个K。返回前K个出现频率最高的数字，最终输出一个数组</p><p>不管怎样，首先肯定先要用一个map来统计每个数字出现的个数。</p><h4 id="O-nlogn-方法"><a href="#O-nlogn-方法" class="headerlink" title="O(nlogn)方法"></a>O(nlogn)方法</h4><p>暴力排序，我们可以直接用不限容量的优先队列，一个一个往里放，最后输出前n个就行</p><p>但是这个方法可以优化</p><h4 id="O-nlogk-方法"><a href="#O-nlogk-方法" class="headerlink" title="O(nlogk)方法"></a>O(nlogk)方法</h4><p>由于我们只需要前k个，因此我们通过使用容量为K的优先队列</p><p>如果key的次数大于优先队列队尾的次数，那么就替换掉，由于优先队列是小顶堆且容量为K，因此时间复杂度为klogk，然后我们要从头遍历一次，最终为nlogk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zenith.example.solution;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:array)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.getOrDefault(num , <span class="hljs-number">0</span>);<br>            map.put(num ,cur+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>                <span class="hljs-keyword">return</span> map.get(a) - map.get(b);<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span>(Integer key:map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(pq.size()&lt;k)&#123;<br>                pq.add(key);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(map.get(key)&gt;map.get(pq.peek()))&#123;<br>                pq.poll();<br>                pq.offer(key);<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            res.add(pq.poll());<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="O-n-的方法"><a href="#O-n-的方法" class="headerlink" title="O(n)的方法"></a>O(n)的方法</h4><p>我们还有一个极致的空间换时间的方法，由于次数对应的数字是唯一的，那么我们可以直接反过来保存从次数到数字的映射，然后次数最大不会超过n，那么我们就从n反过来遍历，有数字就输出，直到输出了k个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zenith.example.solution;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:array)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.getOrDefault(num , <span class="hljs-number">0</span>);<br>            map.put(num ,cur+<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Map&lt;Integer,Integer&gt; countMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer key:map.keySet())&#123;<br>            countMap.put(map.get(key),key);<br>        &#125;<br><br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=array.length;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!countMap.getOrDefault(i,-<span class="hljs-number">1</span>).equals(-<span class="hljs-number">1</span>))&#123;<br>                res.add(countMap.get(i));<br>                k--;<br>            &#125;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列基础</title>
    <link href="/2024/05/10/%E5%85%AB%E8%82%A1/2024-05-10-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/10/%E5%85%AB%E8%82%A1/2024-05-10-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="MQ能干什么"><a href="#MQ能干什么" class="headerlink" title="MQ能干什么"></a>MQ能干什么</h4><p>MQ做的是事儿就是三大点：<strong>异步、解耦、削峰</strong></p><ol><li><p>异步</p><p>对于不同服务之间的相互调用，如果使用RPC的话那么就是同步的，一旦调用链很长就会十分耗时。</p><p>使用消息队列，就可以立即返回处理好的结果，剩下的后续的补充操作（比如秒杀后的创建订单、发送验证码）可以通过消息队列由Consumer尽自己最大能力的执行</p></li><li><p>解耦</p><p>为了保证服务的可扩展性，主服务可以只管发布消息，至于后续有多少其他服务接入进来不关主服务的事儿了，只需要订阅这个topic就好了。</p><p>但是如果不使用消息队列，每次增删改一个其他操作，就需要修改代码，耦合性很大</p></li><li><p>削峰</p><p>其实就是为了解决不同服务之间的性能差异，如果使用同步RPC调用，抛开耗时不谈，一旦主服务和子服务性能差异很大，那么当主服务接受很多请求的时候同步调用子服务就会导致子服务崩溃。</p><p>使用消息队列，可以缓存这些高并发的请求，由子服务尽最大努力的处理请求</p></li></ol><h4 id="MQ带来的问题"><a href="#MQ带来的问题" class="headerlink" title="MQ带来的问题"></a>MQ带来的问题</h4><p>加入这样一个中间件虽然有好处，但是也带来了很多副作用</p><ul><li>加入中间件首当其冲的就是会增加系统的复杂度，这个中间件挂了怎么办？集群怎么搞？消息丢失了怎么办？</li><li>消息重复消费问题，保证幂等性</li><li>消息顺序消费问题，到达有序并且发送有序，那么重发过后如何保证严格有序呢？</li><li>分布式事务问题，如果有一串消息需要作为事务执行，那么如何保证一起提交一起回滚？</li><li>消息堆积问题，如果消费者不给力或者其他原因，导致消息队列内存要满了怎么办？</li></ul><h4 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h4><ul><li><strong>队列模型</strong>很简单，就是把消息放到队列里面去，一个生产一个读取，没什么好说的，就是一个1对1的架构</li><li><strong>主题模型</strong>就不一样了，生产者只会一股脑的发送消息，放一个叫主题的地方，消费者可以自行订阅主题，只要订阅了这个主题的消费者，就会收到该主题关联的消息</li></ul><h2 id="MQ相关问题的解决"><a href="#MQ相关问题的解决" class="headerlink" title="MQ相关问题的解决"></a>MQ相关问题的解决</h2><h4 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h4><p>顺序消费分为<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。前者就是同一个消费队列收到的消息是有顺序的，后者则是消费者收到的所有消息有序，即使发生重试也要保证有序</p><p>严格有序会导致系统的性能严重下降，因为需要十分严格的确认机制</p><p>这里我们讨论普通有序，那就是正常解决方案，同一业务流发送到同一队列，消费者使用缓存队列开启本地多线程，然后同一业务流分配给同一线程</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>RocketMQ的分布式事务分为两个阶段，一个是发送事务，一个是消费事务</p><h4 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h4><p>这里我们需要注意的是，我们无法一味的增加消费者，因为RocketMQ的queue只会绑定一个Consumer，如果消费者数目大于queue，那么就失效了</p><p>其次，我们要看看是不是消费者消费过慢了，还是生产者发送太快了。</p><p>我们可以同时增加队列和消费者来解决，或者让同一个消费者本地开多线程去解决</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>Producer、Cosumer、Broker、Topic、Partition</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405100116685.png" alt="img" style="zoom:50%;" /><p>Partition的多副本，为每个Partiotion搞了一堆副本（可以指定数量），然后里面有一个leader副本，其他相当于备份副本，只有leader副本才会和Producer、Consumer交互</p><h4 id="Kafka消息的有序性"><a href="#Kafka消息的有序性" class="headerlink" title="Kafka消息的有序性"></a>Kafka消息的有序性</h4><p>我们要知道的是，对于Kafka来说对于一个Partition中的消息是有序的，因此解决方案两种：</p><ol><li>每个Topic只分配一个Partition（但是这肯定不合理！）</li><li>对于同一个业务流，我们发送到同一个partition，比如对于同一个订单的操作，我们根据订单的id决定发送到那个partition上</li></ol><h4 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a>Kafka如何保证消息不丢失</h4><p>丢失消息会出现在三个地方</p><ul><li>生产者：保证到达kafka，send的回调机制</li><li>Kafka内部：集群的某个节点丢失，多副本机制</li><li>消费者：offset手动</li></ul><h4 id="Kafka消息重复消费问题"><a href="#Kafka消息重复消费问题" class="headerlink" title="Kafka消息重复消费问题"></a>Kafka消息重复消费问题</h4><p>Consumer端做幂等性</p><h4 id="Kafka重试机制"><a href="#Kafka重试机制" class="headerlink" title="Kafka重试机制"></a>Kafka重试机制</h4><p>这会导致一个问题，重试过后，原本顺序为AB的发送顺序变成了BA</p><p>要保证这种严格的顺序消费，可以设置<code>max.in.flight.requests.per.connection</code>这个参数</p><p>该参数指定了生产者在收到服务器响应之前可以发送多少个消息（ACK一个才能往Kafka发一个）。它的值越高，就会占用越多的内存，同时也会提升吞吐量。把它设为1就可以保证消息是按照发送的顺序写入服务器的</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的一些问题</title>
    <link href="/2024/05/08/%E5%85%AB%E8%82%A1/2024-05-08-Spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/08/%E5%85%AB%E8%82%A1/2024-05-08-Spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring的一些问题"><a href="#Spring的一些问题" class="headerlink" title="Spring的一些问题"></a>Spring的一些问题</h1><p>Spring 其实就是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架</p><p>目前企业开发的标配就是：<strong>Spring5+SpringBoot2+JDK8</strong></p><h2 id="Spring应用的设计模式"><a href="#Spring应用的设计模式" class="headerlink" title="Spring应用的设计模式"></a>Spring应用的设计模式</h2><p>Spring中用到的设计模式还是很多的，我们一个一个讨论</p><ol><li>工厂模式：这其实就是Spring的核心技术IoC，整个IoC容器其实就是一个巨大的工厂，需要什么就提供什么。</li><li>代理模式：这也是Spring的另一个核心技术AOP，AOP的切面增强功能就是基于代理模式实现的。如果这个类继承于某个接口，一般就是JDK动态代理；如果没有，那么就是通过CGLIB搞一个继承它的子类。</li><li>单例模式：Spring容器中的Bean默认就是单例模式</li></ol><p>后面其实就是一些相对不是很重要的设计模式了，比如：</p><ul><li>模板模式：JdbcTemplate、RedisTemplate … 这些就是模板模式</li><li>观察者模式：Listener …</li><li>适配器模式：HandlerAdapter …</li></ul><h2 id="自己实现一个简陋版IoC"><a href="#自己实现一个简陋版IoC" class="headerlink" title="自己实现一个简陋版IoC"></a>自己实现一个简陋版IoC</h2><p>其实就是先在bean.properties文件里面配置好bean的name和对应的全限定包名</p><p>然后我们通过懒加载的方式获取并放到缓存里面就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//待实现</span><br></code></pre></td></tr></table></figure><h2 id="Spring-Bean的相关问题"><a href="#Spring-Bean的相关问题" class="headerlink" title="Spring Bean的相关问题"></a>Spring Bean的相关问题</h2><h4 id="Bean实例化的方式"><a href="#Bean实例化的方式" class="headerlink" title="Bean实例化的方式"></a>Bean实例化的方式</h4><p>construct、factory</p><h4 id="Bean依赖注入的方式"><a href="#Bean依赖注入的方式" class="headerlink" title="Bean依赖注入的方式"></a>Bean依赖注入的方式</h4><p>construct、setter、factory</p><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>Bean的生命周期分为主要分为四个大阶段：构造函数、设置属性（依赖注入）、初始化、销毁</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405092234967.png" alt="三分恶面渣逆袭：Spring Bean生命周期" style="zoom: 33%;" /><ul><li>构造函数就是构造函数，没啥好说的</li><li>设置对象属性，其实就是依赖注入，但是我们要注意的是这里的依赖注入应该是只针对xml文件的注入方式，如果是通过<code>@Autowired</code>注解注入的话，走的是初始化中的后置处理器，并不是在这里注入的</li><li>初始化：初始化其实又分为很多个步骤<ol><li>首先会检查很多Aware相关的接口，比如BeanName就是在这里获取的</li><li>然后会执行前置处理器，BeforeProcess</li><li>接着执行初始化，比如<code>@PostConstruct</code>修饰的函数就是在这执行的</li><li>然后执行后置处理器，比如AOP代理、Autowired依赖注入等</li></ol></li></ul><h4 id="Bean循环依赖的解决（三级缓存）"><a href="#Bean循环依赖的解决（三级缓存）" class="headerlink" title="Bean循环依赖的解决（三级缓存）"></a>Bean循环依赖的解决（三级缓存）</h4><p>循环依赖就没啥好说的了，但是我们要注意的是Spring的循环依赖解决方式只能解决setter注入的且是非懒加载的循环依赖</p><p>三级缓存的定义分别是：</p><ul><li>一级缓存：已经初始化完的对象</li><li>二级缓存：没完全初始化完的对象</li><li>三级缓存：没完全初始化完的对象的工厂对象</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405100125794.png" alt="三分恶面渣逆袭：三级缓存" style="zoom: 50%;" /><p>我们就举一个简单的例子，A和B有循环依赖</p><ul><li>首先按照初始化的顺序，我们先初始化A（这个时候没有人需要A，因此A目前放在的是三级缓存中），当发现需要依赖注入B的时候发现1、2、3级缓存都没有，那么就会去初始化B</li><li>B初始化的时候，由于也没有人需要B，那么也是放在三级缓存中的，等到依赖注入的时候发现需要A，那么就又会去缓存中找，这个时候在三级缓存找到了A</li><li>那么B就会通过三级缓存的工厂对象搞出一个A来，不管是A本身还是代理对象，反正就是搞出来了一个A</li><li>那么既然搞出来了一个A，那这个A就会被放到二级缓存了，同时会将这个A注入到B中，至此B初始化完毕，放到一级缓存中</li><li>最后，继续回到A的初始化，A这次就从一级缓存中拿到了B，那么就可以注入进来，至此A也初始化完毕，也放到一级缓存</li></ul><h2 id="SpringMVC的两种工作流程"><a href="#SpringMVC的两种工作流程" class="headerlink" title="SpringMVC的两种工作流程"></a>SpringMVC的两种工作流程</h2><h4 id="使用ModelAndView"><a href="#使用ModelAndView" class="headerlink" title="使用ModelAndView"></a>使用ModelAndView</h4><p>这个已经背烂了，没啥好说的直接上图：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405100125392.png" alt="三分恶面渣逆袭：Spring MVC的工作流程" style="zoom:50%;" /><blockquote><p>注意的是：HandlerAdapter和Handler应该是一一对应的，它是为了将Request适配到对应的Handler上</p></blockquote><h4 id="不使用ModelAndView"><a href="#不使用ModelAndView" class="headerlink" title="不使用ModelAndView"></a>不使用ModelAndView</h4><p>当我们在Controller的某个方法上加上了<code>@ResponseBody</code>注解的话，那么返回的就是json格式的数据了，而不是ModelAndView，那么这时候工作流程是怎样的呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405092259092.png" alt="Spring MVC Restful请求响应示意图" style="zoom: 20%;" /><ul><li><p>其实先开始都是一样的，先通过HandlerMapping找到Handler，然后通过HandlerAdapter调用对应的Handler</p></li><li><p>但是等到HandlerAdapter返回的时候，因为没有视图，返回的这个ModelAndView是NULL</p></li><li><p>在调用完Handler方法后，Adapter会进一步调用HandlerMethodReturnValueHandler来处理返回值，简单说就是将json序列化，写到 ServletServerHttpResponse（封装了原生的HttpServletResponse）中返回</p></li></ul><h2 id="SpringBoot的相关问题"><a href="#SpringBoot的相关问题" class="headerlink" title="SpringBoot的相关问题"></a>SpringBoot的相关问题</h2><p>SpringBoot一句话来说，就是为了简化Spring开发中的一堆复杂的配置</p><h4 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h4><p>SpringBoot的自动装配是由SpringBootApplicaiton这个注解实现的，这个注解包含三个部分：</p><ul><li><code>@SpringConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul><p>其中EnableAutoConfiguration注解就是开启了自动配置，它Import了一个AutoConfigurationImportSelector，接下来这个东西做了一下几步：</p><ol><li>首先，这个东西读取所有的MEAT-INF&#x2F;spring.factories里面的所有自动配置类，这里的每个类都是是加了<code>@Configuration</code>注解，也就是说这里面声明的所有Bean都<strong>有可能</strong>会被加载（为什么是有可能看后面）</li><li>然后这个Selector会根据SpringBootApplication注解中的exclude和excludeName排除掉不需要的自动配置类</li><li>最后，也不是剩下的这些东西所有配置类都会被加载，他会根据一系列ConditionOnxxx的条件，过滤掉不需要加载的配置类，剩下的就是会自动配置的类了</li></ol><blockquote><p>注意的是，这里MEAT-INF&#x2F;spring.factories不仅仅是spring底下的，只要你maven依赖的jar包，里面只要有这个文件，都会读取出来的</p></blockquote><h4 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h4>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis总结</title>
    <link href="/2024/05/08/%E5%85%AB%E8%82%A1/2024-05-08-Redis%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/08/%E5%85%AB%E8%82%A1/2024-05-08-Redis%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h1><h2 id="Redis基础问题"><a href="#Redis基础问题" class="headerlink" title="Redis基础问题"></a>Redis基础问题</h2><h3 id="Redis可以用来做什么"><a href="#Redis可以用来做什么" class="headerlink" title="Redis可以用来做什么"></a>Redis可以用来做什么</h3><p>一般来说，我用到最多的就是两个：一个是<strong>缓存</strong>，一个是<strong>分布式锁</strong></p><p>还有一些其他的应用，比如排行榜、计数器这种的</p><p>而至于有人说可以做消息队列、延迟队列啥的我觉得没有必要，因为有专门的东西来做比如RabbitMQ</p><h3 id="Redis为啥这么快"><a href="#Redis为啥这么快" class="headerlink" title="Redis为啥这么快"></a>Redis为啥这么快</h3><p>这是一个很老的问题，总的来说一共有三点：</p><ol><li><p>Redis是基于内存的，当然比基于磁盘的MySQL这种数据库快</p></li><li><p>Redis是单线程的，可以避免线程切换、锁获取释放的时间开销。</p><blockquote><p>但是我认为这也是高并发场景下的结果，如果并发不高，其实这个开销相比于多线程并行的提升可以忽略掉</p></blockquote></li><li><p>Redis采用的I&#x2F;O是多路复用。多路复用其实就是内核等待I&#x2F;O准备好通知内核来读取，而不是一直等待或者轮询I&#x2F;O是否准备就绪</p></li></ol><blockquote><p>如果要问你Redis这么快的主要原因，那么一定是基于内存的，这个相比于磁盘读取的速度快的可不是一星半点！</p></blockquote><h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>Redis快的一个原因就是IO多路复用，那么到底在什么地方用了呢？多线程又是在什么地方用了呢？</p><h3 id="Redis那些地方用了多线程"><a href="#Redis那些地方用了多线程" class="headerlink" title="Redis那些地方用了多线程"></a>Redis那些地方用了多线程</h3><ol><li>Redis2.6的时候，加了两个后台线程，一个是<strong>AOF刷盘</strong>，一个是<strong>异步文件关闭</strong></li><li>Redis4.0的时候，新增一个后台线程，用于异步释放key。比如调用“unlink key”指令的时候，就是异步释放内存。</li></ol><blockquote><p>也就说说，如果用的时候4.0以上版本，我们释放大key的时候，最好用<code>unlink</code>，而不是同步删除指令<code>del</code></p></blockquote><ol start="3"><li>Redis6.0以后，由于发现Redis的瓶颈在于内存和网络IO，而不是CPU，因此在网络IO处开启了多线程，默认是4个，可以修改配置</li></ol><h3 id="Redis的事件触发机制"><a href="#Redis的事件触发机制" class="headerlink" title="Redis的事件触发机制"></a>Redis的事件触发机制</h3><ul><li>首先，Redis的事件驱动模块就是一个无限循环的IO多路复用，它会一直循环如果发现有socket准备好，就会触发相应的事件处理器然后处理。</li><li>当事件触发后，就会先执行<code>beforeSleep</code>，然后获取触发的事件并一个一个处理事件，最后执行<code>afterSleep</code>。</li></ul><blockquote><p>比如：当新建事件触发后，就会注册命令请求处理器，<strong>绑定回调函数</strong><code>readQueryFromClient</code>，一旦客户端发起命令请求就会触发该事件，就会先执行<code>beforeSleep</code>，执行<code>readQueryFromClient</code>方法，最后执行<code>afterSleep</code></p></blockquote><h3 id="Redis6-0之前的单线程模式"><a href="#Redis6-0之前的单线程模式" class="headerlink" title="Redis6.0之前的单线程模式"></a>Redis6.0之前的单线程模式</h3><ul><li><p>在单线程模式中，发生命令请求，就会调用<code>readQueryFromClient</code>方法，该方法会读取socket并解析，解析后执行命令，最后会将返回结果写到缓冲区中，但是<strong>并没有写回客户端</strong>！</p></li><li><p>真正写回客户端，<strong>是在第二次事件触发的<code>beforeSleep</code>后</strong>，才会调用<code>handleClientsWithPendingWrites</code>，写回客户端。</p></li></ul><blockquote><p>要注意的是，单线程模式中，从读取socket到最后执行命令写到结果缓冲区，都是主线程通过for循环一个一个处理的</p></blockquote><h3 id="Redis6-0的多线程"><a href="#Redis6-0的多线程" class="headerlink" title="Redis6.0的多线程"></a>Redis6.0的多线程</h3><p>Redis6.0除了执行命令是主线程做的，从读取socket到解析命令都是IO线程做的，并且从结果缓冲区写回客户端也是IO线程做的。</p><ul><li>第一次事件触发的时候，由于写缓冲区没有数据，因此<code>beforeSleep</code>不会触发<code>handleClientsWithPendingWrites</code>，那么执行<code>readQueryFromClient</code></li><li>在<code>readQueryFromClient</code>中，会先判断是否开启多线程<ul><li>如果开启，那么就会将这些socket请求放到pending_read队列中，并标记为pending_read，然后就执行结束，直接进入aferSleep</li><li>如果没开启，那么就跟单线程一样，从读取socket到最后把结果写到缓冲区一直由主线程执行完</li></ul></li><li>在afterSleep中，会执行<code>handleClientsWithPendingReadsUsingThreads</code>，如果开启多线程，那么就会分配给多个IO线程让它们去执行<code>readQueryFromClient</code></li><li>由于已经标记为pending_read了，那么就会读取socket并解析命令而不是再次放到pending_read队列中，最后标记为pending_command（<strong>如果不标记，就会按照单线程逻辑继续顺序执行到<code>processCommandAndResetClient</code>执行命令</strong>，但是标记后解析完就会直接返回了）</li><li>在主线程中会while(1)，等待这些IO执行完，执行完后就会统一顺序执行<code>processCommandAndResetClient</code>方法，执行命令写到结果缓冲区，当下次事件触发，就会在<code>beforeSleep</code>方法中执行<code>handleClientsWithPendingWrites</code>方法，写回客户端</li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis既然是基于内存的，那么他是如何保证数据不丢失的呢？</p><p>答案就是持久化，redis给了三种持久化的方式：<strong>AOF</strong>、<strong>RDB</strong>、Redis4.0以后的<strong>混合持久化</strong></p><h3 id="AOF持久化概述"><a href="#AOF持久化概述" class="headerlink" title="AOF持久化概述"></a>AOF持久化概述</h3><p>AOF(Append Only File)，会将redis执行的每一条写命令追加到AOF日志文件中，然后重启redis后就会顺序执行文件中的命令并执行它，就相当于恢复数据了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321174.png" alt="img" style="zoom: 50%;" /><p>可以看出，和mysql的双写日志不一样，redis这里是先执行命令再写到日志为什么呢？</p><ul><li><strong>避免额外检查的开销</strong>。如果执行的命令有错，你在执行前就写到AOF日志中，要么就得校验要么就等指令出错再回滚。这两种方法都要多花时间。</li><li><strong>不会阻塞当前写操作命令的执行</strong>。因为是先执行命令再写日志，那么当前命令可以得到立即执行，最后写日志，不会受到写日志的IO阻塞</li></ul><p>当然，这样做也不是没有风险：</p><ul><li><p>还是会出现数据丢失的情况，如果执行完命令，还没来得及把AOF写入磁盘就宕机了，就会发生数据丢失</p></li><li><p>如果并发很高，指令很密，那么就会影响后面指令的执行</p></li></ul><h3 id="AOF文件刷盘策略"><a href="#AOF文件刷盘策略" class="headerlink" title="AOF文件刷盘策略"></a>AOF文件刷盘策略</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321396.png" alt="img" style="zoom:50%;" /><p>上述发生数据丢失，都是和AOF数据刷盘时机相关的，Redis给出了三个策略：</p><ul><li><strong>Always</strong>：每次写操作命令执行完后，同步将AOF日志数据写回硬盘。<strong>只会发生一条指令的丢失</strong></li><li><strong>Everysec</strong>：每次写操作命令执行完后，先将命令写入到AOF文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘。<strong>会发生1秒钟的数据丢失</strong></li><li><strong>No</strong>：不由 Redis 控制写回硬盘的时机，将命令写入到 AOF 文件的内核缓冲区后，由操作系统决定何时将缓冲区内容写回硬盘。<strong>无法确定</strong></li></ul><blockquote><p>其实，控制从内核缓冲区写到磁盘，就是调用<code>fsync()</code>函数</p></blockquote><h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>如果Redis一直持续的执行写命令，那么总有时候AOF文件的大小会超过阈值导致磁盘溢出，因此Redis提供了一个AOF重写机制，当大小超过用户设置的阈值的时候，就会执行重写，压缩AOF文件</p><blockquote><p>当AOF文件大小大于<strong>64M</strong>的时候，执行重写机制就会通过后台线程执行，底层是通过fork子进程来实现的：</p><p>fork的子进程最先是和父进程共享内存，但是只是<strong>只读模式</strong>，一旦有一方进行写操作，内存就会发生<strong>写时复制</strong>，二者独立内存</p><p>要注意的是：写时复制<strong>操作的只是发生异常的页</strong>，而不是整个内存全部复制</p></blockquote><p>因此，如果主进程接收到写命令，那么就会发生内存复制，出现数据不一致的情况，该怎么解决呢？</p><ul><li>Redis又提供了一个<strong>AOF重写缓冲区</strong>，在AOF执行重写的时候，主进程出了执行写命令和写到AOF缓冲区以外，还会写入AOF重写缓冲区</li><li>当子进程重写结束后，<strong>主进程</strong>会将AOF重写缓冲区的内容写到新的AOF文件，然后对原AOF文件覆盖</li></ul><p><strong>AOF后台重写发生阻塞的地方</strong>：写时复制、AOF重写缓冲区写入</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB（Redis DataBase）快照用于保存某一瞬间Redis内存的完整状态，因此相比于AOF：</p><ul><li><strong>RDB恢复时间更快</strong>，直接读入内存而不是一条条指令的执行</li><li>但是由于需要保存内存的完整内容，因此<strong>耗费资源更多</strong></li></ul><p>RDB快照生成有两种方式：save和bgsave，其中后者是fork一个子进程进行保存。那么既然涉及子线程就会涉及写时复制，在RDB的bgsave中我们要注意的是：</p><blockquote><ul><li>写时复制保证了快照保存的是执行bgsave指令那一刻的内存快照，因为一旦主线程修改了某个key，那么其涉及的物理页就会发生写时复制，fork的子进程仍然会保存旧key的值</li><li>极端情况就是所有物理页都被修改，那么就会复制所有物理页导致redis占用内存为<strong>原本的两倍</strong>，发生内存溢出</li></ul></blockquote><p>RDB的bgsave指令会有以下几种情况会执行：</p><ol><li>用户配置的，多少秒内修改多少次就会自动执行bgsave</li><li>redis关闭的时候，会自动bgsave以下</li><li>主动在客户端执行</li></ol><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>RDB优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>因此，Redis4.0推出了混合持久化：</p><ul><li>在AOF重写日志的时候，fork一个子进程，先保存当前内存的RDB快照到AOF文件中</li><li>同时，主线程修改的数据会被记录在AOF重写缓冲区中</li><li>RDB快照保存到AOF文件后，就会将AOF重写缓冲区的内容追加到AOF文件的RDB快照后面</li><li>最后，<strong>AOF重写后的文件前一半是RDB快照，后一半是AOF日志</strong></li></ul><h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><h3 id="Redis底层的key和value是怎么存储的？"><a href="#Redis底层的key和value是怎么存储的？" class="headerlink" title="Redis底层的key和value是怎么存储的？"></a>Redis底层的key和value是怎么存储的？</h3><ul><li>Redis的value和eky都被Redis统一包装为了redisObject类型，其中key的ptr是SDS</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<span class="hljs-comment">//对象类型（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<span class="hljs-comment">//编码（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<span class="hljs-comment">//记录对象最后一次被应用程序访问的时间（24位=3字节）</span><br>    <span class="hljs-type">int</span> refcount;<span class="hljs-comment">//引用计数。等于0时表示可以被垃圾回收（32位=4字节）</span><br>    <span class="hljs-type">void</span> *ptr;<span class="hljs-comment">//指向底层实际的数据存储结构(8字节)</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280040314.png" alt="img" style="zoom: 50%;" /><ul><li>二者被封装为dictEntry，作为hash表中的对象</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key;<span class="hljs-comment">//指向key，即sds</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<span class="hljs-comment">//指向value</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个key-value键值对(拉链法解决哈希冲突)</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280038734.png" alt="img" style="zoom: 33%;" /><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>这是Redis最基本的key-value结构，这里的String类型不仅仅是字符串，也可以是数字（整数、浮点数），也可以是二进制字节，它的大小最大可以达到<strong>512M</strong></p><p>Redis底层的String是自己设计的：<strong>简单动态字符串SDS</strong>（Simple dynamic string），Redis3.2以前如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>&#123;</span><br>  <span class="hljs-type">int</span> len;<span class="hljs-comment">//记录buf数组已使用的长度，即SDS的长度(不包含末尾的&#x27;\0&#x27;)</span><br>  <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<span class="hljs-comment">//记录buf数组中未使用的长度</span><br>  <span class="hljs-type">char</span> buf[];<span class="hljs-comment">//字节数组，用来保存字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在redisObject中，SDS字符串对应的type就是<code>REDIS_STRING</code>，而encoding编码方式有三种：</p><ul><li><ul><li>int编码（OBJ_ENCODING_INT）：当存储的字符串是整型，并且可以用long表示，redisObject中的联合体的<strong>value指针直接从void*变为unit_64</strong></li></ul></li><li>embstr编码（OBJ_ENCODING_EMBSTR）：当当字符串对象中存储的是字符串，且长度小于 44 （Redis3.2版本之前是 39）时，Redis会选择使用embstr编码来存储。这时候，redisObject和SDS的内存是连续的</li></ul><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280017411.png" alt="img"></p><ul><li>raw编码（OBJ_ENCODING_RAW）：当字符串对象中存储的是字符串，且长度大于embstr编码规定的长度，那就会采取raw编码进行存储。此时，ptr指针指向SDS的内存地址</li></ul><blockquote><p>embstr编码</p><ul><li>embstr由于是和redisObject连续存储的，因此申请和释放内存的时候只需要进行一次操作</li><li>但是embstr是只读的，一旦使用append改写，即使没有超出embstr长度限制，也<strong>会升级为raw且不会回退</strong>（int的append同理，int编码append后，就没法进行incr这种操作了）</li><li>由于redisObject被规定为大小不能大于64字节，而其本身的固定长度就是16字节，那么除去SDS的额外长度剩下的就是embstr的最大存储字符长度了：<ul><li>Redis3.2之前，由于有一个flag和一个len都是int，因此是8字节，然后字符串还有个’\0’，所以是<strong>64-16-8-1&#x3D;39字节</strong></li><li>而Redis3.2之后，对于64字节的字符串做了优化，变成了sdshdr8类型，这个类型的额外字段长度为1+1+1&#x3D;3字节的长度，除去’\0’，那么最后为<strong>64-16-3-1&#x3D;44字节</strong></li></ul></li></ul></blockquote><p>Redis3.2对于不同长度的SDS，有不同定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^5=32B</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-comment">//实际存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^8=256B</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-comment">//除去头跟空终止符分配的空间</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">//标识字符，3位用于类型，5位未使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-comment">//使用存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^16=64KB</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^32=4GB</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^64，但redis规定string长度小于512M，故没用过</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果调用redis的append函数导致sds超出分配的buf大小即alloc大小，那么就会<strong>扩容</strong>：</p><ul><li>如果大小小于1MB，那么翻倍扩容</li><li>如果大于1MB，那么递增1MB的方式扩容</li><li><strong>如果发现sds的类型对应的大小超过了</strong>，那么就会重新申请空间，并释放掉原有的sds空间</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List类型的底层数据结构是由list或ziplist实现的，而redis3.2后就用quicklist实现了</p><ul><li>如果列表的元素个数小于 512 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 64字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>在Redis3.2版本之后，List数据类型底层数据结构就<strong>只由quicklist实现了</strong></p><ol><li><strong>list数据结构</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">//前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">//后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">//节点的值</span><br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>Redis中的listNode就是正常定义的，但是redisObject中的ptr指向的是重新包装后的list对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-comment">//链表头节点</span><br>    listNode *head;<br>    <span class="hljs-comment">//链表尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">//节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值释放函数</span><br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值比较函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">//链表节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280101820.png" alt="img" style="zoom: 33%;" /><ol start="2"><li><strong>ziplist数据结构</strong></li></ol><p>list无法很好的利用cpu缓存并且额外数据太多，因此redis设计了一个内存紧凑型的数据结构——<strong>压缩链表</strong>：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280104063.png" alt="img" style="zoom:50%;" /><ul><li><strong>zlbytes</strong>：记录整个压缩列表占用对内存字节数</li><li><strong>zltail</strong>：记录末尾节点距离起始地址多少字节，也就是列表尾的偏移量</li><li><strong>zllen</strong>：记录压缩列表包含的节点数量</li><li><strong>zlend</strong>：标记压缩列表的结束点，固定值 0xFF</li></ul><p>压缩列表节点包含三部分内容：</p><ul><li><strong>prevlen</strong>：记录了「前一个节点」的长度，目的是为了实现从后向前遍历<ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值</li></ul></li><li><strong>encoding</strong>：记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数</li><li><strong>data</strong>：记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定</li></ul><blockquote><p>encoding的类型有很多：1个字节的类似uint_8, unit_16这种整型，还有字符串类型（因为要额外保存字符串长度，会根据长度决定使用1字节&#x2F;2字节&#x2F;5字节的空间来保存，而整型的类型就已经决定了长度，不需要额外保存）</p></blockquote><blockquote><p><strong>连锁更新</strong></p><p>由于前一个节点的长度大于等于254，prelen就会变成5个字节，那么：</p><ul><li>如果当前所有节点长度全是250-253之间，这时候在头部插入一个长度为255的字节的listNode</li><li>那原本的一个节点的prelen就会变成5字节导致自己的长度也超过255</li><li>那么原本第二个节点的prelen也会变为5字节，以此类推<strong>最后全量更新扩容</strong></li></ul></blockquote><ol start="3"><li><strong>quicklist数据结构</strong></li></ol><p>quicklist就是<strong>双向链表+压缩链表</strong>，其底层就是一个双向链表，然后listNode的data是一个压缩链表</p><blockquote><p>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能</p></blockquote><ul><li>和list一样，先定义链表节点quicklistNode</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>     <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-comment">//下一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">//后一个quicklistNode</span><br>    <span class="hljs-comment">//quicklistNode指向的压缩列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;              <br>    <span class="hljs-comment">//压缩列表的的字节大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;                <br>    <span class="hljs-comment">//压缩列表的元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;        <span class="hljs-comment">//ziplist中的元素个数 </span><br>    ....<br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><ul><li>再用quicklist封装至redisObject</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    <span class="hljs-comment">//quicklist的链表头</span><br>    quicklistNode *head;      <span class="hljs-comment">//quicklist的链表头</span><br>    <span class="hljs-comment">//quicklist的链表尾</span><br>    quicklistNode *tail; <br>    <span class="hljs-comment">//所有压缩列表中的总元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;<br>    <span class="hljs-comment">//quicklistNodes的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;       <br>    ...<br>&#125; quicklist;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280117106.png" alt="img" style="zoom:50%;" /><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的，Redis7.0以后<strong>压缩链表被listpack代替</strong>：</p><ul><li>如果列表的元素个数小于512个（默认值，可由<code>list-max-ziplist-entries</code>配置），列表每个元素的值都小于64字节（默认值，可由<code>list-max-ziplist-value</code>配置），Redis会使用<strong>压缩列表</strong>作为List类型的底层数据结构</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>哈希表</strong>作为Hash类型的底层数据结构</li></ul><p>压缩列表前面已经说过了，接下来我们来看一看hash和listpack</p><ol><li><strong>Hash数据结构</strong></li></ol><p>Redis的哈希表结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">//哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">//哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;  <br>    <span class="hljs-comment">//哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-comment">//该哈希表已有的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303665.png" alt="img" style="zoom:33%;" /><p>可以看出，Redis处理哈希冲突的方法是拉链法，但是Redis中的hash表是如何扩容的呢？</p><p>Redis对hash表的dictht又再次封装了一层，用于<strong>解决rehash问题</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    …<br>    <span class="hljs-comment">//两个Hash表，交替使用，用于rehash操作</span><br>    dictht ht[<span class="hljs-number">2</span>]; <br>    …<br>&#125; dict;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302097.png" alt="img" style="zoom: 33%;" /><ul><li><p>Redis定义了两个dictht，用于扩容的时候一个提供使用，一个用于扩容</p></li><li><p>一般情况下，Redis只会使用ht[0]，只要发生rehash的时候，才会使用ht[1]</p></li><li><p>当达到rehash条件的时候，就会开始rehash，由于防止哈希表数据过多，导致阻塞主线程时间过长，因此数据迁移并不是一次完成，而是使用一个渐进hash的策略：</p><ul><li>给ht[1]分配空间，一般会比ht[0]大一倍</li><li>在rehash期间，新增操作全部在ht[1]中完成</li><li>对于查找、删除、更新操作，先去ht[0]中找找到就直接对ht[0]操作，没找到再对ht[1]操作</li></ul><blockquote><p>上述两个操作，可以保证ht[0]的数据只会一直减少，不会增加</p></blockquote><ul><li>每次对该hash表操作时，就会按顺序从ht[0]中迁移一部分数据到ht[1]中，最终一定会迁移完毕</li></ul></li></ul><ol start="2"><li>listpack数据结构</li></ol><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303192.png" alt="img" style="zoom: 33%;" /><p>相比于ziplist，listpack的每个entry不再存储前一个node的长度，而是指存储自己的长度</p><p>这样，当插入节点的时候，不会引起其他节点的长度变化，从而<strong>解决了连锁更新的问题</strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于512（默认值，set-maxintset-entries配置）个，Redis会使用<strong>整数集合</strong>作为Set类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则Redis使用<strong>哈希表</strong>作为Set类型的底层数据结构</li></ul><h3 id="Zset——跳表skipList"><a href="#Zset——跳表skipList" class="headerlink" title="Zset——跳表skipList"></a>Zset——跳表skipList</h3><p>在Zset中，底层一个实现就是跳表和哈希表，但是哈希表仅仅只是用来以O(1)的复杂度查询元素的分数，底层的范围查询啥的还是通过skipList实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><ol><li><strong>跳表结构设计</strong></li></ol><p>跳表是在链表基础上改进过来的，实现了一种多层的有序链表，每一层在链表上的跨度不一样，并且还提供了查找前驱节点的能力</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302552.png" alt="img" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">//Zset 对象的元素值</span><br>    sds ele;<br>    <span class="hljs-comment">//元素权重值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">//后向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">//节点的level数组，保存每层上的前向指针和跨度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>跳表节点查询过程</strong></li></ol><p>当查询一个节点的时候，会先从头节点的最高层开始查，有两个判断条件：</p><ul><li>如果下一个节点的next的权重比指定权重小，那么直接进入下一个节点</li><li>如果下一个节点的next的权重和指定权重一样，但是元素小于下一个节点的元素，那么也进入下一个节点</li></ul><p>最终，如果上述两个条件都不满足，那就往下一层继续判断（也是一种贪心法吧，尽可能跨度大点）</p><ol start="3"><li><p><strong>Redis往跳表插入节点</strong></p><ol><li><p>插入节点的level应该设置为多大</p><p>Redis在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25，那么层数就增加 1 层，然后继续生成一个随机数，直到随机数大于0.25结束，最终确定该节点的层数</p><p>但是，Redis规定最大层数不能超过32，也就说<strong>zskiplist的头节点的高度直接设置为32</strong></p></li><li><p>如何插入</p><p>就是单纯的链表插入，只需要根据权重找到应该插入的位置，往前修改每个跨度的节点的指针，在往后指向每个跨度的节点</p></li></ol></li><li><p>为什么Redis不用树，而是用跳表</p></li></ol><ul><li>B+树属于磁盘友好型，对于redis来说并不实用，而且会<strong>多很多插入删除的额外操作</strong></li><li>树结构最起码需要两个指针（左右子树），但是跳表用redis的概率方法，平均下来只有1.33个指针，<strong>更节省空间</strong></li></ul><h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><p>Redis高可用就是通过集群实现的</p><p>Redis集群有三种方式，分别是：<strong>主从复制、哨兵模式、切片集群</strong>，下面一个一个来说</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282307680.png" alt="图片" style="zoom: 50%;" /><p>在Redis主从集群之间，是读写分离的，数据修改只会在主服务器上进行，但是二者如何实现数据一致性的呢？</p><ol><li><strong>第一次全量同步</strong></li></ol><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282323846.png" alt="图片" style="zoom:50%;" /><p>第一次全量同步分为三步：</p><ul><li><p>当执行了replicaof指令后，slave就会给master发送psync指令</p><p>master收到后，就会把自己的runID和当前同步进度offset发给salve，并告诉slave进行全量同步</p></li></ul><blockquote><p>psync有两个参数分别是主服务器的runID和同步进度offset。</p><p>由于是第一次同步，因此第一次psync指令的参数是？-1，因此发送的psync指令为<code>psync ? -1</code></p></blockquote><ul><li><p>master在把自己的runID和offset发给salve后，就会执行bgsave指令生成RDB快照，然后发送给slave</p><p>slave收到后，就会清空内存读取RDB，接着就会给master回复一个ACK</p><p>但是，master在bgsave的时候也会写数据，这个时候就会用一个replication_buffer缓冲区来存储bgsave时执行的命令</p></li><li><p>当slave读取完RDB给master回复一个ACK后，master就会将replication_buffer的内容发给slave同步新的写入数据</p></li></ul><blockquote><p>master会为每个slave建立一个replication_buffer，一旦<strong>缓冲区溢出就会强制终止全量同步</strong></p></blockquote><ol start="2"><li><strong>命令传播</strong></li></ol><p>完成第一次全量同步后，master就会和slave建立一个TCP连接</p><p>后续有写指令，master就会将该指令传给slave异步执行，同时slave会更新自己的offset</p><ol start="3"><li><strong>增量同步</strong></li></ol><p>由于命令传播依靠的是TCP连接，那如果TCP连接断开会怎么办？</p><p>连接恢复后，slave就会调用psync runID offset，只不过这里的runID和offset就有值了</p><p>master收到后，就会根据offset和自己的offset查看，环形缓冲区repl_backlog_buffer是否被覆盖，如果被覆盖就告知slave全量同步，还没有被覆盖就执行增量同步</p><p>增量同步就会把slave发送的offset到目前master记录的offset之间的指令全部写到replication_buffer中，然后发送给slave</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282359203.png" alt="图片" style="zoom:50%;" /><ol start="4"><li>集群脑裂问题</li></ol><p>当主从结构中，如果原master和集群失联，但是和客户端仍然保持联系，那么：</p><ul><li>客户端仍然将数据写入旧master</li><li>哨兵发现旧master失联，因此选出新的master</li></ul><p>当旧master重新连接，哨兵会通知旧master有新的master，这样旧master会执行全量同步清空旧数据，导致客户端写入的数据丢失</p><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>如果主从集群中的master挂了，那么如何自动化的实现发现并进行主从切换？这就是哨兵集群的功能了！</p><p>哨兵节点主要负责的就是三个事儿：监控节点状态、选择新的主节点、通知客户端和从节点 master发生变更</p><ol><li><strong>如何监控状态</strong></li></ol><p>每个哨兵节点每隔一秒就会给所有节点发送ping命令，节点收到后就会返回一个pong，一旦超过时间阈值没有返回pong命令，该哨兵节点就会认为这个节点<strong>主观下线</strong></p><p>如果有一个哨兵节点认为主节点主观下线了，那么就会发起投票，看看其他哨兵节点怎么认为的，超过用户配置的个数阈值，就会认为该主节点客观下线，就要开始进行故障转移</p><blockquote><p>注意的是，任何节点只要认为master主观下线了都会发起投票，一旦超过阈值就会认为master客观下线</p></blockquote><ol start="2"><li><strong>故障转移</strong></li></ol><p>故障转移分为两步，分别是选出主导这次故障转移的leader以及选择新的主节点</p><ul><li><p>选leader</p><p>每个认为客观下线的哨兵节点都会作为leader的候选者，然后开始投票</p><p>其中在选leader的时候，每个哨兵只有一次投票机会，哪个候选者先来请求就先投给谁，而且<strong>候选leader自己的一票会投给自己</strong></p><p>最终超过半数投票（故哨兵数量应为<strong>奇数</strong>）并且超过配置阈值才会被认为是leader，开始主导本次故障转移</p></li><li><p>选新的master</p><p>选择新的master会先过滤掉网络状况不好的节点（主从断连次数超过10次），然后有三轮排序：</p><ol><li>根据设置的优先级排序，人为设置，可根据服务器配置进行设置</li><li>如果优先级一样，就根据同步的offset排序</li><li>offset一样，根据自己的runID排序</li></ol></li></ul><ol start="3"><li><strong>通知变更</strong></li></ol><p>master的变更需要通知三个：</p><ul><li>给其他从节点发送slaveOf命令，通知新的主节点</li><li>给客户端发送指令，通知新的master的IP和端口</li><li>监视旧主节点，一旦旧的主节点上线，发送slaveOf指令</li></ul><h3 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h3><p>随着系统的不断壮大以及并发量的提升，Redis会面以下几个问题：</p><ul><li>缓存的数据量太大</li><li>并发量太大</li></ul><p>这里要注意的是，虽然读并发可以通过哨兵以及主从来实现，但是写并发怎么解决呢？</p><p>切片集群模式油然而生，解决了写并发以及缓存不足的问题</p><p>其主要思想就是将数据平均的分到多个redis节点，这些节点各自都会有自己的slave，保证了高可用还提供了写并发以及大缓存</p><p>并且每个master节点都是一个哨兵，互相监控着对方的可用性，如果发现有master客观下线，就要从它的slave中选择一个数据最完整的作为新的master，如果这个master没有slave，那集群无法对外提供服务了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407122024812.png" alt="image-20240712202423692" style="zoom: 40%;" /><p>一般来说一个切片集群需要有三个master（哨兵个数为奇数），每个master需要至少一个slave</p><p>当有新节点加入集群的时候，就会重新分配hash槽，那么就会涉及两个问题：</p><ul><li><p><strong>hash槽为什么是16384个</strong>。计算给定key的方法是，先生成16为的CRCC校验码，然后对hash槽个数16384取模</p><p>那为什么hash槽个数不是$2^{16}&#x3D;65536$，而是$2^{14}&#x3D;16384$个呢？因为redis集群的master个数不会太大，因此16384足矣，并且盲目的增加槽的个数，只会增加节点之间通信的代价</p></li><li><p><strong>在调整hash槽分配的时候，如果有请求过来怎么办</strong>？</p><p>如果发现当前槽还在原始节点，还没迁移过去，那就直接访问</p><p>如果该槽正在迁移中，则返回一个ASK重定向指令，让其重定向到转移的目标节点；但是在向目标节点发送请求之前，会先向其发送一个ASKING指令，然后再发送请求，如果目标节点有该key则返回，否则返回null</p><p>如果该槽已经迁移完成，那就可以认为是访问到了其他节点，正常的返回MOVE指令，然后去目标节点找</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407122045696.png" alt="img" style="zoom:40%;" /></li></ul><p>最后一个问题，<strong>Redis Cluster在发现故障的时候如何实现故障转移的</strong>：</p><ul><li><p>首先要知道的是，切片集群中不管什么节点只要是个节点就会互相ping&#x2F;pong，每次ping的节点是随机从自己的clusterState.nodes中选5个节点，然后选择<strong>最长时间没有ping过自己的节点去ping</strong></p><blockquote><p>clusterState是一个node数组，包含自己已知的所有集群主从节点，还有自己（myself）</p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202407122110057.png" alt="在这里插入图片描述" style="zoom:50%;" /></li><li><p>如果发现ping不同，那就标记为主观下线，然后广播一条该节点主观下线的消息</p><p>当其他节点收到后，就会在clusterState.nodes中主观下线的node中的<strong>fail_reports</strong>链表中加上疑似认为的那个节点</p><p>比如A收到B认为C主观下线的消息，就会在自己的clusterState.nodes中C的<strong>fail_reports</strong>链表加上B，一旦发现链表长度超过总数的一半，那就广播客观下线的消息</p></li><li><p>当该客观下线的master底下的slave收到客观下线的消息，那就会立马向其他所有主节点广播投票给自己的消息，一旦其他主节点收到这个消息，并且还没有投票，那就投给它</p><p>当然<strong>不是所有的从节点都可以广播投票请求</strong>，每个slave在广播之前，会先看看自己和master的上次数据同步时间有没有超过阈值，超过则无法参加竞选</p><blockquote><p>那master如何确定自己有没有投过票呢？</p><p>在切片集群中，有一个配置纪元的东西，每发起一次故障转移就会+1，那么从节点发送投票请求的时候，会带上这个东西，master收到后如果发现这个配置纪元我已经投过了，那就不投了</p></blockquote></li></ul><p>​最终，那个<strong>超过半数票+1的节点就成为了新的主节点</strong>，如果没有，那就重新投票，并且配置纪元+1</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis提供了三种集群模式</p><ul><li><p><strong>主从复制</strong>：适用于数据备份和读写分离场景，配置简单，但在主节点故障时需要手动切换。</p></li><li><p><strong>哨兵模式</strong>：在主从复制的基础上实现自动故障转移，提高高可用性，适用于高可用性要求较高的场景。</p></li><li><p><strong>切片集群</strong>：通过数据分片和负载均衡实现大规模数据存储和高性能，适用于大规模数据存储和高性能要求场景，一般Cluster模式都是配备主从的（基本配置：三个分片+两个从节点）。</p></li></ul><h2 id="Redis过期删除和淘汰"><a href="#Redis过期删除和淘汰" class="headerlink" title="Redis过期删除和淘汰"></a>Redis过期删除和淘汰</h2><h3 id="Redis-主从模式中，对过期键如何处理"><a href="#Redis-主从模式中，对过期键如何处理" class="headerlink" title="Redis 主从模式中，对过期键如何处理"></a>Redis 主从模式中，对过期键如何处理</h3><p>要注意的是，<strong>slave永远不会修改自己的数据，哪怕是过期了</strong></p><p>只有当master发现key过期了，就会删除该key，并在AOF中添加一条对应的DEL指令，然后同步给slave</p><blockquote><p> master不处理读请求，如何发现key过期：过期删除策略是惰性+定时部分删除的</p></blockquote><h3 id="Redis-持久化时，对过期键如何处理"><a href="#Redis-持久化时，对过期键如何处理" class="headerlink" title="Redis 持久化时，对过期键如何处理"></a>Redis 持久化时，对过期键如何处理</h3><ol><li>RDB持久化<ul><li>RDB文件生成的时候，会对每个key检查，过期的不会写入RDB文件</li><li>RDB文件加载的时候，master会对key检查，但是slave不会</li></ul></li><li>AOF持久化<ul><li>AOF文件追加的时候，发现过期key不会删除，等待清理的时候追加一条DEL语句</li><li>AOF文件重写的时候，发现过期key，不会保存到AOF重写中去</li></ul></li></ol><h3 id="内存淘汰中LRU和LFU有什么区别"><a href="#内存淘汰中LRU和LFU有什么区别" class="headerlink" title="内存淘汰中LRU和LFU有什么区别"></a>内存淘汰中LRU和LFU有什么区别</h3><p>在redisObject中，有一个lru字段</p><p>当使用LRU算法的时候，lru就是用来记录最近访问的时间戳，等需要淘汰的时候，就删掉lru最小的</p><p>当使用LFU算法的时候，lru的高16位记录访问的时间戳，低8位记录访问次数，删除访问次数最少的，若很多一样则删掉时间戳最小的</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL总结</title>
    <link href="/2024/05/06/%E5%85%AB%E8%82%A1/2024-05-05-MySQL%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/06/%E5%85%AB%E8%82%A1/2024-05-05-MySQL%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL总结"><a href="#MySQL总结" class="headerlink" title="MySQL总结"></a>MySQL总结</h1><h2 id="MySQL中的一条记录是如何存放的"><a href="#MySQL中的一条记录是如何存放的" class="headerlink" title="MySQL中的一条记录是如何存放的"></a>MySQL中的一条记录是如何存放的</h2><p>在InnoDB存储引擎中，默认的存储格式是Compact格式，其基本结构如下：</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405051730936.png" alt="img"></p><ul><li>变长字段长度列表存放的每个元素表示的是对应的varchar字段的真实长度</li><li>NULL值列表存放的是每个没有设置为NULL字段是否为空，只需要一个bit就可以</li></ul><p>但是，我们要注意的是：这个两个列表存放的顺序是和表中DDL语句声明的字段相对的顺序是反着的。因为，这每条记录中指向下一条记录的指针指向的是记录头信息最后的位置，反着存放是为了<strong>指针往右走可以按顺序读取列的真实值，往左走可以按顺序读取列表</strong>。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405051736137.png" alt="img" style="zoom:50%;" /><h2 id="一条SQL是如何执行的"><a href="#一条SQL是如何执行的" class="headerlink" title="一条SQL是如何执行的"></a>一条SQL是如何执行的</h2><p>这里，我们默认已经对MySQL的基本组件都是有一点基础的了，一些基础名词不会做额外解释</p><p>我们将其分为两大部分，首先我们来看一看宏观部分，然后在看一看存储引擎的一些细节</p><h3 id="宏观部分"><a href="#宏观部分" class="headerlink" title="宏观部分"></a>宏观部分</h3><p>下图是MySQL的各个功能模块，主要分为三大部分：连接层，Server层，存储引擎层</p><p>其中server层更为复杂，它可以再次细分为：查询缓存、解析器、预处理器、优化器、执行器</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406252338860.png" alt="img" style="zoom:50%;" /><h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><p>连接层主要做的事就是连接，MySQL的连接是基于TCP的长连接，并且在连接的两端都是有连接池的，可以保证连接线程的服用，并且不会无限的创建线程。</p><blockquote><p>比如client端有Druid连接池，server端有MySQL自己的连接池</p></blockquote><p>此外，在连接建立后，就会校验用户的身份和密码，一旦校验成功就会缓存用户的权限和身份信息</p><p>因此，只要校验成功连接连上，不管在此期间权限怎么变化，由于已经缓存起来，<strong>本次连接均不会受到影响</strong>，只有下次连接才会受到影响</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>查询缓存其实在MySQL8.0已经被移除了，但是以前的版本还是会有的</p><p>MySQL在每次查询的时候，都会以当前SQL作为key去缓存中看看是否有，如果有的话那就直接返回；没有的话就查询，然后保存结果</p><p>而且一旦相关的表发生修改，关联的所有查询缓存都会被删掉</p><p>因此，由于这种做法十分鸡肋（比如对于经常更新的表，命中率极低；还得保证缓存一致性），因此被移除了</p><h4 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h4><p>解析器会在查询之前，解析SQL语句，我们可以认为这是一种编译</p><p>它会进行词法分析和语法分析，一旦SQL语句有语法错误，就会在这一层报错</p><p>但是，它<strong>不会校验表名、字段名是否存在</strong></p><h4 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h4><p>在解析器中不会去校验表名、字段名。真正校验的地方其实是在预处理器，预处理器会做两个事情：</p><ul><li>校验字段名、表名这些东西是否存在</li><li>将<code>select *</code>中的 * 转换为全字段列表</li></ul><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>优化器就是要为此条SQL制定一个执行计划，比如到底用哪个索引，怎么用</p><p>它会考虑<strong>CPU成本</strong>（筛选、排序）以及<strong>IO成本</strong>（从磁盘读到buffer pool），最终选择耗费最少的执行计划，交给存储引擎执行</p><p>这里有一个比较重要的概念就是<strong>覆盖索引</strong>，当交给存储引擎执行完计划后，如果发现查出来的字段是B+树节点包含的，那就直接拿出来返回出去，否则就会进行<strong>回表查询</strong></p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>存储引擎会根据优化器制定的执行计划，去磁盘中查询，具体怎么查的后面分析存储引擎的时候再说。</p><p>当存储引擎查到后，如果有索引就会使用索引查到满足使用的索引字段的条件的记录</p><p>但是，如果还有其他没有用到索引字段的条件（包括联合索引失效后，右边的索引字段），那就会向上返回给server层去做过滤</p><p>但是还一种特殊情况叫<strong>索引下推</strong>，当发现查出来的B+树节点存在需要过滤的字段并且没有用到索引（索引失效），那就会在<strong>引擎层做过滤</strong>，然后将结果返回给server层</p><blockquote><p>这里一定要区别于覆盖索引：</p><ul><li>索引下推是在引擎层做的，而覆盖索引是在server层做的</li><li>索引下推是在筛选的时候做的，而覆盖索引是在获取select字段时候做的</li><li>但是二者如果不使用，<strong>都有可能会造成回表操作</strong></li></ul></blockquote><h3 id="存储引擎是如何工作的"><a href="#存储引擎是如何工作的" class="headerlink" title="存储引擎是如何工作的"></a>存储引擎是如何工作的</h3><p>和计算机的虚拟内存一样，存储引擎也有一个自己的内存，叫做Buffer Pool（具体后面会介绍）</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406252339903.png" alt="img" style="zoom:50%;" /><p>当需要查询的时候，MySQL不会直接在磁盘上查询，而是也是会从磁盘读一个页到buffer pool中来查询，如果发现buffer pool中没有，那就会先读取然后再去buffer pool里面查</p><p>如果是一个修改操作，那就会在读到buffer pool的时候保存一份数据到undo log</p><p>然后更新数据并写入redo log buffer中</p><p>提交事务后，就会将redo log buffer写到page cache，写入binlog 然后在redo log置为commit状态（这就是两阶段提交）</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>按<strong>数据结构</strong>分：B+树索引，Hash索引，全文索引<ul><li>其中MySQL（InnoDB、MyISAM）中默认使用B+索引，并且也支持全文索引</li></ul></li><li>按<strong>物理存储</strong>分：聚簇索引和非聚簇索引<ul><li>InnoDB支持两种形式，其中主键索引就是聚簇索引，其他的索引都是非聚簇索引</li><li>而MyISAM中只有非聚簇索引，数据会存在单独的空间，B+数节点存放索引字段和数据指针</li></ul></li><li>按<strong>字段特性</strong>分：主键索引（primary key）、唯一索引（unique）、普通索引（index）</li><li>按<strong>字段个数</strong>分：联合索引、单列索引</li></ul><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>MySQL默认使用的是B+树索引，那为什么使用B+数，不用B树、AVL、红黑树？</p><p>首先，我们从数据页的角度来看</p><h4 id="从数据页角度看"><a href="#从数据页角度看" class="headerlink" title="从数据页角度看"></a><strong>从数据页角度看</strong></h4><p>数据库IO的基本单位是页，就是Buffer Pool每次读进来的东西，而InnoDB数据页的默认大小是16KB</p><p>其中一个数据页分为7个部分：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406252339941.png" alt="img" style="zoom:50%;" /><p>我们主要关注一下<strong>最大、最小记录</strong>，这个指向的是B+树节点的头尾记录，其实可以认为是头尾指针，不包含数据，真正的每个记录存放在用户记录中。因此，我们可以得出B+树的组织结构：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406252339107.png" alt="img" style="zoom:67%;" /><p>看了B+数的组织形式后，我们也可以脑补一下B树的组织形式，其实基本差不多，只不过非叶子节点存放的不仅仅只有指针，还有数据</p><p>那么这么想一想，当InnoDB数据页固定的情况下，对于一个节点来说，B+树分的叉肯定会比B树多</p><p>因此相比于B树来说，<strong>B+树会更矮胖，并且磁盘IO次数也更少</strong></p><blockquote><p>一般来说B+树大概只有2-4层</p></blockquote><h4 id="具体性能差异"><a href="#具体性能差异" class="headerlink" title="具体性能差异"></a><strong>具体性能差异</strong></h4><p>从数据页来看B+树比B层更少，并且IO次数更少。当然，在性能上也会有差异</p><ul><li><p><strong>等值查询</strong>：</p><ul><li>B树的等值查询，最快可以达到O(1)的复杂度，但是最慢还是会查到叶子节点O(m)的复杂度（m为B树高度）</li><li>而B+树更为稳定，永远会查到叶子节点，因此查询速度为O(m)，而且<strong>B+树的m要比B树小</strong></li></ul></li><li><p><strong>范围查询</strong></p><p>B+树叶子节点拥有链表结构，因此范围查询只需要确定起始节点，然后顺序查找就好，性能更优</p></li><li><p><strong>更新操作</strong></p><p>更新的时候，一般来说B+树只需要改变叶子节点的链表结构，但是B树往往会发生较大树形态的改变</p></li></ul><p>综上所述，<strong>B+树完胜B树</strong></p><h4 id="MySQL的单表限制"><a href="#MySQL的单表限制" class="headerlink" title="MySQL的单表限制"></a><strong>MySQL的单表限制</strong></h4><p>由于InnoDB默认的数据页大小为16KB，而且一个数据页的额外字段大约会占据1KB</p><p>因此真正能存储的部分大约只有15KB，假设主键类型为bigint，并且下个节点的页号为4位</p><p>那么非叶子节点的索引部分，一个记录占12byte，也就是说一个数据页可以存放$\frac{15*1024}{12}&#x3D;1280$个记录</p><p>而对于叶子节点，由于使用聚簇索引存放所有数据，因此假设一条记录为1K，那么一个数据页可以存15个</p><p>因此我们可以计算：</p><ul><li>当B+树为两层时，记录有$1280 \times 15&#x3D;19200$</li><li>当B+树为三层时，记录有$1280 \times 1280 \times 15&#x3D;24576000$（2000w左右）</li></ul><p>因此，<strong>当MySQL的一张表超过2000W，一般就会导致B+树变成4层，那么查询效率会陡然上升</strong>！</p><h3 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h3><h4 id="索引不是越多越好"><a href="#索引不是越多越好" class="headerlink" title="索引不是越多越好"></a><strong>索引不是越多越好</strong></h4><p>索引是用来做查询的，并且是快速定位要查询的记录，因此下面几种情况其实没有必要加索引：</p><ol><li>对于频繁更新的字段，比如库存这种的就没有必要加索引，会带来更新时的额外开销</li><li>对于基本不会用于where、group by、order by的字段也没有必要加</li><li>对于大量重复数据的字段，比如性别，这种对半分的字段其实查询一次也跟全表差不多</li><li>表数据不多的时候，比如只是一些配置信息，那就没有必要加索引</li></ol><h4 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a><strong>使用索引</strong></h4><ol><li>尽量覆盖索引，避免回表查询</li><li>主键最好自增，这样可以保证每次插入都是链表的追加操作，尽量减少树形态的复杂变化</li><li>索引最好为非NULL</li><li>避免索引失效</li></ol><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a><strong>索引失效</strong></h4><p>那既然说到索引失效，就来讲讲索引失效的情况吧</p><p>一些十分常见的：最左匹配、like的百分号开头、表达式就不说了</p><p>说两个不常见的：</p><ul><li><p>隐式转换</p><p>MySQL当字符串和数字比较的时候会将<strong>数字转成字符串</strong>。因此实际上隐式转换其实就是在数字前面加了个类似<code>str()</code>的函数。</p><p>那如果某个索引字段是数字，但是where的时候写成了<code>where id=&#39;aaa&#39;</code>，那么就会被解析为<code>where str(id)=&#39;aaa&#39;</code>。其实这也就是一种表达式，最终导致索引失效</p></li><li><p>where 查询的or连接</p><p>如果是or连接的话，如果or相连的表达式有一个没用到索引，那就会直接全表</p><p>因为，or是要两个条件都要搜然后取并集，既然有一个全表了，那就直接全表过滤就好了</p><p>没有必要一个用索引，一个用全表，效率会更低</p></li></ul><h3 id="count函数"><a href="#count函数" class="headerlink" title="count函数"></a>count函数</h3><p>count函数是一种聚合函数，我们分析这个其他的聚合函数可以类推</p><h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a><strong>count(1)</strong></h4><p>count(1)很简单，就是查询后返回字段全都是1，然后计算1的个数</p><p>如果是计算全表的个数，那就会InnoDB会默认用二级索引（<strong>叶子节点更小，IO次数更少</strong>），没有二级索引的时候才会用主键索引</p><h4 id="count-主键"><a href="#count-主键" class="headerlink" title="count(主键)"></a><strong>count(主键)</strong></h4><p>count(主键)相比于count(1)多了一步，因为count(1)不需要读取数据信息，但是count(主键)需要读取主键信息并判断是否为NULL，因此速度会慢一点</p><p>同时，主键在任何索引都是存在的，因此同样会优先二级索引，其次再主键索引</p><blockquote><p>多个二级索引的时候，会选取索引字段长度和最短的那个</p></blockquote><h4 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a><strong>count(字段)</strong></h4><p>这个是最慢的，因为这个一般都是要全表扫描</p><h4 id="InnoDB为什么需要遍历计数"><a href="#InnoDB为什么需要遍历计数" class="headerlink" title="InnoDB为什么需要遍历计数"></a><strong>InnoDB为什么需要遍历计数</strong></h4><p>不同于MyISAM，当直接计算全表个数的时候，InnoDB需要遍历全表，但是MyISAM有一个字段专门维护记录个数。因此，计算全表个数的时候，InnoDB是O(n)而MyISAM是O(1)</p><p>这是因为InnoDB还需要支持事务，使用MVCC来解决并发的话就不能直接通过一个字段来决定，有的记录对于当前事务来说是不可见的，需要<strong>通过遍历来判断</strong></p><p>而当有条件的计数时候，InnoDB和MyISAM都是会遍历的</p><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>这个已经讲烂了：<strong>ACID</strong>，那么在InnoDB中ACID是如何保证的呢？</p><ul><li>Atomic：原子性是指一个事务中的所有操作，要么一起提交，要么一起回滚。这是通过<strong>undo log</strong>实现的，当事务中发生异常，就要通过undo log回滚，实现原子性</li><li>Isolation：隔离性是指多个事务之间，应该是相互隔离的，无法看到事务执行的中间状态。这是通过<strong>MVCC+锁机制</strong>实现的，快照读使用MVCC，当前读使用锁机制</li><li>Durable：持久性是指事务执行完后，结果永远保留。这是通过<strong>redo log</strong>实现的，当事务执行完后redo log就会保存操作记录，并刷盘持久化，如果事务提交后发生崩溃，导致buffer pool还没有写入磁盘，可以通过redo log恢复</li><li>Consistent：一致性是指数据的一致性，这个是通过AID来共同保证的</li></ul><p>也就是说ACID中，<strong>AID是基础，最终保证了C</strong></p><h3 id="并发事务引起的问题"><a href="#并发事务引起的问题" class="headerlink" title="并发事务引起的问题"></a>并发事务引起的问题</h3><p>MySQL提出了事务隔离级别的概念，不同的隔离级别就是为了解决不同的问题</p><p>一共有三种问题：</p><ul><li><p><strong>脏读</strong>：事务A读到了还没有提交的事务B的中间状态</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406282049066.png" alt="图片" style="zoom:50%;" /></li><li><p><strong>不可重复读</strong>：事务A中执行了两次相同的select，但是事务B在这两次select中提交了修改，导致两次select读出来的数据不一样（这里指的不一样指的是内容，而不是条数增加了）</p><blockquote><p>update、delete都是修改，delete底层是逻辑删除，会有单独线程来清理</p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406282049260.png" alt="图片" style="zoom: 50%;" /></li><li><p><strong>幻读</strong>：幻读专门指的insert导致的，他是指在两次前后查询到的数据个数不一样</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406282049728.png" alt="图片" style="zoom:50%;" /><p>这个要和不可重复读区别开，幻读是insert引起的，而不是更新操作引起的，因为这有可能会导致两次select的条数不一样</p><p>虽然delete也会，但是delete后是逻辑删除，还是可以通过MVCC来控制，具体为什么我们后面详细说说</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>既然事务并发有上面这三个问题，那MySQL肯定也解决了它们，MySQL提供了四种隔离级别：</p><p>Read Uncommitted &lt; Read Committed &lt; Repeatable Read &lt; Serializable</p><p>当然这四种隔离级别肯定也不是所有的都解决了上述问题</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406282049801.png" alt="img" style="zoom:50%;" /><p>那这些隔离界别是如何实现的呢？</p><ul><li><p>Read Uncommitted</p><p>没有任何操作，任何并发问题都有可能发生，数据库里是啥，就读啥</p></li><li><p>Read Committed</p><p>通过MVCC实现，但是会在每次读之前生成一个Read View，只解决了脏读问题</p></li><li><p>Repeatable Read，是MySQL的默认隔离级别，但是只解决了部分幻读，可重复读级别使用了两种方式来解决的：</p><ul><li><p>对于快照读，使用的是MVCC</p></li><li><p>对于当前读，使用的是间隙锁。</p><p>间隙锁其实就是范围锁，当使用<code>select for update</code>的时候，由于会直接读取最新的，为防止两次读取之间有修改操作导致结果不一样，会<strong>对这个select范围就会加上间隙锁</strong>直接不允许操作这个范围内的任何数据，如果需要在这个范围里面做update、delete、insert操作都会被阻塞，直至事务提交</p></li></ul></li><li><p>Serializable</p><p>通过读写锁实现，允许并发读，但是不允许同时读写，也不允许并发写</p></li></ul><h3 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h3><p>接下来，我们来重点讨论一下幻读，为什么Repeatable Read隔离级别只解决了部分幻读问题？</p><p><strong>幻读是指</strong>：同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行</p><h4 id="快照读避免幻读"><a href="#快照读避免幻读" class="headerlink" title="快照读避免幻读"></a>快照读避免幻读</h4><p>在Repeatable Read级别中，由于MVCC创建的读视图是不变的，因此在当前事务中，<strong>一般情况下</strong>，如果有其他事务insert、delete、update的时候都不会出现问题。</p><p>MVCC会从undo log中找到符合读视图的版本，如果是insert的话，那找到最后也没发现直接返回空</p><p>这里有两个问题：</p><ul><li><p><strong>delete的记录，为什么还能从表中找到undo log的头指针？</strong></p><p>这是因为MySQL的delete操作是逻辑删除，因此还是会找到该数据，会判断是否符合读视图还会判断是否已删除</p><p>那如果全都是逻辑删除岂不是会很耗空间？</p><p>MySQL会有一个单独线程（线程数可以设置），来删除逻辑删除的数据条目和undo log，只要确定该记录不会被用到了，比如该记录trx_id以前的事务都已经终止了，那就会删掉</p></li><li><p><strong>为什么说是一般情况？</strong></p><p>因为如果你不做update操作就永远是在读视图里面select就不会出问题，但是如果在当前事务使用delete、update、insert操作，这些操作是基于当前读实现的，那就有可能会出问题了</p><p>如果在当前事务执行修改操作之前，事务B插入了一条数据，恰巧当前事务的修改操作范围匹配上事务B插入的数据，那么本次修改操作就会<strong>在开发者不知道的情况下作用在事务B插入的数据上，并且会将该记录的trx_id修改成自己的</strong>，那么下次查询就会莫名其妙的查出来了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406282049816.png" alt="img" style="zoom: 67%;" /><p>其实不仅仅是事务B的insert操作，事务B的delete操作，如果事务Aupdate在delete之后，那就会发现update并没有生效，还是有很多种情况的</p><p>如果要解决只能通过serializable来解决，因为它不允许并发读写和并发写</p></li></ul><h4 id="当前读解决幻读"><a href="#当前读解决幻读" class="headerlink" title="当前读解决幻读"></a>当前读解决幻读</h4><p>那就是简单粗暴的使用间隙锁了，只要在当前事务中使用了select for update语句，那就会有两种情况：</p><ul><li>有其他事务正在写，那么当前事务阻塞，知道写事务提交，才会拿到结果并加上间隙锁</li><li>没有写事务，那就直接加锁并获取结果</li></ul><p>加上间隙锁后，任何对于该范围内的写操作都会被阻塞，因此当前事务所有的当前读都不会被其他写操作干扰，不会出现幻读</p><p>那么就有人问了，如果先select 在select for update呢？</p><p>那确实有可能会不一样，但原则上select和select for update是两个不同的语句，不一样可以接受</p><h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>在将MySQL日志之前，我觉得有些东西得先讲一讲，那就是缓冲区</p><p>在MySQL的日志、数据这些写入操作的时候，都不是直接写到磁盘，而是先放在一个buffer中，然后由MySQL的配置决定什么时候写到page cache，然后在通过fsync来持久化到磁盘</p><p><strong>从MySQL的角度来说，只要写到page cache其实就算持久化了</strong>，因为这个时候即使MySQL崩了也不会发生丢失，page cache是OS层面的缓存，只有OS崩了或者系统断电等情况发生，才会丢失</p><p>此外，我们还需要提醒一点：undo log的buffer是放在buffer pool中的，而redo log和binlog的buffer都是单独存在的</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301134065.png" alt="img" style="zoom:67%;" /><p>后面看日志和BufferPool的时候，我们一定要明确一点：</p><p>MySQL是基于磁盘的，<strong>如何减少磁盘IO的同时并保证数据完整性</strong>，是MySQL日志和Buffer Pool优化的地方，这里任何技术的提出都是为了达到此作用</p><h3 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h3><p>如果在事务还没有提交的时候，MySQL出现了错误或者崩溃需要回滚，那就需要靠undo log记录下执行前的数据，这样如果发生回滚就可以直接根据undo log回滚了，<strong>保证了事务的原子性</strong></p><p>此外，undo log在MVCC中也起到了十分重要的作用，通过undo log形成的链表，找到符合当前读视图的那个记录版本</p><p>要注意的是，每个undo log记录格式并不相同，它取决于执行的操作是insert、delete、update</p><p>undo log的buffer不同于redo log和binlog，它是放在buffer pool中的，被当作是数据页看待。因此undo log的修改同样也会被redo log记录下来</p><p>而redo log会每秒刷盘+事务提交刷盘，因此redo log<strong>可以保证持久性</strong></p><blockquote><p>其实在这里，我想到了一个问题：</p><p>当事务执行一半的时候，mysql崩了，此时修改的数据页脏页刷盘了，但是undolog页并没有刷盘，但是<strong>由于事务执行一半redo log也没有刷盘</strong>。这个时候数据页已经写进去了（如果没写进去，那还好，mysql恢复过来什么也没有刷盘，执行一半的事务相当于没有发生），此时事务相当于没完成需要回滚，但是undo log没了，redo log也没记录undo log的变更</p><p>那么此时，该怎么办？</p><p>其实这个时候，确实是回滚不来了的，这个问题的<strong>重点其实是我加粗的那块</strong></p><p>事务提交reo log刷盘是msyql的默认策略，本来就不能保证强一执行。我们可以修改参数，使其没执行一条指令刷一次盘，这样就可以解决上述问题了。</p></blockquote><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>Buffer Pool其实就是MySQL做的一层分页，MySQL定义的页大小是16KB，是OS的四倍（4KB）</p><p>那么既然讲到分页，那应该就能理解了，MySQL使用undo log、数据页的时候，不会只取一条改完再写回，而是一次取一页，然后LRU换出的时候被动写回</p><p>这样的话可以进一步提高速度，因为这个BufferPool是MySQL自己的缓存，不像OS的page cache是OS层面的，要和其他进程竞争页面<strong>更容易缺页</strong>。</p><h3 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h3><p>对于BufferPool来说，毕竟是基于内存的，一旦MySQL崩了或者系统断电，那么如果脏页没有写回去，那就会出现数据丢失</p><p>为了防止这种情况发生，MySQL使用redo log来保证持久性</p><p>简单来说，就是当有数据更新的时候，会先更新BufferPool中的数据页和undo log，然后将此次修改记录到redo log中，BufferPool中的数据可以异步刷盘，但是redo log数据必须刷盘</p><p>这样，即使MySQL出问题了，也可以通过redo log恢复过来。</p><p>这就是<strong>WAL技术</strong>（Write Ahead Logging），写操作不急着刷盘，而是记录日志将日志刷盘，脏页异步刷盘</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301134799.png" alt="img" style="zoom:50%;" /><h4 id="undo-log和redo-log的区别"><a href="#undo-log和redo-log的区别" class="headerlink" title="undo log和redo log的区别"></a>undo log和redo log的区别</h4><ul><li><p>undo log是用于回滚和MVCC的，记录的是数据修改之前的状态，保证事务的原子性</p></li><li><p>redo log是用于数据持久化的，记录的是数据修改了什么地方，保证事务的持久性</p></li></ul><h4 id="那为什么不直接将buffer-pool刷盘，而是非要通过redo-log来搞？"><a href="#那为什么不直接将buffer-pool刷盘，而是非要通过redo-log来搞？" class="headerlink" title="那为什么不直接将buffer pool刷盘，而是非要通过redo log来搞？"></a>那为什么不直接将buffer pool刷盘，而是非要通过redo log来搞？</h4><p>这是因为redo log是<strong>顺序写入</strong>的</p><p>就比如一个事务修改了100张表，那如果是直接写入，这100张表的数据肯定不在一个数据页上吧，那就得写回100次</p><p>但是如果是异步写回数据页，我们只需要将redo log刷盘，而redo log是顺序记录这100次表的修改的，基本就是在一个redo log页上，只需要写回一次</p><p>那当然redo log性能高了</p><p>此外，<strong>根据局部性原理</strong>，一般拿出来的数据页可能有多个线程修改，那等多个线程写完一起写回，肯定比写一次写回一次要效率高吧！</p><p>因此，总结下来有两个原因：</p><ul><li>redo log是顺序写入</li><li>buffer pool可能多个线程修改同一个页，异步写回，效率更高</li></ul><h4 id="redo-log是怎么刷盘的"><a href="#redo-log是怎么刷盘的" class="headerlink" title="redo log是怎么刷盘的"></a>redo log是怎么刷盘的</h4><p>Redo log也是有自己的buffer的，但是为了保证数据持久性，肯定不能也放在buffer pool中异步写回，因此redo log buffer独立出来，单独处理</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301134345.webp" alt="img" style="zoom:40%;" /><p>redo log的刷盘是有策略的，除了默认的<strong>一秒一次的刷盘</strong>，还有如下细节：</p><ul><li><p>首先，可以通过配置决定什么时候刷盘：不主动写回page cache；事务提交写回page cache；事务提交写回磁盘</p></li><li><p>其次，redo log是循环写，当脏页同步到磁盘，就会删掉redo log对应的内容，采用双指针</p><p>一旦发现追了一圈，那就会阻塞，直至有脏页写到磁盘空出空间，才可以继续写入</p></li></ul><h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h3><p>上述两个日志undo log和binlog都是InnoDB的日志，也就是说MyISAM是没有事务也没有崩溃恢复能力的，但是binlog是MySQL的东西，也是用来做主从同步的</p><p>binlog里面记录的是所有数据库的修改操作，包括表结构和表数据的修改，但是不包括select语句</p><p>binlog无法做崩溃恢复，只有归档能力，它和redo log还是有很大区别的：</p><ul><li><p>从用途来说：</p><p>binlog用来做归档、主从同步的；</p><p>redo log用来实现事务的持久性，做崩溃恢复的</p></li><li><p>从存储内容来说：</p><p>binlog存储的是<strong>全量的</strong>所有的表结构、表数据的修改操作语句，是修改的逻辑语句；</p><p>redo log存储的是<strong>还没有写回磁盘的脏页的物理修改记录</strong>，是修改的物理地址</p></li></ul><h4 id="为什么binlog无法崩溃恢复"><a href="#为什么binlog无法崩溃恢复" class="headerlink" title="为什么binlog无法崩溃恢复"></a>为什么binlog无法崩溃恢复</h4><p>因为binlog记录的是全量的数据，真要做恢复，就是把mysql的数据全删了，然后用binlog恢复，并且也没有做undo log的保存</p><p>而redo log则是保存的没有刷盘的脏页的数据，只需要回复一下就好了</p><h4 id="binlog的刷盘"><a href="#binlog的刷盘" class="headerlink" title="binlog的刷盘"></a>binlog的刷盘</h4><p>和redo log一样，由于需要同步刷盘，因此也不放到buffer pool中，单独开了一个binlog buffer</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>由于redo log和binlog是两个文件，如果一个刷盘了但是另一个没刷盘，那就会出现问题：</p><ul><li>如果写入binlog没有写入redolog，主库崩溃后无法恢复，但是主库会把binlog中的没恢复的数据同步给从库</li><li>如果写入redo log没有写入binlog，主库崩溃后恢复了，但是binlog中没有，无法同步给从库</li></ul><p>那么如何<strong>保证redo log和binlog的一致性</strong>呢，这就是大名鼎鼎的两阶段提交方案：</p><ul><li>事务提交的时候，会先将redo log刷盘，并将状态置为prepared</li><li>然后将binlog刷盘，刷盘成功后就会将redo log置为committed状态</li></ul><p>这个时候：</p><ul><li><p>若写入binlog失败，恢复时会发现redo log存在prepare项且binlog无对应项，则回滚并删除redo log对应记录</p></li><li><p>若置为committed失败，恢复时会发现redo log存在prepare项但binlog有对应项，则提交并将该记录置为committed</p></li></ul><p>但是两阶段提交也存在一些问题：</p><ul><li>由于一个事务提交就会触发一次两阶段提交，那么就会有两次fsync的刷盘（redo log和binlog）</li><li>并且为了保证事务并发时候顺序性，两阶段提交需要加锁，因此效率会下降</li></ul><p>在MySQL5.7以后，采用了流式操作的组提交的形式，分为了三个阶段：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406301135150.png" alt="img" style="zoom:50%;" /><ul><li>Flush阶段：对redo log刷盘并把binlog写到binlog buffer中不刷盘</li><li>Sync阶段：binlog刷盘，fsync</li><li>Commit阶段：将redo log对应记录置为commit</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里Lazada笔试第一题</title>
    <link href="/2024/04/29/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E9%A2%98/"/>
    <url>/2024/04/29/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里Lazada笔试第一题"><a href="#阿里Lazada笔试第一题" class="headerlink" title="阿里Lazada笔试第一题"></a>阿里Lazada笔试第一题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小红定义一个01串的权值为:相邻两个字符都是’1’的对儿数。例如，”110111”的权值为3。 </p><p>现在小红希望你求出所有长度为<code>n</code>的01串的权值之和。你能帮帮她吗?</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>一个正整数<code>n</code></p><p>$$<br>1\le n \le 10^9\<br>$$</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure></blockquote><h4 id="Example-02"><a href="#Example-02" class="headerlink" title="Example-02"></a>Example-02</h4><blockquote><p>Input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>首先，我们可以先求出从<code>dp[i-1]</code>到<code>dp[i]</code>的递推公式，它拥有两个部分：<ol><li>当<code>str[i]</code>为’0’时，那么所有01串的权值和为：<code>dp[i-1]</code></li><li>当<code>str[i]</code>为’1’时，那么所有01串的权值和为：<code>dp[i-1]</code> + 最后两个是‘11’的01串的个数</li></ol></li><li>那么根据上述两个部分，可以算出递推公式：</li></ul><p>$$<br>dp[i]&#x3D;dp[i-1]+dp[i-1]+2^{i-2}&#x3D;dp[i-1] \times 2+2^{i-2}<br>$$</p><ul><li>由于n的最大值为10e9，因此不能循环暴力求解，我们可以由递推公式算出直接公式：</li></ul><p>$$<br>dp[i]&#x3D;(i-1)\times2^{i-2}<br>$$</p><ul><li>再利用费马小定理（因为10e9+7是质数），可以直接得到计算公式：</li></ul><p>$$<br>dp[i]&#x3D;(i-1)\times2^{(i-2) \mod (10^9+6)}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n=in.nextInt();<br><br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">6</span>;<br>        <span class="hljs-type">long</span> res=n-<span class="hljs-number">1</span>;<br>        res=(res*(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">2</span>,(n-<span class="hljs-number">2</span>)%mod))%mod;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索二维矩阵Ⅱ</title>
    <link href="/2024/04/28/%E5%88%B7%E9%A2%98/2024-04-28/2024-04-28-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1/"/>
    <url>/2024/04/28/%E5%88%B7%E9%A2%98/2024-04-28/2024-04-28-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="搜索二维矩阵Ⅱ"><a href="#搜索二维矩阵Ⅱ" class="headerlink" title="搜索二维矩阵Ⅱ"></a>搜索二维矩阵Ⅱ</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240. 搜索二维矩阵 II</a></strong></p><h3 id="Solution-01"><a href="#Solution-01" class="headerlink" title="Solution-01"></a>Solution-01</h3><p>对每一行二分查找，同时可以做一些简单的剪枝</p><p>如：如果该行第一个数字比<code>target</code>大，那么就可以直接返回<code>false</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> [] row:matrix)&#123;<br>            <span class="hljs-keyword">if</span>(row[<span class="hljs-number">0</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> index=binarySearch(row,target);<br>            <span class="hljs-keyword">if</span>(index !=-<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-type">int</span> low=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>            <span class="hljs-type">int</span> mid=(low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> num=nums[mid];<br>            <span class="hljs-keyword">if</span>(num==target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num&gt;target)&#123;<br>                high=mid-<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                low=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Solution-02"><a href="#Solution-02" class="headerlink" title="Solution-02"></a>Solution-02</h3><p>还有一种时间复杂度为<code>O(m+n)</code>的方法——“Z字查找”：我们可以从矩阵右上角（即<code>matirx[0][m-1]</code>）开始遍历：</p><ol><li>如果当前元素小于<code>target</code>，我们就往下走</li><li>如果当前元素大于<code>target</code>，我们就往左走</li><li>如果当前元素等于<code>target</code>，直接返回<code>true</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;matrix.length&amp;&amp;j&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-04-28 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="/2024/04/28/%E5%88%B7%E9%A2%98/2024-04-28/2024-04-28-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2024/04/28/%E5%88%B7%E9%A2%98/2024-04-28/2024-04-28-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p><strong>Problem: <a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/">LCR 120. 寻找文件副本</a></strong></p><h3 id="Solution-01"><a href="#Solution-01" class="headerlink" title="Solution-01"></a>Solution-01</h3><ul><li>很简单直接用hash表记录遍历过的元素，然后再次碰到直接返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatDocument</span><span class="hljs-params">(<span class="hljs-type">int</span>[] documents)</span> &#123;<br>        Map&lt;Integer,Boolean&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:documents)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(num)==<span class="hljs-literal">null</span>)&#123;<br>                map.put(num,<span class="hljs-literal">true</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Solution-02"><a href="#Solution-02" class="headerlink" title="Solution-02"></a>Solution-02</h3><p>还有一种空间复杂度为<code>O(1)</code>的方法，由于题目中说到数字在0到n-1之间，那么其实给的这个数组就是一个天然的hashmap，因此我们可以直接在这个数组上做文章：</p><ol><li><p>我们需要遍历每个索引<code>i</code>，如果当前索引取出来的数等于<code>i</code>，那么就可以继续遍历下一个索引</p></li><li><p>如果不等于，我们就要看看：</p><ul><li><code>documents[documents[i]]==documents[i]</code>：这种情况就说明存在两个位置的数字是一样的，那么就返回<code>documents[i]</code>。</li><li><code>documents[documents[i]]!=documents[i]</code>：这种情况说明当前索引没有存在它应该存的值，我们就把<code>documents[i]</code>存的这个数放在它应该存的地方，然后把挤出来的数（原本的<code>documents[documents[i]]</code>）拿到当前索引来继续处理看看这个数应该放在哪。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatDocument</span><span class="hljs-params">(<span class="hljs-type">int</span>[] documents)</span> &#123;<br>        <span class="hljs-type">int</span> n=documents.length;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(documents[i]==i)&#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> temp=documents[i];<br>            <span class="hljs-keyword">if</span>(documents[temp]==temp)&#123;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                documents[i]=documents[temp];<br>                documents[temp]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
      <category>2024-04-28 刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里淘天笔试第三题</title>
    <link href="/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-27-%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/"/>
    <url>/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-27-%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里淘天笔试第三题"><a href="#阿里淘天笔试第三题" class="headerlink" title="阿里淘天笔试第三题"></a>阿里淘天笔试第三题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小红拿到了一个长度为”的数组。她定义一个子序列是“好的”，且仅当该子序列所有元素之和为奇数。现在小红想求出所有“好的”子序列的元素和之和。你能帮帮她吗?由于答案可能过大，请对<code>10e9+7</code>取模。定义一个数组的子序列是，数组中取若干元素(可以不连续)按原数组顺序形成的新数组。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入一个正整数<code>n</code>，代表小红拿到的数组。<br>第二行输入<code>n</code>个正整数，代表数组中的元素。<br>$$<br>1\le n\le 10^5\<br>1\le a_i \le 10^9<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>所有“好的”子序列的元素和之和，答案对<code>10e9+7</code>取模。</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li><p>dp数组含义：</p><ul><li><p><code>dp[0][i]</code>：前i个数字，和为<strong>偶数</strong>的子序列之和</p></li><li><p><code>dp[1][i]</code>：前i个数字，和为<strong>奇数</strong>的子序列之和</p></li></ul></li><li><p>count数组含义：</p><ul><li><code>count[0][i]</code>：前i个数字，和为<strong>偶数</strong>的子序列<strong>个数</strong>之和</li><li><code>count[1][i]</code>：前i个数字，和为<strong>奇数</strong>的子序列<strong>个数</strong>之和</li></ul></li><li><p>状态转移方程：</p><ul><li>当第i个数为奇数的时候：<ul><li>偶数子序列之和为：前i-1个数字的偶数子序列之和 + 带上第i个数字的前i-1个奇数子序列之和，即<code>dp[0][i] = dp[0][i - 1] + dp[1][i - 1] + count[1][i - 1] * a[i - 1]</code></li><li>奇数数子序列之和为：前i-1个数字的奇数子序列之和 + 带上第i个数字的前i-1个偶数子序列之和+它自己，即<code>dp[1][i] = dp[0][i - 1] + count[0][i - 1] * a[i - 1] + dp[1][i - 1] + a[i - 1]</code></li></ul></li><li>当第i个数为奇数的时候:<ul><li>偶数子序列之和为：前i-1个数字的偶数子序列之和 + 带上第i个数字的前i-1个偶数子序列之和+它自己，即<code>dp[0][i] = dp[0][i - 1] + count[0][i - 1] * a[i - 1] + dp[0][i - 1] + a[i - 1]</code></li><li>奇数数子序列之和为：前i-1个数字的奇数子序列之和 + 带上第i个数字的前i-1个奇数子序列之和，即<code>dp[1][i] = dp[1][i - 1] + count[1][i - 1] * a[i - 1] + dp[1][i - 1]</code></li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span> , <span class="hljs-number">3</span> , <span class="hljs-number">2</span> , <span class="hljs-number">4</span> , <span class="hljs-number">5</span> , <span class="hljs-number">6</span> , <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span>[][] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = (dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod + dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>])%mod;<br>                count[<span class="hljs-number">0</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)%mod;<br>                dp[<span class="hljs-number">1</span>][i] = (dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod + dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])%mod;<br>                count[<span class="hljs-number">1</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])%mod;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[<span class="hljs-number">0</span>][i] = (dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod)%mod;<br>                count[<span class="hljs-number">0</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])%mod;<br>                dp[<span class="hljs-number">1</span>][i] = (dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod + dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>])%mod;<br>                count[<span class="hljs-number">1</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)%mod;<br>            &#125;<br>        &#125;<br>        System.out.println(dp[<span class="hljs-number">1</span>][n]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团笔试第三题</title>
    <link href="/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/"/>
    <url>/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团笔试第三题"><a href="#美团笔试第三题" class="headerlink" title="美团笔试第三题"></a>美团笔试第三题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小美拿到了一个数组，她每次操作可以将两个相邻元素<code>a[i]</code>合并为个元素，合并后的元素为原来两个元素之和。小美希望最终数组的最小值不小于<code>k</code>。她想知道有多少种不同的合并结果?</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入两个正整数<code>n,k</code>，代表数组大小和数组的最大值。</p><p>第二行输入<code>n</code>个正整数<code>a[i]</code>，代表小美拿到的数组。</p><p>$$<br>1 \le n, k, a_i \le 200<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>输出一个整数，代表小美可以得到多少种不同的结果。由于结果可能很大，输出对<code>10e9+7</code>取模的结果。</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li><p>dp数组含义：</p><ul><li><code>dp[i][j]</code>：从<code>i</code>到<code>j</code>的合并方式数量</li></ul></li><li><p>状态转移方程：</p><ul><li><p>选取一个<code>h</code>但是，这是一个在<code>i</code>和<code>j</code>之间的量，代表合并<code>h</code>到<code>j</code>的所有数字，如果这个数字大于<code>k</code>那么就会多出<code>dp[i][h-1]</code>种方式出来。（这相当于固定<code>h</code>到<code>j</code>，前面<code>i</code>到<code>h-1</code>可以随便合并）</p></li><li><p>那么我们就可以得到状态转移方程：<br>$$<br>dp[i][j]&#x3D;\sum^{h&#x3D;i}_{i\le h\le j}dp[i][h-1]<br>$$</p></li><li><p>但是这里比较重要的是初始化：</p><ul><li>首先，对于<code>dp[i][i]</code>来说，就是单独一个数字，如果<code>a[i]</code>比<code>k</code>大那么<code>dp[i][i]=1</code>，否则<code>dp[i][i]=0</code></li><li>其次，对于<code>dp[i][0]</code>，我们令其为<code>1</code>（这其实相当于从头加到尾了，如果满足sum&gt;k的条件，那么就应该+1）</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-type">int</span> n=in.nextInt();<br>            <span class="hljs-type">int</span> k=in.nextInt();<br>            <span class="hljs-type">int</span> [] a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                a[i]=in.nextInt();<br>            &#125;<br>            <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br><br>            <span class="hljs-type">long</span> [][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span> [n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>                dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(a[i-<span class="hljs-number">1</span>]&gt;k)&#123;<br>                    dp[i][i]=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n+<span class="hljs-number">1</span>;j++)&#123;<br>                    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=j;h&gt;=i;h--)&#123;<br>                        sum+=a[h-<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(sum&gt;=k)&#123;<br>                            dp[i][j]=(dp[i][j]+dp[i][h-<span class="hljs-number">1</span>])%mod;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            System.out.println(dp[<span class="hljs-number">1</span>][n]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团笔试第四题</title>
    <link href="/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E5%9B%9B%E9%A2%98/"/>
    <url>/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E5%9B%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团笔试第四题"><a href="#美团笔试第四题" class="headerlink" title="美团笔试第四题"></a>美团笔试第四题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小美拿到了一棵树，其中有一些节点被染成红色。小美定义一个红色连通块的权值为:所有节点编号乘积的因子数量。<br>小美想知道，所有红色连通块的权值之和是多少?由于答案过大，请对<code>10e9+7</code>取模。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入一个正整数<code>n</code>，代表节点数量。</p><p>第二行输入一个长度为<code>n</code>的，仅由’R’和’W’组成的字符串，第<code>i</code>个字符为’R’代表<code>i</code>号节点被染成红色，’W’代表未被染色。保证至少有一个节点被染成红色。<br>接下来的<code>n - 1</code>行，每行输入2个正整数<code>u</code>，<code>v</code>，代表<code>u</code>号节点和<code>v</code>号节点有一条边连接。<br>$$<br>1 \le n \le 10^5\<br>1 \le u,v \le n<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>一个整数，代表所有红色连通块的权值之和。</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">WRR</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li>这题其实就是要找连通分量，我们可以在输入的时候就做预处理：<strong>只保留红色节点和红色节点相邻的边，其余的边一律不保留</strong></li><li>然后就可以直接dfs或者bfs遍历每个连通分量了，我们只需要在遍历的时候记录这个节点visit过，防止重复遍历就好</li><li>最后直接计算因子个数</li></ol><blockquote><p>但是我觉得这样会超时，当时现场没有时间写，不知道这种解法对不对</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> []visit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, List&lt;Integer&gt;&gt; graph;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n=in.nextInt();<br>        in.nextLine();<br>        String str=in.nextLine();<br><br>        graph=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] isRed=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        visit=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            isRed[i+<span class="hljs-number">1</span>]= str.charAt(i) != <span class="hljs-string">&#x27;W&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> u=in.nextInt();<br>            <span class="hljs-type">int</span> v=in.nextInt();<br>            <span class="hljs-keyword">if</span>(isRed[u]&amp;&amp;isRed[v])&#123;<br>                List&lt;Integer&gt; uNeighbor = graph.getOrDefault(u , <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                uNeighbor.add(v);<br>                graph.put(u,uNeighbor);<br><br>                List&lt;Integer&gt; vNeighbor = graph.getOrDefault(v , <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                vNeighbor.add(u);<br>                graph.put(v,vNeighbor);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visit[i]&amp;&amp;isRed[i]) &#123;<br>                visit[i] = <span class="hljs-literal">true</span>;<br>                res=(res+get_sum(dfs(i)))%mod;<br>            &#125;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        List&lt;Integer&gt; neighbors = graph.getOrDefault(node , <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">long</span> ans=node;<br>        <span class="hljs-keyword">for</span>(Integer neighbor:neighbors)&#123;<br>            <span class="hljs-keyword">if</span>(visit[neighbor])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            visit[neighbor]=<span class="hljs-literal">true</span>;<br>            ans*=dfs(neighbor);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_sum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)tot++;<br>        <span class="hljs-keyword">return</span> tot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里Lazada笔试第二题</title>
    <link href="/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98/"/>
    <url>/2024/04/27/%E7%AC%94%E8%AF%95%E9%A2%98/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里Lazada笔试第二题"><a href="#阿里Lazada笔试第二题" class="headerlink" title="阿里Lazada笔试第二题"></a>阿里Lazada笔试第二题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小红拿到了一个数字串，她想取一个长度为<code>k</code>的子序列，满足这个子序列对应的正整数是<code>4</code>的倍数。小红想知道有多少种不同的选择方案?</p><p> 请注意，选择的子序列包含前导零也是合法的。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入两个正整数<code>n</code>，<code>k</code>，代表数字串的长度和取的子序列长度。</p><p>第二行输入一个长度为<code>n</code>的、仅由数字字符组成的字符串。<br>$$<br>1\le k \le n \le 200000<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>一个整数，代表合法的子序列数。由于答案可能过大，请对<code>10e9+7</code>取模</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li><p>dp数组含义：</p><ul><li><code>dp\[i]\[j][h]</code>：前<code>i</code>个数字串，取<code>j</code>个字符，模4等于<code>h</code>的合法组合数</li></ul></li><li><p>状态转移方程，这里我们有三种情况需要处理，我们令<code>num</code>为第i个数： </p><ul><li><p>组合不包含第i个数字的个数：这种情况就是前面的<code>dp</code>大小，即<code>dp[i][j][h]=dp[i-1][j][h]</code></p></li><li><p>组合包含第i个数字的个数：这种情况就是把前面去j-1个串然后加上num取模的结果加到当前<code>dp</code>上去，即<code>dp[i][j][(h*10+num)%4]+=dp[i-1][j-1][h]</code></p><p>这里可以证明，推导如下：<br>$$<br>对于原本数字，我们可以设为：x&#x3D;b_i\times 4^i+b_{i-1}\times 4^{i-1}+…+b_0\times4^0\<br>我们令h&#x3D;x % 4&#x3D;b_0 % 4\<br>原本的数x末尾加上num后结果可以表示为：\<br>x’&#x3D;b_i\times 4^i\times10+b_{i-1}\times 4^{i-1} \times 10+…+b_0\times 4^0 \times 10+num\<br>因此，x’% 4&#x3D;(b_0\times 4^0 \times 10+num)%4&#x3D;(h\times10+num)% 4<br>$$</p></li></ul></li></ol><ul><li>组合<strong>只</strong>包含第i个数字的个数：这种情况其实就是取1个字符的结果，模多少对应的dp就加一，即<code>dp[i][1][num%4]++</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> times=<span class="hljs-number">4</span>;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n=in.nextInt();<br>        <span class="hljs-type">int</span> k=in.nextInt();<br>        in.nextLine();<br><br>        <span class="hljs-type">char</span>[] nums = in.nextLine().toCharArray();<br>        <span class="hljs-type">long</span> [][][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>][times];<br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>) Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> num=nums[i-<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>;h&lt;times;h++)&#123;<br>                    dp[i][j][h]=dp[i-<span class="hljs-number">1</span>][j][h];<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>;h&lt;times;h++)&#123;<br>                    dp[i][j][(h*<span class="hljs-number">10</span>+num)%times]+=dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][h];<br>                    dp[i][j][(h*<span class="hljs-number">10</span>+num)%times]%=mod;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>)&#123;<br>                    dp[i][j][num%times]++;<br>                    dp[i][j][num%times]%=mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(dp[n][k][<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股文精简版</title>
    <link href="/2023/12/17/%E5%85%AB%E8%82%A1/2023-12-17-%E5%85%AB%E8%82%A1%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/17/%E5%85%AB%E8%82%A1/2023-12-17-%E5%85%AB%E8%82%A1%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="八股文精简版"><a href="#八股文精简版" class="headerlink" title="八股文精简版"></a>八股文精简版</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>底层实现就是数组</p><p>其数组的初始化如果不给容量参数，那么就会初始化为0，在我们第一次添加数据的时候才会变成10</p><p>其次，在往后的添加数据过程中，只要添加后的容量没有超出底层数组的容量，就会直接添加</p><p>否则，就会先将底层数组的数据拷贝到一个长度为1.5倍的数组里，在添加（不是一味的扩容1.5倍，扩容后检测是否超出最大限制）</p><blockquote><p>由于是直接拷贝长度，因此扩容后的新数组实际上可能存在脏数据，所以我们取值用的是get方法，他会根据size判断你取值是否越界，避免脏数据</p></blockquote><p>当执行<code>Arrays.toList</code>的时候，返回的是一个内部类，不是util中的ArrayList，而且其底层的数组是引用，二者<strong>共用同一地址</strong></p><blockquote><p>无法add操作，底层用了final定义</p></blockquote><p>当执行ArrayList中的toArray的时候，是开辟新的空间，把数据拷贝进去，二者<strong>地址不同</strong></p><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>底层是一个双向链表</p><h6 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h6><ul><li>底层数据结构不同：ArrayList是一个动态数组，LinkedList是一个双向链表</li><li>操作数据效率不同</li><li>内存占用不同：ArrayList使用数组，连续存储，节省内存；LinkedList用的链表，额外存储了prev和next指针</li><li>二者都不是线程安全的</li></ul><h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h6><p>底层使用的是哈希表的结构，发生冲突时候会使用拉链法（后面追加链表）</p><p>但是不同的是这里不是简单的链表，当链表的长度达到8以上且数组的长度大于64的时候，会将其转化为红黑树的结构</p><p>这样即使在最坏的情况下，查找效率也是$O(log{n})$</p><blockquote><p>jdk1.8之前用的是链表的结构，之后才引入了红黑树</p></blockquote><h6 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h6><ul><li>查看当前hashmap有没有被初始化，如果没有就执行扩容</li><li>根据计算出来的hash值和当前容量按位与（因为容量是2的n次幂），得到对应的数组地址</li><li>如果对应位置为空，直接赋值，不为空则：<ul><li>​查看当前key和数组的key是否一样，一样则为更新操作，直接覆盖</li><li>不一样再向其中插入节点，其中如果是红黑树则走红黑树插入的逻辑，是链表直接放到链表尾部，但是链表插入完要看看长度是否超过8，超过的话再看看数组容量是否达到64，没达到需要先扩容，达到了才会转成红黑树结构</li><li>其次，插入遍历链表的过程中，发现key一样的直接覆盖</li></ul></li><li>上述逻辑执行完，相当于插入了一条数据，都会查看当前元素的数量是否超过数组数量$\times 0.75$，超过则需要扩容</li></ul><h6 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h6><ul><li>先检查有无初始化，没有初始化则初始化为16，直接结束</li><li>否则，将数组容量$\times 2$，然后遍历原数组的每个元素，如果该元素的next为空，则计算新的hash值插入数组，否则：<ul><li>是链表，需要对每个元素重新hash再逐个插入</li><li>是红黑树，执行红黑树插入</li></ul></li></ul><h6 id="寻址算法"><a href="#寻址算法" class="headerlink" title="寻址算法"></a>寻址算法</h6><p>给定一个key，它在数组中为值为：<code>(hash(key)^(hash(key)&gt;&gt;16))&amp;(capacity-1)</code></p><p>使用这样的方法计算哈希值，可以使得哈希值分布的更加均匀</p><h6 id="为什么数组长度是2的n次幂"><a href="#为什么数组长度是2的n次幂" class="headerlink" title="为什么数组长度是2的n次幂"></a>为什么数组长度是2的n次幂</h6><ol><li>在计算数组位置的时候，可以使用(capacity-1)&amp;hash，而不是模运算，减少开销</li><li>在扩容的时候，计算重新计算hash值不是真的重新计算，而是oldCapacity&amp;hash，如果为0则一样，如果为1说明hash的新一位和原来的不一样，则新位置改为：原位置+oldCapacity</li></ol><h6 id="jdk1-7中hashMap多线程死循环问题"><a href="#jdk1-7中hashMap多线程死循环问题" class="headerlink" title="jdk1.7中hashMap多线程死循环问题"></a>jdk1.7中hashMap多线程死循环问题</h6><p>根本原因：jdk1.7扩容时，数据迁移用的是头插法，但是由于put操作用的尾插法，会导致扩容后的链表顺序相反</p><p>发生场景：</p><ul><li>线程一准备扩容的时候，阻塞，此时item和next指针都已经指向了链表的第一个元素和第一个元素的next</li><li>此时线程二开始扩容，扩容完毕后，原本第一个元素的next变成了null</li><li>线程一开始迁移，由于next指针和当前真实的链表顺序不符，此次迁移完毕后链表会形成<strong>环状结构</strong>，下次get操作会导致死循环问题</li></ul><blockquote><p>在jdk1.8中，改成了尾插法，因此扩容后不会改变原有顺序</p></blockquote><h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><h4 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h4><p>Spring是一款开源的轻量级Java开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>其提供的最主要的核心功能就是IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming，面向切面编程）。</p><p>它有几个比较重要的模块：spring-core(IoC)、spring-bean、spring-jdbc、spring-aop、spring-webmvc</p><h4 id="Spring、Spring-MVC、Spring-Boot的关系"><a href="#Spring、Spring-MVC、Spring-Boot的关系" class="headerlink" title="Spring、Spring MVC、Spring Boot的关系"></a>Spring、Spring MVC、Spring Boot的关系</h4><p>Spring其实包含了很多的功能模块（上述已经提到了几个），而其中的spring-webmvc是其中比较重要的一个模块。</p><p>Spring MVC主要提供了快速构建MVC架构的web程序的能力</p><p>在Spring开发过程中手动配置过于繁琐，尤其是有时候需要编写复杂的xml文件，为了简化这一过程，Spring Boot诞生了。</p><blockquote><p>要注意的是，Spring Boot仅仅是为了简化开发中繁琐的配置。</p><p>比如我们进行MVC开发时候还得使用Spring MVC，但是我们使用了Spring Boot简化了Spring MVC的配置过程。</p></blockquote><h4 id="SpringBoot、Spring-Cloud、Spring-Cloud-Alibaba的关系"><a href="#SpringBoot、Spring-Cloud、Spring-Cloud-Alibaba的关系" class="headerlink" title="SpringBoot、Spring Cloud、Spring Cloud Alibaba的关系"></a>SpringBoot、Spring Cloud、Spring Cloud Alibaba的关系</h4><p>随着SpringBoot项目越来越大，我们开发难度也陡然上升，同时维护难度也在上升</p><p>因此SpringCloud提出了一套微服务的规范，广义上的SpringCloud其实就这个，它提供了一套微服务架构的标准规范，比如网关、负载均衡、服务发现等等，至于每个模块用什么技术，那么就是下面的实现问题了</p><p>常用的两个实现就是SpringCloudNetflix以及SprinCloudAlibaba，其中前者就是狭义上的SpringCloud</p><p>二者都为对应SpringCloud给出的对应模块给出了相应的技术实现：</p><ul><li><p><strong>SpringCloudNetflix</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405191756153.jpeg" alt="img" style="zoom: 67%;" /></li><li><p><strong>SpringCloudAlibaba</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405191757679.png" alt="img" style="zoom: 50%;" /></li></ul><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>IoC（Inversion of Control ）即控制反转&#x2F;反转控制，它是一种思想不是一个技术实现。</p><p>比如说：现在有一个类A，依赖于类B，那么就有两种常用的方法</p><ul><li>自定义A的构造函数，在其中new一个实例B</li><li>使用IoC，在初始化A的时候注入类B的实例</li></ul><p><strong>我们放弃了自己创建、管理对象的权力，将其交给Spring，但是我们同时也就不需要考虑创建、管理对象这一系列过程。</strong></p><p><strong>控制反转指的是：</strong></p><ul><li>控制：管理、创建对象</li><li>反转：将权力交给外部框架，如Spring</li></ul><p>IoC降低了对象之间的耦合度以及依赖程度，并且使得资源管理变得容易，只要将其加入了容器，你可以随时随地的注入。</p><h6 id="IoC与DI"><a href="#IoC与DI" class="headerlink" title="IoC与DI"></a>IoC与DI</h6><p>IoC（Inversion of Control）是一种设计思想或者说是某种模式，但是这设计思想在其他框架中也是使用了的。</p><p><strong>而IoC的较为普遍的、最合理的实现方式就是DI（Dependency Injection，依赖注入）</strong></p><h4 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h4><h6 id="如何声明Bean对象"><a href="#如何声明Bean对象" class="headerlink" title="如何声明Bean对象"></a>如何声明Bean对象</h6><p>Bean实际上就是指的被Spring IoC管理的那些对象，最基本的我们可以通过@Component注解来声明一个类为bean对象。</p><p>除此之外，在Spring MVC中由于分为了持久层、业务层、控制层，为了提高分辨率衍生了出了三个注解分别为@Repository、@Service、@Controller。</p><p>另外，对于通过方法声明的自定义bean，我们可以在方法上面加上@Bean注解来声明。</p><blockquote><p>@Bean与@Component有什么区别？</p><ol><li>@Bean作用与方法，而@Component作用与类</li><li>由于@Bean使用的方法，因此自定义性更强，比如定义RedisTemplate的序列化器</li></ol></blockquote><h6 id="如何注入Bean对象"><a href="#如何注入Bean对象" class="headerlink" title="如何注入Bean对象"></a>如何注入Bean对象</h6><p>一般来说，使用Spring提供的@Autowired或者JDK内置的@Resource注解</p><p>但是@Autowired注解是byType方式注入的，如果某个接口有多个实现类，那么就需要再加上一个@Qualifier注解，使用byName方式注入，而@Resource默认是byName方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><h6 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h6><p>在IoC中，有两种常见的作用域，分别为prototype和singleton，这两种作用域下是不同的。</p><p>对于prototype来说，由于每次获取都会new一个新对象，因此是线程安全的</p><p>但是对于singleton来说，由于使用的是单例模式，因此如果该bean对象是<code>有状态的</code>，那么就不是线程安全的。</p><p><strong>有两种解决方法</strong></p><ul><li>尽量不要定义有状态的bean对象</li><li>对于状态字段，可以使用ThreadLocal变量来保存</li></ul><h6 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h6><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231207163100469.png" alt="image-20231207163100469" style="zoom: 50%;" /><ul><li>执行构造函数实例化bean</li><li>bean依赖注入</li><li>处理一系列Aware结尾的接口</li><li>执行bean的前置处理器</li><li>初始化方法（PostConstruct自定义初始化、内置的初始化）</li><li>执行bean的后置处理器，一般在这做AOP，动态代理</li><li>销毁bean</li></ul><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><p>AOP（Aspect-Oriented Programming:面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度</p><blockquote><p>Spring AOP主要基于<strong>动态代理技术+拦截器</strong>，对于有实现接口的类，会使用JDK proxy去创建代理对象，而对于没有实现接口的类会使用Cglib生成一个该类的子类作为代理对象。</p></blockquote><h6 id="几个重要术语"><a href="#几个重要术语" class="headerlink" title="几个重要术语"></a>几个重要术语</h6><ul><li>横切关注点（cross-cutting concerns） ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制等）。 </li><li>切面（Aspect）：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。 </li><li>连接点（JoinPoint）：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。 </li><li>通知（Advice）：通知就是切面在某个连接点要执行的操作。通知有五种类型：Before、After、AfterReturning、AfterThrowing、Around。</li><li>切点（Pointcut）：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。</li><li>织入（Weaving）：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。</li></ul><h6 id="常见的实现方式"><a href="#常见的实现方式" class="headerlink" title="常见的实现方式"></a>常见的实现方式</h6><p>有两种：<code>Spring AOP 与 AspectJ AOP</code></p><p>前者使用的是运行时增强（基于Dynamic Proxy），而后者使用的是编译时增强（基于字节码）。</p><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><h6 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h6><p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务、数据、显示三者分离来组织代码</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401181452594.png" alt="image-20240117161209710" style="zoom: 33%;" /><p><code>MVC更多的可以看看作是一种设计模式，而不是软件开发规范</code></p><h6 id="Spring-MVC的核心组件"><a href="#Spring-MVC的核心组件" class="headerlink" title="Spring MVC的核心组件"></a>Spring MVC的核心组件</h6><ul><li>DispatcherServlet：核心的中央处理器，负责接收请求、分发，并给予客户端响应。 </li><li>HandlerMapping：处理器映射器，根据URL去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。 </li><li>HandlerAdapter：处理器适配器，根据HandlerMapping 找到的Handler，调用对应的 Handler</li><li>Handler：请求处理器，处理实际请求的处理器。 </li><li>ViewResolver：视图解析器，根据 Handler 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 DispatcherServlet响应客户端</li></ul><h6 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h6><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401181451517.png" alt="image-20240117161537732" style="zoom: 33%;" /><ul><li>用户发起请求，DispatcherServlet拦截到用户的请求</li><li>DispatcherServlet根据URL路径，去HandlerMapping找到响应的Handler，并且会和拦截器一起返回一个调用链</li><li>DispatcherServlet调用HandlerAdapter，让Adapter去调用Handler</li><li>HandlerAdatpter调用Handler，然后返回ModelAndView对象</li><li>DispatcherServlet收到后，会去调用ViewResolver去解析，返回一个View视图对象</li><li>DispatcherServlet返回View视图给用户</li></ul><h4 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h4><p>在Spring中，一般使用@Transactional注解来开启事务（侵入性更小），但是要在配置类上加上@EnableTransactionManagement注解</p><h6 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h6><p>Spring框架中，和事务有关的有三个类：</p><ul><li>PlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心。</li><li>TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、 回滚规则)。</li><li>TransactionStatus：事务运行状态</li></ul><p>其中，PlatformTransactionManager是SPI的形式，它定义好了接口，由JDBC、Hibernate等自己去实现自己的事务管理器。在该接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> &#123;<br>    <span class="hljs-comment">//获得事务</span><br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//提交事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h6><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。比如，到底是新开启一个事务，还是加入当前事务</p><p>在Spring中，定义了这么几种形式</p><ol><li><p>TransactionDefinition.PROPAGATION_REQUIRED</p><p>这是使用最多的，也是@Transaction注解默认的传播形式</p><ul><li>如果外部方法没有开启事务的话，Propagation.REQUIRED修饰的内部方法会新开启自己的事务</li><li>如果外部方法开启事务并且被Propagation.REQUIRED的话，所有 Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚</li></ul></li><li><p>TransactionDefinition.PROPAGATION_REQUIRES_NEW</p><p>创建一个新的事务，如果当前存在事务则把当前事务挂起，当前方法会新开启自己的事务</p></li><li><p>TransactionDefinition.PROPAGATION_NESTED</p><p>与PROPAGATION_REQUIRES_NEW不同，PROPAGATION_NESTED的事务和它的父事务是相依的，它的提交要和它的父事务一起。也就是说，如果父事务最后回滚，它也要回滚。如果子事务回滚或提交，不会导致父事务回滚或提交，但父事务回滚将导致子事务回滚</p></li></ol><h6 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h6><p>如果你一次执行多条查询语句，为了防止多条语句之间有事务提交，<code>保证读一致性</code>，可以开启只读事务。</p><h6 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h6><ol><li><p>异常捕获处理</p><p>在事务中捕获异常没有抛出，而是在catch中自己处理了。由于事务的AOP中就无法捕获到异常，会直接提交事务。</p></li><li><p>抛出检查异常</p><p>如果在方法后面加上throw 异常，那么就不会抛出RuntimeException了，而spring的事务默认只会捕获运行时异常。</p><p><code>解决方法</code>：在@Transactional注解中指定捕获的异常类</p></li><li><p>非public方法</p><p>如果使用注解的方法不是public方法，那么也会失效。</p></li><li><p>在Bean内部调用自己的事务方法</p><p>由于在内部调用自己的方法，因此没有使用代理类，导致AOP失效。</p><p><code>解决方法</code>：获取代理类，比如在方法内部注入自己，用这个类调用方法。</p></li></ol><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><h6 id="什么是Spring-Boot-Starters"><a href="#什么是Spring-Boot-Starters" class="headerlink" title="什么是Spring Boot Starters"></a>什么是Spring Boot Starters</h6><p><code>Spring Boot Starters是一系列依赖关系的集合</code>。没有这个之前，在开发web应用的时候，需要自己导入MVC、Tomcat相关依赖，而且还得确定好版本防止冲突。但是有了Spring Boot Starters，只需要引入spring-boot-starter-web就好了，它下面的子依赖已经包含了所有的web需要的依赖，并且配置好了版本。</p><h6 id="Spring-Boot的自动配置原理"><a href="#Spring-Boot的自动配置原理" class="headerlink" title="Spring Boot的自动配置原理"></a>Spring Boot的自动配置原理</h6><p>在Spring Boot启动类上有这样一个注解：@SpringBootApplication</p><p>实际上，这个注解里面包含了三个注解：</p><ul><li>@ComponentScan：扫描Bean，并加入IoC容器</li><li>@Configuration：声明该类是一个配置类，可以在里面声明Bean，导入其他配置类</li><li>@EnableAutoConfiguration：这个就是SpringBoot自动配置的注解，它通过@Import注解导入了一个AutoConfigurationImportSelector类，实现自动配置。</li></ul><h6 id="AutoConfigurationImportSelector工作流程"><a href="#AutoConfigurationImportSelector工作流程" class="headerlink" title="AutoConfigurationImportSelector工作流程"></a>AutoConfigurationImportSelector工作流程</h6><ul><li>读取META-INF&#x2F;spring.factories，获取需要自动装配的所有配置类</li><li>但并不是加载所有的自动配置类，它会通过@ConditionalOnxxx注解判断是否需要加载，满足条件后才会生效</li></ul><blockquote><p>想要相关配置生效必须引入spring-boot-starter-xxx包实现起步依赖</p></blockquote><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h4 id="MySQL-字段"><a href="#MySQL-字段" class="headerlink" title="MySQL 字段"></a>MySQL 字段</h4><h6 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h6><p>对于varchar来说，磁盘中只会存储实际长度的空间，但是char是声明了多大就会存储多大</p><p>对于varchar(10)和varchar(100)来说，虽然磁盘占用一样，但是实际读取到内存中的时候，varchar(100)还是会占用100个字节的空间</p><h6 id="不推荐使用TEXT和BLOB"><a href="#不推荐使用TEXT和BLOB" class="headerlink" title="不推荐使用TEXT和BLOB"></a>不推荐使用TEXT和BLOB</h6><p>这两种类型，在使用临时表的时候无法在内存中创建，只能在磁盘中创建，并且其检索效率较低</p><h6 id="NULL和’’"><a href="#NULL和’’" class="headerlink" title="NULL和’’"></a>NULL和’’</h6><p>在MySQL中，NULL需要占用额外的空间，但是’’占用空间是0</p><p>此外，在做条件判断的时候NULL只能使用IS NULL来判断，无法使用&#x3D;、&lt;这种比较运算符。</p><h4 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401181451253.png" alt="image-20240118144412169" style="zoom: 33%;" /><p>MySQL的基础架构大致可以分为两个部分：<strong>Server层</strong>和<strong>存储引擎</strong></p><h6 id="Server层基本组件"><a href="#Server层基本组件" class="headerlink" title="Server层基本组件"></a>Server层基本组件</h6><ul><li>连接器：接收客户端连接，并校验用户身份和权限。注意的是，用户登录成功后，连接器会从权限系统表中查询出权限数据并保存，即使在该连接中用户修改了系统表，次用户连接的权限仍然是登录时候的权限。</li><li>查询缓存：会记录select语句以及结果，一旦执行的select语句命中并且权限校验通过，就直接返回结果</li><li>分析器：对sql语句进行词法分析（提取sql关键字）和语法分析（语句是否正确）</li><li>优化器：按照优化方案优化语句（可能优化的方式不是最优的），比如索引的选择等</li><li>执行器：校验权限正确后，调用存储引擎接口，返回数据</li></ul><blockquote><p>MySQL 8.0 版本后删除了缓存的功能</p></blockquote><h6 id="Update语句执行过程"><a href="#Update语句执行过程" class="headerlink" title="Update语句执行过程"></a>Update语句执行过程</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tb_student A set A.age=&#x27;19&#x27; where A.name=&#x27;张三&#x27;;<br></code></pre></td></tr></table></figure><ul><li>查询满足条件的数据，如果有缓存会使用缓存</li><li>查询后，修改相应的记录并调用InnoDB接口</li><li>在InnoDB中，会先将语句以及修改的相关数据页保存在内存中，并通过两阶段写入日志的方法写入redo log和binlog，并选择合适的时机将脏数据写入磁盘（如果没有写入就宕机了，可以通过redo log恢复）</li></ul><h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><p>要注意的是，存储引擎是基于表的而不是数据库，也就是说对于每个表都可以定制自己的存储引擎</p><p>MySQL5.5之前，MyISAM是默认引擎，之后就是InnoDB了，二者区别如下：</p><ul><li>InnoDB支持行级锁，而MyISAM只有表级锁</li><li>MyISAM不提供事务支持，InnoDB提供事务支持</li><li>MyISAM不支持MVCC，而InnoDB支持</li><li>InnoDB有redo log和undo log，因此可以支持故障恢复</li></ul><h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>无论是在InnoDb还是MyISAM中，索引的结构使用的都是B+树的结构</p><p>索引虽然可以加快查询的速度，但是增加了更新操作的开销</p><h6 id="索引底层的数据结构（B-树）"><a href="#索引底层的数据结构（B-树）" class="headerlink" title="索引底层的数据结构（B+树）"></a>索引底层的数据结构（B+树）</h6><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202404112111758.png" alt="image-20240118171104728" style="zoom:50%;" /><p>相比于B树来说：</p><ul><li>B+树只在叶子节点存放数据，每次查询必要搜索到底并且只在最后一次读取全部数据到内存，因此搜索效率更加稳定</li><li>在叶子节点使用链表的结构，因此更适用于范围查询</li></ul><blockquote><p>对于MyISAM，每个索引只存放key以及数据指针，不存放数据；而在InnoDB中，其主键索引存放数据。</p></blockquote><h6 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h6><p>聚簇索引指的是key与数据一起存放的索引，非聚簇索引只存放key和对于的指针</p><p>在InnoDB中，主键索引就是聚簇索引；InnoDB中的二级索引以及MyISAM中的所有索引都是非聚簇索引</p><ul><li>聚簇索引查询的效率更高，减少了一次IO，但是需要更大的存储空间</li><li>非聚簇索引更轻量，但是可能会造成回表查询</li></ul><h6 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h6><p>一个索引包含所有要查询的字段值，就称之为覆盖索引。（这其实是一种situation，而不是一种type）</p><h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p>使用表中的多个字段创建索引，它遵循最左匹配原则</p><p>最左匹配原则的原因是：联合索引简历后，只有左边的值确定了，才会根据排序进一步筛选右边的字段，否则直接筛选右边的字段是无序的</p><p>就好比你要从一个排好序的字符串数组中找第三位是’c’的所有字符串，但是你不给前两位，直接找第三位其实是无序的需要全局遍历，如果给定前两位你可以直接二分查找。</p><h6 id="对于索引的使用建议"><a href="#对于索引的使用建议" class="headerlink" title="对于索引的使用建议"></a>对于索引的使用建议</h6><ul><li>为合适的字段创建索引：比如不为NULL、频繁查询、频繁连接的字段</li><li>被频繁更新的字段应该慎重建立索引，因为添加索引后，会增加更新的开销</li><li>尽量使用联合索引，而不是单个索引</li></ul><h6 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h6><ul><li>没有使用索引覆盖，导致查询后导致回表（比如 select *）</li><li>创建了组合索引，但查询条件未遵守最左匹配原则</li><li>以%开头的LIKE查询比如LIKE ‘%abc’;</li></ul><h4 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h4><p>MySQL中有三个较为重要的日志：redo log、undo log、binlog。其中redo log和undo log是InnoDB自己的</p><h6 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h6><p><strong>redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力</strong></p><p>redo log写入磁盘的方式：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401191956609.png" alt="image-20240119195629553" style="zoom: 33%;" /><p>redo log buffer -&gt; page cache -&gt; disk</p><p>但是刷盘的时机是可以设置的，有三种方式</p><ul><li>事务提交不立即刷盘，而是每秒将buffer写入page cache，并调用fsync刷盘</li><li>事务提交立即写入page cache并调用fsync刷盘</li><li>事务提交立即写入page cache，但每隔一秒调用fsync刷盘</li></ul><blockquote><p>page cache独立于MySQL，它是属于操作系统的部分</p></blockquote><h6 id="为什么要用redo-log，而不是每次更新直接刷数据盘"><a href="#为什么要用redo-log，而不是每次更新直接刷数据盘" class="headerlink" title="为什么要用redo log，而不是每次更新直接刷数据盘"></a>为什么要用redo log，而不是每次更新直接刷数据盘</h6><ol><li>数据页太大，一般为16KB，不能每次为了更新几十字节的数据就进行16KB的文件IO</li><li>每次更新的相关数据不一定位于同一数据页，容易发生页的换进换出，而redo log属于追加方式的顺序IO，很少发生换进换出</li></ol><h6 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h6><p>redo log它是物理日志，记录内容是“在某个数据页上做了什么修改”，而binlog是逻辑日志，记录内容是语句的原始逻辑</p><p>binlog主要用于数据备份，主从同步等操作，保证数据一致性</p><p>binlog刷盘流程如下，事务已提交就写入page cache，但是用户可以自定义：每秒fsync还是wrtie完直接fsync</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401192017585.png" alt="image-20240119201717525" style="zoom:33%;" /><h6 id="binlog为什么不能做崩溃恢复"><a href="#binlog为什么不能做崩溃恢复" class="headerlink" title="binlog为什么不能做崩溃恢复"></a>binlog为什么不能做崩溃恢复</h6><p>binlog记录了所有的操作，而redo log只记录了数据修改后的结果</p><p>因此发生故障时，直接通过redo log覆盖数据就好，但是binlog是逻辑指令，会发生数据不一致</p><p>比如binlog记录了加十次1，恢复的时候不能简单基于当前结果加十次1，因为你不知道从哪一次开始发生故障的，而redo log记录了当前记录为8，直接覆盖就行</p><h6 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h6><p>用于解决发生故障时，binlog和redo log不一致的问题</p><p>具体方法：</p><ul><li>先写入redo log，并将该记录置为prepare状态</li><li>事务提交后，会写入binlog</li><li>写完binlog后，将redo log对应记录置为commit状态</li></ul><p>若第二步失败，恢复时会发现redo log存在prepare项且binlog无对应项，<code>回滚</code></p><p>若第三步失败，恢复时会发现redo log存在prepare项但binlog有对应项，<code>提交</code></p><h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><p>用于事务的回滚操作以及MVCC，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作</p><h4 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h4><h6 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h6><p>关系型数据库事务满足ACID特性：Atomicity、Consistency、Isolation、Durability</p><blockquote><p>AID是手段，C是目的</p></blockquote><h6 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h6><ul><li>脏读：由于其他事务的更新操作，当前事务读到了其他事务修改但还未提交的记录</li><li>丢失修改：两个事务同时读，并都基于当前值修改（如A&#x3D;A-1），那么就会导致最终只修改了一次</li><li>不可重复读：在两次读之间，如果有事务的修改操作提交，会导致两次读的记录可能不一样</li><li>幻读：在两次读之间，如果有事务进行了<strong>插入&#x2F;删除操作</strong>，那么第二次读可能会莫名其妙多了一些数据</li></ul><blockquote><p>不可重复读主要针对于update操作，可以直接通过加锁来解决</p><p>但是幻读针对于insert、delete操作，你无法对原本不存在的数据加锁</p></blockquote><h6 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h6><p>read-uncommitted、read-committed、repeatable-read、serializable</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC的实现主要依靠三个部分实现：</p><ul><li>隐藏字段：事务id、回滚指针(指向undo log中上一个版本记录的指针)</li><li>读视图</li><li>undo log</li></ul><p>具体实现流程如下：</p><ul><li>根据当前事务的隔离级别，生成读视图（RC级别下，每次读都会生成；RR级别下，只有第一次读的时候会生成一次）</li><li>当需要读的时候会根据读视图的内容做以下判断：<ul><li>当前记录版本的事务id小于min_trx_id，那么说明该版本事务创建于读视图创建之前，直接使用</li><li>当前记录版本的事务id大于max_trx_id，那么说明该版本事务创建于读视图创建之后，不能使用</li><li>当前记录版本的事务id在二者之间，如果没有在读视图的活跃事务列表中（比如修改的是自己），那么可以使用，否则不能使用</li></ul></li><li>一旦发现该版本不能使用，则通过上一个版本的指针判断undo log中的旧版本是否可用，直至遍历到尾指针则返回空</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201101170.png" alt="image-20240120110139110" style="zoom:50%;" /><h4 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h4><p>对于RR下面的一致性非锁定读（普通select语句），可以使用MVCC机制解决不可重复读和幻读问题</p><p>但是对于锁定读：</p><ul><li>select … lock in share mode</li><li>select … for update</li><li>insert、update、delete</li></ul><p>这种操作，不会使用MVCC乐观锁机制，会直接读取最新的版本，可以通过加S锁(共享锁，读锁)和X锁(排他锁，写锁)来保证可重复读，但无法解决幻读问题</p><p>解决幻读的方法是添加间隙锁，对于当前查询的范围添加锁，不允许插入满足查询条件的数据</p><h4 id="Mybatis相关问题"><a href="#Mybatis相关问题" class="headerlink" title="Mybatis相关问题"></a>Mybatis相关问题</h4><h6 id="Dao接口的工作原理"><a href="#Dao接口的工作原理" class="headerlink" title="Dao接口的工作原理"></a>Dao接口的工作原理</h6><p>xml中开头就是namespace，这个是dao接口的全限定名</p><p>然后每个MapperStatement都有一个id这个就对应的Dao接口函数名</p><p>Dao接口没有实现类，调用的时候会通过接口类的全限定名加函数名构造唯一的key，找到相应的MapperStatment，执行相应语句</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h4 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h4><h6 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h6><ul><li>Redis是基于内存的，IO速度本来就很快</li><li>Redis使用了IO多路复用技术</li><li>Redis是单线程的，不需要考虑上下文切换，而且不用考虑多线程安全问题</li></ul><h6 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h6><ul><li>Cache Aside Pattern：先更新DB，再删除缓存（反过来不行，因为更新DB的时间更长，容易导致不一致），但是这样也会导致不一致，没办法，redis本来就不是用来保证强一致性的</li><li>Read&#x2F;Write Through Pattern：写的时候若有cache先写到缓存，然后由cache服务<code>同步</code>更新DB</li><li>Write Behind Pattern：写的时候若cache存在，则先写到cache，然后由cache服务<code>异步</code>更新DB</li></ul><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><h6 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h6><p>会基于当前redis的状态，生成一个快照，对所有数据进行备份</p><p>由于这种方式比较耗时，可以通过bgsave指令来另外fork一个线程用于保存快照</p><h6 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h6><p>和mysql的binlog类似，会记录每次执行的指令，并记录到buffer中，然后buffer -&gt; page cache -&gt; aof file</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201137280.png" alt="image-20240120113748242" style="zoom:50%;" /><p>每次写入一个指令到buffer中就会调用一次write，然后会根据不同策略调用fsync：</p><ul><li>一条指令一个fsync</li><li>一秒一次fsync</li><li>由操作系统自己fsync，一般30秒一次</li></ul><h6 id="为什么AOF先记录日志再执行指令"><a href="#为什么AOF先记录日志再执行指令" class="headerlink" title="为什么AOF先记录日志再执行指令"></a>为什么AOF先记录日志再执行指令</h6><blockquote><p>首先要注意的是，Redis的设计是为了满足系统的高可用性，真的要实现强一致会降低性能</p></blockquote><ul><li>避免写入日志前的语法检查</li><li>避免记录日志对当前指令执行的阻塞，但是会导致对后续指令的阻塞</li></ul><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>开启混合模式后，会将RDB的文件加到AOF文件开头，大大减小AOF文件的大小</p><p>混合模式就是为了综合二者的优点：</p><ul><li>RDB文件只是redis的快照，文件大小更小，并且还原更快</li><li>AOF的持久化速度更快，实时性更高</li></ul><h4 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h4><p>Redis的指令执行是单线程的，但是对于网络请求、持久化这方面是可以支持多线程的，为的是提高IO性能</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201202823.png" alt="image-20240120120209740" style="zoom:50%;" /><h4 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h4><h6 id="过期key的处理"><a href="#过期key的处理" class="headerlink" title="过期key的处理"></a>过期key的处理</h6><p>redis使用了两个处理方式</p><ul><li>惰性删除：当对该key进行查询操作的时候，检查该key是否过期，如果过期则直接删除</li><li>定期删除：redis每隔一段时间就会抽取<code>一部分的key</code>检查过期状态，<strong>这个线程是主线程，会阻塞指令执行</strong></li></ul><h6 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h6><p>当redis内存满了过后再添加数据就会触发内存淘汰机制</p><ol><li>noeviction：内存满了不允许写入</li><li>volatile-ttl：对设置了ttl的key，删除最快要过期的数据</li><li>allkeys-random：对全体key随机删除</li><li>volatile-random：对设置了ttl的key，随机删除</li><li>allkeys-lru：对所有的key，使用LRU算法    <code>这个是最常用的</code></li><li>volatile-lru：对设置里ttl的key，使用LRU算法</li><li>allkeys-lfu：对所有的key，使用LFU算法</li><li>volatile-lfu：对设置里ttl的key，使用LFU算法</li></ol><h4 id="事务、pipeline、Lua脚本"><a href="#事务、pipeline、Lua脚本" class="headerlink" title="事务、pipeline、Lua脚本"></a>事务、pipeline、Lua脚本</h4><p>三者都可以批量执行多个语句，但是还是存在一些区别</p><ul><li>事务：多个语句要分开做网络传递，但是批量执行期间不会被别的指令打断</li><li>pipeline：多个语句合到一次，只做一次网络交互，但是指令可能会穿插执行</li><li>Lua脚本：只做一次网络交互，并且不会被打断</li></ul><blockquote><p>这三个都无法实现<strong>原子性和一致性</strong>，无法支持出错回滚，一般使用Lua脚本来实现事务</p></blockquote><h4 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h4><ul><li>使用批量操作减少网络传输：使用mset类似的指令，对于不同指令可以使用Lua脚本、pipeline</li><li>大量key集中过期问题：定期清理中，若发现大量过期key会导致阻塞时间过长，可以设置随机TTL</li><li>bigkey问题：如果一个key大小过大，会导致网络IO阻塞、过期清理时间长，可以对其分割存储</li><li>hotkey问题：如果一个key访问频率过高，同样也会影响网络IO，可以使用主从库、集群方式减轻压力，也可以使用本地缓存减少redis访问频率</li><li>慢查询：一般redis中根据key查找都是O(1)复杂度，但是如果使用keys *这种指令，就会导致时间复杂度为O(n)，导致慢查询，我们尽量要避免这种类似指令</li></ul><h4 id="Redis内存碎片"><a href="#Redis内存碎片" class="headerlink" title="Redis内存碎片"></a>Redis内存碎片</h4><ul><li>由于Redis为一个key申请空间的时候，一般都要比其占用空间要大一点，这就会导致内部碎片</li><li>同时当我们频繁的删除key的时候，其占用的内存并不会立刻free，这就会导致外部碎片</li></ul><h4 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h4><p><strong>缓存三兄弟</strong>：缓存穿透、缓存雪崩、缓存击穿</p><h6 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h6><p>访问大量DB中不存在的key，由于redis中没有，所有请求会直接转向DB</p><ul><li>可以在redis中缓存该不存在的key，其value设置为一个约定的特殊字符，代表NULL</li><li>使用bloom filter，但是会产生误判，认为不存在的key存在，但是使用适当的bitmap长度，性能很高</li></ul><h6 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h6><p>大量key在同一时间失效，或者redis服务直接宕机，那么所有请求都会转向DB</p><ul><li>使用集群、sentinel</li><li>随机TTL</li></ul><h6 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>对于某个热点key，如果发生过期或者不在redis中，大量请求也同样会转向DB</p><ul><li>缓存预热</li><li>使用互斥锁访问、逻辑过期</li><li>设置热点数据永不过期或者过期时间比较长</li></ul><h4 id="Redis集群-哨兵模式"><a href="#Redis集群-哨兵模式" class="headerlink" title="Redis集群-哨兵模式"></a>Redis集群-哨兵模式</h4><p>哨兵模式（sentinel）用于实现主从集群的自动故障恢复</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231130174229378.png" alt="image-20231130174229378" style="zoom: 33%;" /><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><ol><li>监控master和slave是否在按照预期正常运作</li><li>如果master故障，sentinel会从slave中选取一个作为新的master（故障转移）</li><li>通知redis客户端主从发生变化，防止客户端违规的向原本的master写数据</li></ol><h6 id="服务状态监控工作原理"><a href="#服务状态监控工作原理" class="headerlink" title="服务状态监控工作原理"></a>服务状态监控工作原理</h6><p>基于心跳机制检测，一旦有一个sentinel发现ping不通某个node就会认为该node主观下线。</p><p>一旦有超过一定数量（自己配置）的sentinel都认为该node主观下线，则该node客观下线</p><p>如果认为客观下线的node是master则会通过以下方式选举新的master：</p><ul><li>根据设定的优先级选择slave作为master</li><li>如果优先级一样，选offset最大的slave</li></ul><blockquote><p>sentinel自己也是一个node，也就是说一个sentinel会ping所有的主从redis，也会ping其他的sentinel</p></blockquote><h6 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h6><p>由于网络原因，sentinel无法连接到master认为其下线从而选出新的master。但是客户端仍可以与原本的master连接，因此在主从切换的过程中，原本的matser仍然在接收写命令。</p><p>但是一旦网络恢复，原本的master会变为slave，他会清空原本写入的数据，和新的master做全量同步，这会导致在主从切换过程中写入的数据发生丢失。</p><p>可以通过设置两个参数来解决</p><ul><li><code>min-replicas-to-write</code>：表示最少的从节点个数，如果不满足则不允许执行写操作</li><li><code>min-replicas-max-lag</code>：表示数据复制时的 ACK 消息延迟的最大时间。主库做同步时，如果没有在指定时间返回ACK，则拒绝写入数据。</li></ul><h4 id="Redis集群-分片集群"><a href="#Redis集群-分片集群" class="headerlink" title="Redis集群-分片集群"></a>Redis集群-分片集群</h4><h6 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h6><ul><li><p>在分片集群中，有很多的master，每个master保存一部分数据</p></li><li><p>每个master必须至少有一个slave，但是并<strong>不会实现读写分离，slave只是做数据备份方便故障转移</strong></p></li><li><p>各个master之间互相通过心跳机制监控，不需要哨兵机制</p></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201351902.png" alt="image-20240120135042566" style="zoom:33%;" /><blockquote><p>如果有一个master故障并且没有slave，那么整个集群都将不可用</p></blockquote><h6 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h6><p>为了实现访问任何节点都可以得到同一个数据，redis使用了一种插槽的概念</p><p>插槽的总数是16384个，对于请求的key，会根据key做hash然后对16485取模</p><p>redis给每个master都分配了插槽，如果当前访问的节点发现算出来的结果不是自己的槽就会根据值路由到其他redis节点，否则从自己的内存中查出来返回。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231130175653818.png" alt="image-20231130175653818" style="zoom: 33%;" /><h6 id="Redis-Cluster扩容缩容期间可以提供服务吗"><a href="#Redis-Cluster扩容缩容期间可以提供服务吗" class="headerlink" title="Redis Cluster扩容缩容期间可以提供服务吗"></a>Redis Cluster扩容缩容期间可以提供服务吗</h6><p>如果进行重新分片，动态迁移哈希槽，那么可能会发生计算hash后来到指定节点，但是发现数据不存在的情况</p><p>为了保证cluster的可用性，有两个重定向包：</p><ul><li>MOVED：说明hash迁移完成，但是客户端没更新分配情况，因此会让客户端更新hash槽信息并返回真正存储该key的node</li><li>ASK：说明还正在迁移，只会发送存储该key的node，但不会让客户端更新hash槽信息</li></ul><h4 id="Redis的扩容缩容原理"><a href="#Redis的扩容缩容原理" class="headerlink" title="Redis的扩容缩容原理"></a>Redis的扩容缩容原理</h4><p>当redis的hash容量达到扩容或者缩容的阈值时，就会触发扩容缩容</p><p>此时会使用ht[1]，先申请一个足够的空间，然后将ht[0]的数据迁移过去</p><p>为保证可用性，并不是一次性迁移成功，而是每迁移一部分，就会停止，处理客户端请求</p><p>当迁移过程中，如果添加数据，就会直接插入ht[1]，查询数据会保留一个字段记录迁移到那个数据，在这个数据之前的访问ht[1]，之后的访问ht[0]</p><p>迁移完成后，ht[1]会变成ht[0]，同时释放ht[0]的空间</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401311148188.png" alt="image-20240131114846042" style="zoom: 33%;" /><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201447456.png" alt="image-20240120144703385" style="zoom:33%;" /><p>JVM的运行时数据区分为两大部分：线程共享和线程私有</p><p>其中线程共享的区域为：堆、字符串常量池、运行时常量池</p><p>线程私有的区域为：虚拟机栈、本地方法栈、程序计数器</p><h4 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h4><h6 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h6><p><strong>线程私有</strong>，用于记录当前线程执行到的字节码位置，方便线程的上下文切换</p><h6 id="两个栈"><a href="#两个栈" class="headerlink" title="两个栈"></a>两个栈</h6><p><strong>线程私有</strong>，都是用来保存函数调用产生的局部变量，调用一次压一次，返回后自动弹出</p><p>但是虚拟机栈保存的Java方法的方法调用，而本地方法栈保存的是native方法的方法调用</p><blockquote><ul><li>方法调用的返回分为两种形式，一种是return正常返回，一种是抛出异常</li><li>在局部变量中，对于对象而言，只保存引用变量，真正的对象实例依然是存放在堆中</li></ul></blockquote><h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><p><strong>线程共享</strong>，几乎所有的对象实例都是在堆中创建的</p><p>堆其实又分为多个区域：新生代、老年代，其中新生代又分为Eden区和Survivor区</p><p><code>要注意的是，虽说在JDK1.7之前还有个永久代，但是实际上永久代是方法区的一种实现，严格意义上说它并不属于堆的一部分</code></p><p>此外，JDK1.8过后永久代已经被元空间取代，并转移至本地内存中</p><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><p>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息等数据</p><p>方法区可以看作是一个接口，JDK1.8之前其实现是永久代，之后的实现是元空间</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201511592.png" alt="image-20240120151159547" style="zoom:33%;" /><blockquote><p>1.7之前是永久代；1.7的时候将字符串常量池和静态方法移至堆中存放；1.7以后，剩下的永久代中的东西移至元空间</p></blockquote><p>移至元空间的原因是永久代存在上限，无法动态调整，而本地内存取决于计算机的配置，不容易OOM</p><h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>它是方法区的一部分，用于存放字面量和符号引用的，常量池表会在类加载后存放到运行时常量池中</p><p>其中比较重要的是字符串常量池，它在JDK1.7的时候从永久代移到了堆中（静态变量也是），它是为了String类型专门开辟的常量池，为了减少相同字符串的重复创建</p><h6 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h6><p>直接内存比较特殊，它并不属于Java本身，是属于OS层面的，它方便了Java和操作系统之间的IO</p><p>一般来说，Java的IO依赖于native方法，这就会导致IO的数据会先从内核拷贝到native内存，再从native内存拷贝到Java内存</p><p>但是有了直接内存后，可以直接从内核拷贝到直接内存，然后Java直接读取直接内存，减少了一次数据拷贝</p><h4 id="JVM对象"><a href="#JVM对象" class="headerlink" title="JVM对象"></a>JVM对象</h4><h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><ul><li>首先在方法区中查找该对象对应的类有没有加载，若没有加载执行类加载逻辑</li><li>类加载完成后，就可以在堆中为该对象分配指定空间了，分配空间的方法取决于GC方法。分为空闲列表（未整理）以及指针碰撞（整理）</li><li>分配完指定空间，就将该空间的所有数据全部置为0，这样可以实现默认初始化，比如int的默认值为0</li><li>设置对象头，比如类的元数据信息、对象的哈希码、GC年龄</li><li>最后才是执行构造函数</li></ul><p>为了解决对象分配空间的并发问题，有两种方法</p><ul><li>CAS：失败重试</li><li>TLAB：为每个线程分配一点独立Eden空间，不够再CAS</li></ul><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>一个对象由三个部分组成：对象头、数据、对齐填充</p><h6 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h6><p>一个引用变量访问对象实例有两种方式</p><ul><li>句柄：引用变量指向句柄，句柄存放对象地址以及方法区中类信息地址</li><li>直接指针：引用变量直接指向实例，实例中存放方法区中类信息地址</li></ul><p>直接指针的访问速度更快，但是如果对象需要移动位置要修改所有的相关引用变量，而句柄只需要修改自己的对象指针就好</p><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><h6 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h6><ul><li><p>对象的创建基本都在Eden区，只有大对象的创建才会跳过Eden区，直接进入老年区，创建时年龄初始化为0</p></li><li><p>如果Eden区放不下了，就会触发一次GC，每次GC后所有存活的实例年龄+1，</p><blockquote><p>具体是何种GC方式取决于老年代的最大连续空闲空间是否大于等于所有新生代使用的空间（即就算所有新生代全部进入老年代也能放得下），如果大于等于就Minor GC；否则会Full GC</p><p>这其实就是<strong>空间分配担保</strong></p></blockquote></li><li><p>如果Eden区有年龄为1的对象，就会进入Survivor区</p></li><li><p>Surivior区如果有达到年龄阈值的就进入老年代</p><p>年龄的阈值有两个，一个是设置的固定阈值，一个是50%(50%也是设置的)空间所对应的年龄，二者取较小者为最后的阈值</p></li></ul><h6 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h6><ul><li>部分收集 (Partial GC)<ul><li>新生代收集（Minor GC）：只对新生代进行垃圾收集</li><li>老年代收集（Major GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li>整堆收集 (Full GC)：收集整个Java堆和方法区</li></ul><h4 id="死亡对象的判断方法"><a href="#死亡对象的判断方法" class="headerlink" title="死亡对象的判断方法"></a>死亡对象的判断方法</h4><h6 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h6><p>每有一个引用指向该对象，该对象的引用就加1，个数为0的可以被认为是垃圾对象</p><p>但是如果出现对象之间的循环引用，那么引用计数法就无法检测出来了</p><h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p>构造引用关系图，如果某个对象对任意一个GC root节点都不可达，那么就可以认为是垃圾</p><p>GC root可以是：虚拟机栈、本地方法栈中引用的对象、常量引用的对象、静态属性引用的对象</p><h6 id="如何回收方法区中的类"><a href="#如何回收方法区中的类" class="headerlink" title="如何回收方法区中的类"></a>如何回收方法区中的类</h6><p>回收该类需要满足三个条件</p><ol><li>该类所有的实例已经被回收</li><li>该类的ClassLoader已经被回收</li><li>该类的.Class对象没有地方引用，也没有地方反射调用类的方法</li></ol><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul><li><p>标记清除法：标记出所有不需要回收的对象，然后统一回收没有被标记到的对象，</p><p>会产生大量内存碎片</p></li><li><p>标记复制法：将原本的内存区域分为两块，每次清理的时候将存活的对象复制到另一块去</p><p>这会导致可用内存空间减小，并且如果碰到每次GC数量较少的内存区域（如老年代），每次为了GC几个对象而复制一堆对象，有些得不偿失</p></li><li><p>标记整理法：每次回收后，会把对象往一端移动，然后直接清理另一端脏数据区域</p><p>移动的效率不高，适合老年代这种回收频率低的区域</p></li></ul><blockquote><p>一般来说，新生代会使用标记复制，而老年代使用标记清除或者标记整理</p></blockquote><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>一共有四大类：serial、parallel、CMS、G1。其中serial和parallel都有两个版本分别针对新生代和老年代，称之为serial new + serial old以及parallel new + parallel old</p><p>其中new使用的是标记复制，old使用的是标记整理</p><p>对于serial和parallel，二者的区别在于回收的时候是单线程还是多线程，但是不管是不是多线程，回收的时候都会暂停程序的运行，即STW(“stop the world”)</p><p>在Java8及以前，JVM使用的就是parallel new + parallel old</p><p>而从Java9开始，就使用G1收集器了</p><h6 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h6><p>它使用的收集方法是标记清除算法</p><ul><li>初始标记：<code>STW</code>，找到GC root以及其直接关联的对象</li><li>并发标记：和用户线程并发，查找与GC root间接关联的对象，并且记录该过程中引用的变化情况</li><li>重新标记：<code>STW</code>，根据引用的变化情况，重新检查相关对象的可达性</li><li>并发清理：和用户线程并发，清理垃圾</li></ul><p>由于并发清理也可能会出现引用变化产生垃圾，因此会出现浮动垃圾的现象</p><p>此外使用标记清除法，会产生大量内存碎片</p><h6 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h6><p>G1收集器不再使用传统的各个区之间物理隔离，而是将整个堆分成了多个region，每个region都可以是Eden、Survivor、old</p><p>每次GC的时候其实就是将region中存活的对象拷贝到另一个新的region中，因此G1可以看成是宏观上标记整理，微观上标记复制</p><p>当eden区满的时候会触发一次STW young GC</p><p>而当老年代达到一定阈值的时候，就会触发一次mix GC</p><p>G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的 Full GC</p><h4 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401211323146.png" alt="image-20240121132314060" style="zoom: 25%;" /><ul><li>前面四字节是固定的，称之为魔数：”CAFEBABE”</li><li>minor version和major version分别是Java的大小版本号</li><li>后面的结构基本都是统一的：xxx的个数 + xxx数组，比如常量池个数+常量池数组</li><li>Constant Pool：常量池</li><li>Access Flag是访问空值，比如public、volatile、final等</li><li>This class和Super Class分别是当前类和父类的索引，这一项没有数组的原因是：Java中是单继承的，因此只会有一个父类</li><li>Interface：接口信息；Field：字段信息；Method：方法信息</li><li>Attribute：在上面三个的数组中其实包含了Access Flag、name、相关Attribute数组。除此之外，用户还可以自定义其他的属性，那么就会保存在这个地方</li></ul><h4 id="类加载过程（要区别于对象创建）"><a href="#类加载过程（要区别于对象创建）" class="headerlink" title="类加载过程（要区别于对象创建）"></a>类加载过程（要区别于对象创建）</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401211339833.png" alt="image-20240121133951788" style="zoom: 33%;" /><p>一个类的加载过程可以分为：加载-&gt;连接-&gt;初始化  三大部分</p><p>其中，连接又可以拆分为：验证-&gt;准备-&gt;解析 三个部分</p><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>类加载会通过类的全限定名获取二进制字节流，然后将其转换到方法区的运行时数据区中，并且会在内存中生成一个Class对象</p><p>类加载可能和连接阶段有部分重叠，比如验证中的字节码文件验证，也就是说类加载还没有完成，连接可能就开始了</p><h6 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h6><p>连接分为三个步骤</p><ul><li><p>验证：验证字节码文件、验证符号引用、验证语法语义等</p></li><li><p>准备：在准备阶段会给类分配内存空间并设置初始值</p><p>这里分配的空间是类的静态变量，而且初始值全都设置为0，除非是static final修饰的字面量，才会在这里赋值</p></li><li><p>解析：将符号引用转化为方法区中的直接引用，比如方法符号引用转化为方法表中的偏移地址</p></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>初始化我理解的就是Class类的初始化，这里就会给类变量真正的初始化了，而不是使用0的默认值</p><p>并且只有主动使用该类才会去初始化，否则执行到连接就会停止，直到使用该类</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>Java有三个默认的类加载器：BootstrapClassLoader、ExtensionClassLoader、AppClassLoader</p><p>除了BootStrapClassLoader是用C++实现的不用被加载以外，其他只要是类就要被加载（包括这两个类加载器）</p><p>加载的时候会使用双亲委派机制，防止重复加载某个类</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位</p><p>一个进程可以拥有多个线程，在Java中多个线程共享进程的堆、方法区，但是拥有自己私有给的程序计数器、栈结构</p><p>在JDK1.2之前，Java的线程属于用户线程，之后采用的是内核线程，可以实现多核运行</p><p>在Java中，进程之间是独立的，不会互相影响，但是线程之间由于共享堆以及方法区，多个线程之间很有可能会互相影响</p><p>此外，在单核CPU下，使用多线程并不一定可以提高效率</p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile可以保证变量的可见性，但是无法保证变量更新的过程中的原子性</p><p>因为他只会保证每次使用的时候会去主存中获取值，但是更新操作时先读后改再写回，这三步不是原子的</p><p>此外volatile可以禁用指令重排序，他不允许在他之前的写操作延迟执行，也不允许在他之后的读操作超前执行</p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><p>假设没有人来竞争，会直接执行相关操作然后试图更新，发现被抢占了就会自旋</p><p>乐观锁的实现方式有版本号机制和CAS操作</p><p>对于CAS操作，它是OS提供的一个原子指令，compare和swap两个操作是原子的不会被打断。但是CAS有ABA问题，最终解决方式还是用到了版本号机制</p><h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><p>假设有人来竞争，每次需要资源的时候会先获得锁，否则不会执行相关操作</p><p>比如synchronized、Reentrantlock、RedissonLock等都是悲观锁</p><h4 id="synchorized原理"><a href="#synchorized原理" class="headerlink" title="synchorized原理"></a>synchorized原理</h4><p>被synchronized修饰的代码块，会借助OS提供的monitorenter、monitorexit两个指令来实现</p><p>monitorenter会获取一个monitor对象锁，并且锁的计数器加一</p><p>后面monitorexit的时候就会释放锁，计数器减一</p><p>但是被synchronized修饰的方法并不是靠这个，而是有一个方法的访问属性表明它是一同步方法，然后执行相应的方法调用</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>每个Thread类都有一个ThreadLocalMap类，这是属于线程的私有资源</p><p>它是一个hashMap，key是一个ThreadLocal对象，value就是该线程保存的值</p><p>当ThreadLocal需要set的时候，会通过当前线程获取当前线程的ThreadLocal，然后用this作为key，来set一个value</p><p>此外，他和ArrayList一样也是懒加载的</p><h6 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h6><p>由于ThreadLocalMap中的key是弱引用，而value是强引用，当他的key没有外部强引用引用的时候就会被GC回收</p><p>此时value是强引用不会被回收，这就会导致内存泄漏</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>当队列为空且核心线程池不满的时候，会直接使用核心线程池中的线程执行任务</p><p>然后，如果核心线程池加满了，但是队列还没有满，那么就放到队列中阻塞</p><p>如果队列也满了，那么就会开启非核心线程池，使用非核心线程执行</p><p>再满了，就会执行饱和策略了</p><p>此外，设置的存活时间是针对于非核心线程的，如果非核心线程在设置的存活时间中一直没有任务，就会被释放</p><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>AQS是一个抽象队列同步器，用于同步使用</p><p>他将共享资源抽象为state，然后使用CAS操作来更新state，保证原子性并且表达资源的占有情况</p><p>并且它使用一个双向队列，来保存阻塞线程</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><p>四层模型分别为：应用层、传输层、网络层、网络接口层</p><ul><li><p>应用层：主要提供两个终端之间的应用数据传输，这里的应用数据格式是异构的，不同的应用层协议都是不同的</p></li><li><p>传输层：为应用多种多样的协议提供统一的数据传输服务。</p><blockquote><p>从代码角度来说，只需要调用tcp.send(msg)，而不是每个应用层协议都需要写一个send，如http.send(msg)</p></blockquote></li><li><p>网络层：传输层只负责src send to dst，但是具体怎么送到，走哪几个路由器，是网络层的任务</p></li><li><p>网络接口层：这里其实包含的是数据链路层和物理层，这负责的是每一段链路上数据的正确送达</p></li></ul><p>分层模型可以大大提高系统的灵活度，让每一层的实现都是独立的，分解原本网络传输问题成多个小问题</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h6 id="从输入URL到页面展示的过程"><a href="#从输入URL到页面展示的过程" class="headerlink" title="从输入URL到页面展示的过程"></a>从输入URL到页面展示的过程</h6><p>浏览器会根据输入的URL通过DNS协议解析出IP地址</p><p>然后主机会使用自己的随机临时端口和服务主机的80端口连接，这其中会建立一个TCP连接</p><p>服务器接收到请求后会处理请求，并返回响应结果</p><p>浏览器接收到后会渲染页面</p><h6 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h6><ul><li>HTTP的端口号是80，HTTPS的端口号是443</li><li>HTTP协议中传输的内容都是明文，没有加密，而HTTPS工作与SSL&#x2F;TLS之上，传输的内容均被加密过</li></ul><h6 id="HTTPS的加密问题"><a href="#HTTPS的加密问题" class="headerlink" title="HTTPS的加密问题"></a>HTTPS的加密问题</h6><p>HTTPS工作在SSL&#x2F;TLS之上，传输的内容使用的是对称加密，但是对称加密的密钥使用的是数字证书的非对称加密</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>个人笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
