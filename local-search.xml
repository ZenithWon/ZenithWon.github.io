<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM详解</title>
    <link href="/2024/06/14/2024-06-14-JVM%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/14/2024-06-14-JVM%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="初步认知"><a href="#初步认知" class="headerlink" title="初步认知"></a>初步认知</h2><p>JVM是一个程序集虚拟机，它可以运行一系列虚拟的计算机指令，这个指令就是我们常说的字节码</p><p>当然，JVM不仅仅就是运JAVA程序，它其实是一个虚拟机，你只要提供的字节码是满足JVM定义的规范那就可以运行</p><p>也就是说对于任意一个语言，我们只需要设计一个编译器将该语言编译成JVM定义的字节码规范，就可以直接在JVM中运行，比如Scala、Kotlin等</p><h3 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h3><p>JVM的指令集是基于栈操作的，比如你执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> k=i+j;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这是换成C语言来做，他的编译是基于寄存器的，因此就直接使用mov指令+add指令就可以完成了</p><p>但是JVM的字节码是基于栈来实现的，最通过javap反编译的结果是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: iconst_2<span class="hljs-comment">//常量2</span><br><span class="hljs-number">1</span>: istore_1<span class="hljs-comment">//存到栈里</span><br><span class="hljs-number">2</span>: iconst_3<span class="hljs-comment">//常量3</span><br><span class="hljs-number">3</span>: istore_2<span class="hljs-comment">//存到栈里</span><br><span class="hljs-number">4</span>: iload_1<span class="hljs-comment">//读取</span><br><span class="hljs-number">5</span>: iload_2<span class="hljs-comment">//读取</span><br><span class="hljs-number">6</span>: iadd<span class="hljs-comment">//加</span><br><span class="hljs-number">7</span>: istore_3<br><span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>虽然这个和C语言的汇编比起来指令更多，但是<strong>基于栈的架构可移植性更强、指令集更小</strong>，不需要考虑计算机硬件（比如寄存器）的问题，因为栈是基于内存的</p><p>但是相比寄存器而言，毕竟是基于内存的栈，因此<strong>执行性能会差点</strong></p><h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><ul><li>JVM启动：通过bootstrapClassLoader创建一个初始类，这个类是由虚拟机完成的</li><li>JVM执行：就是执行一个java任务，当启动一个java程序的时候，其实就是启动了一个JVM进程</li><li>JVM退出：正常退出、出现错误或者异常导致退出、调用System.exit()方法</li></ul><h3 id="JVM的整体架构"><a href="#JVM的整体架构" class="headerlink" title="JVM的整体架构"></a>JVM的整体架构</h3><p>JVM的组成可以分为三大部分，分别是：<strong>类加载器</strong>、<strong>运行时数据区</strong>、<strong>执行引擎</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152303592.png" alt="img" style="zoom: 50%;" /><ul><li><p>类加载器：就是将.class文件加载到内存中，生成一个klass对象，放在方法区中</p></li><li><p>运行时数据区：这个就是JVM的内存结构，这个一定要和JMM区分开，JMM是屏蔽硬件而定义的一个规范</p><blockquote><p>因为JVM是一个虚拟机，因此我们需要在这里面屏蔽掉底层操作系统的异构性，所以定义了一个叫做JMM的内存规范，它提供了多线程情况下的内存访问方式，抽象出了主内存和工作内存两大空间，并且还提供了类似volatile、synchronized这些关键字用于线程同步</p></blockquote></li><li><p>执行引擎：这个就是执行字节码，这期间还涉及到了垃圾回收和即时编译（JIT）</p></li></ul><p>如果学完整个JVM，最终的JVM架构图应该是这样的：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152303132.png" alt="img" style="zoom:40%;" /><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190210050.png" alt="preview" style="zoom: 80%;" /><p>类加载过程总的氛围三个阶段：Loading、Linking、Initialization，其中Linking阶段还分为为三个子阶段：Verifying、Prepare、Resolve</p><p>这里一定要把这里的Loading阶段的加载和类加载器的加载区分开，Loading阶段只是类加载的一个阶段，但是它只是恰好也叫加载</p><p>类加载器的作用：</p><ul><li>加载class文件到内存中，其中class文件有特定的开头文件标识（魔数 CAFEBABE）。文件开头是否合法的验证就是在Linking阶段的Verify</li><li>ClassLoader只负责加载文件，他不会分析代码，具体执行是否会出异常或者错误，是由执行引擎决定的</li><li>类加载器会把加载后的类信息放到方法区中，方法区中还会放运行时常量池，其实这也是从字节码文件映射过来的</li></ul><h3 id="Loading阶段"><a href="#Loading阶段" class="headerlink" title="Loading阶段"></a>Loading阶段</h3><p>这里一共会做三件事：</p><ol><li>通过一个类的全限定名读取该字节码文件，并且是以二进制字节流的形式读取</li><li>将这个字节流代表的静态存储结构转化为运行时数据结构</li><li>生成一个Class对象，作为方法区类信息的访问接口，包括反射也是通过这个Class对象实现的</li></ol><h3 id="Linking阶段"><a href="#Linking阶段" class="headerlink" title="Linking阶段"></a>Linking阶段</h3><p>链接阶段一共分为三个子阶段：验证、准备、解析</p><ul><li><p>验证阶段：确保字节流信息是符合JVM要求的，不会危害虚拟机正常运行，比如文件开头是否为CAFEBABE</p></li><li><p>准备阶段：为类变量分配内存，同时将类的static变量全部先覆盖为零值</p><p>就跟对象创建过程一样，在执行构造函数之前先全部设置为零值。类初始化也是如此，它会现在这全部初始化为零值，然后在初始化阶段，执行编译字节码文件时候组装好的<code>&lt;clinit&gt;</code>函数，初始化类变量</p><blockquote><p>但是对于<strong>final static修饰的字面量</strong>，是在编译阶段就已经初始化好了，因此在准备阶段是直接赋值的，而不是先覆盖为零值</p></blockquote></li><li><p>解析阶段：将常量池中的符号引用转换为直接引用，<strong>这个我目前还不清楚，等看到后面字节码我再来分析</strong></p></li></ul><h3 id="Initialization阶段"><a href="#Initialization阶段" class="headerlink" title="Initialization阶段"></a>Initialization阶段</h3><p>在Linking阶段已经讲过了，初始化阶段其实就是执行<code>&lt;clinit&gt;</code>函数，这个要和构造函数<code>&lt;init&gt;</code>区分开，clinit函数是类静态变量的构造函数</p><p><strong>它不需要我们来写，是由编译器自动收集类信息来组装出来的</strong>。也就是说，如果这个类没有静态变量，那就收集不到信息，就不会有clinit函数！</p><blockquote><p>如果该类有父类，那么父类的clinit方法会先于子类的ciinit方法执行，因为加载子类之前会先加载父类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        a=<span class="hljs-number">2</span>;<br>        b=<span class="hljs-number">2</span>;<br>        System.out.println(b);<span class="hljs-comment">//如果加上这行代码就会报错，因为先声明再调用</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，编译器就会收集这些信息，然后最终clinit函数就是：</p><p><code>a=1-&gt;a=2-&gt;b=2-&gt;b=1</code>，那为什么b的赋值可以在声明之前呢？</p><p>因为Linking的Prepare阶段已经分配内存并初始化为零值了，因此可以直接赋值，但是无法调用</p><p>此外，对于<code>&lt;init&gt;</code>方法，就是类的构造方法，如果你没有写就会有一个默认的无参构造方法，但是只要你写了，那个默认的无参构造方法就没有了。</p><p><strong>也就说一个类可能没有clinit方法，但是一定至少有一个init方法</strong></p><p>并且在clinit方法执行的时候，由于方法区是线程共享的，因此它在执行的时候会加锁，这样可以保证<strong>clinit操作只会执行一次</strong></p><blockquote><p>类的被动加载，不会执行Initialization阶段；只有主动加载才会！</p></blockquote><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM定义了两种类型的加载器：引导类加载器和用户自定义的加载器，其中JVM把用户自定义的加载器定义为继承ClassLoader抽象类的加载器都叫用户自定义加载器</p><p>因此，JVM中的类加载器只有<strong>BootstrapClassLoader和其他</strong>，即使是ExtClasLoader和AppClassLoader，也是继承自ClasssLoader抽象类的，因此也属于用户自定义的加载器</p><blockquote><p>BootstrapClassLoader加载器是C语言编写的，也就是说你直接打印它，出来的是null</p><p>比如你打印AppCLassLoader的类加载器是谁，打印出来的就是null了，并不是说它没有，而是它的ClassLoader是BootstrapClassLoader</p></blockquote><p>下面我们一个个来讲一讲JVM定义的几个类加载器吧</p><ol><li><p>BootstrapClassLoader</p><p>可以说BootstrapClassLoader就是JVM的一部分，使用C++编写，<strong>不继承ClassLoader抽象类</strong></p><p>主要用来加载java的核心类库，比如sun、java开头的类，像List、String、JUC的类都是BootstrapClassLoader加载的</p></li><li><p>ExtClassLoader</p><p>继承自ClassLoader，使用java语言编写的，由BootstrapClassLoader加载，父类加载器也是</p><p>这个加载器用于加载java.ext.dirs下的类库，或者用户编写的类放在jre&#x2F;lib&#x2F;ext目录下，也会用这个加载器加载</p></li><li><p>AppClassLoader</p><p>继承自ClassLoader，使用java语言编写的，由BootstrapClassLoader加载，父类加载器是ExtClassLoader</p><p>这个加载器负责加载classPath下的的类，也是我们用户编写的类的默认加载器</p></li></ol><p>那既然都有这三个加载器了，为什么还需要我们自定义加载器呢？</p><ul><li>隔离加载类，防止同一个包名发生冲突</li><li>修改类的加载方式：比如加载来源（从数据库加载、网络加载）；防止源码泄漏，在加载时候解密</li></ul><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>JVM对class文件的使用是按需加载的方式，也就说，如果整个JVM进程中没有使用到这个class，那就不会加载，而加载某个类的时候，使用的双亲委派机制</p><p>具体来说：</p><ul><li>就是把类加载的任务先委派给parent执行，如果parent无法加载才会由当前加载器来加载。</li><li>其中，parent是ClassLoader定义的，用户自定的时候可以设置该ClassLoader的parnet是谁</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152307708.png" alt="img" style="zoom:67%;" /><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li><p>这样可以保证java核心的API不会被篡改，保证程序的稳定性，不然用户自己定义一个java.lang.String，如果不是双亲委派机制，那直接由AppClassLoader加载，以后所有的String都是用户自定义的String了</p><p>但是有了双亲委派机制，可以保证java核心类库的东西都由BoostrapClassLoader加载，而BootstrapClassLoader是JVM定义的，这样保证了一定的封闭性</p></li><li><p>同时，双亲委派机制可以保证类不会重复加载，低及加载器不会在高级加载器之前加载类</p></li></ul><p>其实，保证java核心类库有两个方面：</p><ul><li>首先，核心类库只由BootstrapClassLoader加载，保证核心类库不会歧义</li><li>其次，如果用户自定义了一个java.lang的类，但是核心类库中没有，BootstrapClassLoader会拒绝加载，保证BootstrapClassLoader不受到攻击</li></ul><blockquote><p><strong>这样才能形成一个闭环，核心类由自己人加载，自己的加载器只加载自己人</strong></p><p>这个其实也是java的<strong>沙箱安全机制</strong>的一个组件，保证核心类库不会被破坏</p></blockquote><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406152307442.png" alt="img" style="zoom: 50%;" /><p>这就是java运行时数据区的完整架构图：</p><ul><li>两个栈区：本地方法栈和虚拟机栈，其中虚拟机机栈很重要，这两个栈都是<strong>线程私有</strong>的</li><li>程序计数器：PC计数器，也是<strong>线程私有</strong>的</li><li>堆区：分为eden区、survivor区、old区等，这个是存放对象的地方，是<strong>线程共享</strong>的</li><li>方法区：JDK1.8以后从堆中移出来作为元空间，以前是放在堆中作为永久代，<strong>线程共享</strong></li><li>JIT编译产物：JIT会把热点代码编译好，不用JVM解释执行，那么编译的产物就放在这里</li></ul><p>Java有一个Runtime对象，这个我们就可以理解为是运行时数据区，这是一个单例，一个JVM进程只有一个</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>在这里，我们需要明确一点，这里的程序计数器虽然英文名称之为PC register，但是他并不是CPU中的那个物理PC寄存器，而是JVM的一个抽象，因此我们还是叫他程序计数器</p><p>程序计数器是放在内存里面的，由于一个线程只有一个方法正在运行，因此它指向的就是当前方法执行的JVM指令的地址，如果是native方法，则为undefined</p><p>当前JVM指令执行完后，就会更新PC为下一条指令的地址，由于执行引擎只会操作当前栈帧，因此程序计数器指向的地址就是当前栈帧中的字节码地址，不需要考虑指令index的歧义</p><h3 id="虚拟机栈概述"><a href="#虚拟机栈概述" class="headerlink" title="虚拟机栈概述"></a>虚拟机栈概述</h3><p>在JVM中，栈是运行时的单位，堆是存储单位，这个要分清楚。栈解决的是程序运行时问题，而堆解决的是数据存储的问题</p><p>而虚拟机栈，就是把每一个方法当作一个栈帧保存下来，保存方法的局部变量、部分结果，并参与方法的调用和返回</p><p>每个线程在创建的时候，都会创建一个虚拟机栈，其中每一个栈帧（stack frame），对应着一次次的Java方法调用，也就说栈顶就是当前运行的方法</p><p>而且相比于程序计数器，栈是有可能出现异常的，但是它不会有GC，简单的来说会出现两种异常：</p><ul><li>如果栈内出现溢出，比如无限循环的递归等，就会出现<code>StackOverFlowError</code></li><li>如果线程创建过多，导致内存无法为新线程分配栈，就会出现<code>OutOfMemoryError</code></li></ul><h4 id="栈的运行原理和存储结构"><a href="#栈的运行原理和存储结构" class="headerlink" title="栈的运行原理和存储结构"></a>栈的运行原理和存储结构</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170033580.png" alt="image-20240617003344506" style="zoom: 50%;" /><p>每个线程都有自己的栈，在栈内是以<strong>栈帧</strong>为基本单元存储的，而栈帧又是一块内存区域，里面维护着执行方法的各种数据信息，而执行引擎执行的字节码只会对当前栈帧操作</p><p>如果当前方法调用了其他方法，那么在上层栈帧返回之前会将执行结果传给底下的栈帧，然后再弹出</p><blockquote><p>要注意的是，方法的返回分为两种：正常的return；抛出异常且未处理。这两种方式都会导致栈帧弹出</p><p>也就是说<strong>往上抛出异常，其实就是出栈前返回的数据是异常类</strong>，如果最终到main函数都没有try catch，那main函数就会直接终止，因为你已经走到最后一个栈帧了</p></blockquote><p>此外，栈帧的内部还分为以下五个部分</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170055170.png" alt="image-20240617005513122" style="zoom:67%;" /><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><h4 id="存放内容"><a href="#存放内容" class="headerlink" title="存放内容"></a>存放内容</h4><p>局部变量表存放的就是，该方法的参数、方法体内的局部变量、returnAddress类型等，也就是说<strong>局部变量只存放基本数据类型和对象引用（指针）</strong></p><p>并且局部变量表的大小是在编译的时候就已经确定好了，这个是预编译好的最大的局部变量表的大小，不一定真正运行的时候，一定就是那么大，因为程序运行中会有报错、if&#x2F;else分支等操作</p><p>在局部变量表中，最基本的存储单元是slot，除了double和long占两个slot外，其他的数据类型如byte、char、boolean、对象引用（开了指针压缩）等都是会转换为int类型，在表中占一个slot</p><blockquote><p>当前方法如果不是static方法，那局部变量表的第一个index0的位置会<strong>放一个this引用</strong>，然后剩下的才会往后放到表中</p></blockquote><h4 id="长度以及内容的优化"><a href="#长度以及内容的优化" class="headerlink" title="长度以及内容的优化"></a>长度以及内容的优化</h4><p>字节码中的局部变量表很有意思：</p><ul><li><p>如果一个局部变量在代码块中只是声明了，但是没有用到，那么局部变量表就不会有这个，但是字节码中的局部变量表的最大长度会算上它，而且还会根据if else来取最大值，这个十分有意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如下面这段代码的max length是3：i，this，j或k，而局部变量表只显示：i和this，因为只是声明没有使用。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170150416.png" alt="image-20240617015041386" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170150575.png" alt="image-20240617015013519" style="zoom: 50%;" /><p>但是只有声明没有使用是代码块中，你看i也只是声明（<code>int i=0;</code>可以，但是<code>int i;</code>仍然不会写到局部变量表中）没有使用，但是它不在代码块中，因此还是会有</p></li><li><p>此外，局部变量表还有复用的情况，一旦发现有局部变量走出作用域，正好作用域后面声明了一个新的局部变量，那么这两个变量就会使用同一个slot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        i=j+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        i=k+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> h=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码的max length以为是4？，其实还是3，因为h和k、j的作用域是互斥的，然后h和j是if&#x2F;else互斥的，因此最后<strong>其实h、k、j是可以共用一块区域的</strong>。如下：全是用的slot2：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406170154711.png" alt="image-20240617015400667" style="zoom:50%;" /></li></ul><h4 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h4><ul><li>它和JVM调优比较密切</li><li>方法执行的时候，使用局部变量表完成方法传递</li><li>局部变量表中的引用变量作为GC的root节点</li></ul><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>每一个独立的栈帧除了有一个局部变量表以外，还有一个操作数栈</p><p>执行引擎会根据字节码，把一些数据压栈，或者取出栈中的几个数据进行计算，并将计算结果重新压栈。<strong>这也就是为什么执行引擎是基于栈的原因</strong></p><p>如果调用的方法有返回值，那么其返回值也要被压入栈中</p><p>操作数栈和局部变量表一样，也会在编译期间就已经决定了大小，但是运行期间内部的数据都会一直在变化</p><h4 id="操作数栈和局部变量表的关系"><a href="#操作数栈和局部变量表的关系" class="headerlink" title="操作数栈和局部变量表的关系"></a>操作数栈和局部变量表的关系</h4><p>在方法调用也就是栈帧刚创建的时候，操作数栈和局部变量表都是空的，执行引擎会根据字节码对操作数栈操作</p><p>那么局部变量表是如何变化的呢？</p><ul><li>执行引擎会现根据字节码把数据读到栈里，然后调用<code>store</code>指令出栈并将结果存入局部变量表</li><li>当需要局部变量表的数据的时候，会先依次将要操作的变量通过<code>load</code>指令读到栈里，再执行操作（如add）</li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>目前看来，就是当调用一个方法的时候，需要将方法的符号引用转化为运行时常量池的直接地址</p><p>那么动态链接指向的就是方法区中，运行时常量池该方法符合引用的真实地址</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406172241735.png" alt="img" style="zoom: 50%;" /><h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>这个看完字节码再说吧，我现在也搞不明白</p><p>但是有一点要搞明白，就是栈帧单元中有一个方法返回地址的字段，他记录的就是上一个栈帧弹出后，底下栈帧对应的方法应该从哪行字节码运行</p><p>我个人觉得方法返回地址，应该是方法调用创建栈帧的时候把当前程序计数器的值保存到被调用方法的栈帧中，然后再将程序计数器的值改为被调用方法的入口字节码地址</p><p>方法返回地址只针对于正常return的情况，发生异常处理不一样，我们后面再看</p><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>运行时数据区里面有一个本地方法栈，所谓的本地方法调用的就是C++编写的方法</p><p>为什么要使用本地方法呢？</p><ul><li>与Java环境外交互，让我们无需去了解Java应用以外的繁琐细节</li><li>与操作系统交互，为了提高程序执行效率，比如线程的start方法，底层就调用了native的<code>start0</code></li></ul><p>既然使用了本地方法，运行时数据区就有一块本地方法栈，来供本地方法使用</p><p>本地方法栈和虚拟机栈差不多，也会出现StackOverflowError和OOM，但是不会出现GC</p><h2 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h2><p>堆是运行时数据区的一部分，但是由于堆的内容很多很重要，我们这里把堆单独作为一大节</p><p>以下是堆、栈、方法区三者的关系：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406180140353.png" alt="image-20240618014058269" style="zoom:50%;" /><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>堆在JVM进程中是唯一的，一个JVM进程只有一个运行时数据区，也只有一个堆</p></li><li><p>堆的空间是固定的，在JVM进程创建的时候，堆的大小就已经确定下来了</p><ul><li>堆大小的JVM参数有两个分别是<code>-Xms</code>（堆初始大小）和<code>-Xmx</code>（堆最大大小）</li></ul></li><li><p>堆是GC的主要区域，方法区也会有GC但是比例不大，GC又是JVM调优主要的关注对象</p></li></ul><p>堆的具体内存结构如下，要注意的是JVM参数设置的堆空间大小只有新生代和老年代（JDK7和JDK8都是）</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406180150099.png" alt="image-20240618015047008" style="zoom: 40%;" /><p>以上是堆的基本理论，但是还有几个平时不会注意的问题：</p><ul><li>堆空间不一定物理上连续，但是逻辑上是连续的</li><li>所有线程共享Java堆，但是不是共享所有的堆空间。堆中可能还会划分一小块区域，作为线程的<strong>私有的堆缓冲区TLAB</strong></li><li>不是所有的对象一定会在堆中分配内存，如果逃逸分析后没有逃逸出去，可以在栈上直接分配</li><li>堆内存的实际可用空间是小于JVM参数分配的空间的，因为<strong>S0和S1区只会有一个使用</strong></li></ul><h3 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h3><p>Java对象可以被分为两类，分别是生命周期较短的瞬时对象和生命周期较长的对象</p><p>由于生命周期较长的对象一般不会被GC，因此<strong>为了优化GC性能</strong>，JMV把堆空间分成了新生代和老年代。</p><p>其中新生代可以进一步分为Eden区、Survivor0区、Survivor1区。新生代可以经常GC，但是老年代原则上应该GC少点</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406182334191.png" alt="image-20240618233406091" style="zoom:50%;" /><p>新生代和老年代的大小可以通过<code>-XX:NewRatio</code>参数来修改，他代表老年代和新生代大小的比例。默认是2，代表老年代是新生代的2倍，并且此参数一般不会修改</p><p>同样新生代中的Eden区和Survivor区也可以通过参数<code>-XX:SurvivorRatio</code>来调整，但是要注意的是Survivor区有两个，配置的比例是Eden区和其中一个Survivor区的比例。也就是说如果设置为8，那么就表示Eden区占8&#x2F;10，而另外两个Survivor区分别占1&#x2F;10</p><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><p>首先，我们抛开特殊情况不谈，先来说一说<strong>基本流程</strong>：</p><ul><li>当一个对象创建的时候，会先放到Eden区</li><li>如果Eden区放不下，那么<strong>在Eden区创建对象之前</strong>，会做下面几件事：<ul><li>做一次YonugGC，清理掉Eden区Survivor区的垃圾，同时新生代所有对象GC年龄（存在对象头中）<code>+1</code></li><li>将原本Eden区、from区存活下来的对象放到to区，然后to变成下次的from，from变成下次的to</li><li>超过年龄阈值（默认为15，可通过<code>-XX:MaxTenuringThreshold</code>参数设置）的对象直接转移至老年代</li></ul></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190052195.png" style="zoom:67%;" /><p>这里要注意的是，<strong>Survivor区是被动GC的</strong>，只有Eden区满了才会GC整个新生代，Survivor区不会主动GC</p><p>上述是基本流程，但是仍然会有一些<strong>特殊情况</strong>：</p><ul><li><p>Young GC后，Eden区还是放不下</p><p>那就说明是超大对象，因此会直接往Old区放，如果Old区放不下就会执行Full GC</p></li><li><p>Young GC后，往to区放的时候放不下</p><p>一般来说，Young GC的时候都会往to区放，首先会看是否到年龄阈值，到了就放到old区</p><p>然后如果没到，但是往to区放的时候发现放不下，那也会直接放到old区</p></li></ul><p>因此最终，对象分配的大致流程就是下面这样：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190100664.png" alt="image-20240619010000561" style="zoom: 40%;" /><p>此外，JVM还提供了几个比较重要的晋升老年代的规则：</p><ul><li><p>大对象直接进入老年代</p></li><li><p>Survivor区晋升老年代，还有一种动态的年龄判断：这个不用等到maxTenuringThreshold才去晋升，而是那个动态年龄阈值（排序后的空间百分比）</p></li></ul><h3 id="空间担保机制"><a href="#空间担保机制" class="headerlink" title="空间担保机制"></a>空间担保机制</h3><p>在Minor GC之前，其实还有一次判断：</p><ul><li>如果发现新生代大小比老年代剩余区域小，那就说明即使Minor GC每一个垃圾且全部放到老年代都能放下，那么就说明本次Minor GC安全，可以执行</li><li>如果发现放不下且开启空间担保（<code>-XX:HandlerPromotionFailure=true</code>）则：<ul><li>要是老年代可用空间，大于以前每次MinorGC晋升到老年代空间的平均值，则进行一次有风险的Minor GC</li><li>否则直接Full GC（没开启，或者小于平均值）</li></ul></li></ul><blockquote><p>空间担保机制在JDK7以后强制开启，即使保留了<code>-XX:HandlerPromotionFailure</code>参数，但是不会使用</p></blockquote><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p>JVM的GC的时候并不是每次都会对整个堆空间GC，其实一共有三种方式：Minor GC、Major GC、Full GC</p><p>在HotpotJVM中，GC可以大致分为两种：整堆GC和部分GC</p><ul><li><p>整堆GC：Full GC，会对<strong>整个堆空间+方法区</strong>做一次GC，包括所有的新生代和老年代</p><p>因此老年代空间不足和方法区空间不足，都会触发Full GC</p></li><li><p>部分GC：Minor GC（Young GC）和Major GC（Old GC），这里一定要区别Major GC和Ful GC</p><ul><li>Minor GC是针对整个新生代，且只会由Eden区满了后主动触发</li><li>Major GC是针对整个老年代，但是目前<strong>只有CMS会有Major GC</strong></li><li>上述混合就是Mixed GC，这个是整个新生代+部分老年代，这个目前<strong>只有G1有Mixed GC</strong></li></ul></li></ul><h3 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h3><p>由于堆是线程共享的区域，因此当多个线程同时创建对象的时候就会出现操作同一块内存的线程不安全问题</p><p>为了解决这个问题，简单粗暴的解决办法就是加锁来实现对象创建，但是这会大大降低JVM性能</p><p>所以TLAB就出现了，它会<strong>在Eden区为每个线程分配一块私有区域</strong></p><blockquote><p>当线程把这块TLAB用掉后，就会归还给Eden区作为共享区域，然后重新分配TLAB区域</p><p><strong>分配TLAB的时候还是会CAS，因为这个时候同样也是线程不安全的</strong></p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406190148915.png" alt="image-20240619014834807" style="zoom: 40%;" /><p>但是，TLAB实际上很小，如果对象占用空间大于TLAB大小，那么还是会通过<strong>CAS</strong>的方式去共享区域分配内存</p><h3 id="堆空间的JVM参数"><a href="#堆空间的JVM参数" class="headerlink" title="堆空间的JVM参数"></a>堆空间的JVM参数</h3><p>首先要说的是对于<code>-XX:-啥啥啥</code>，由于前面是减号，因此表示禁用某个功能</p><p>相反对于<code>-XX:+啥啥啥</code>，前面是加号，因此表示开启某个功能，前面没有符号默认是加号</p><ul><li><code>-Xms</code>、<code>-Xmx</code>、<code>-Xmn</code>：堆空间初始大小、堆空间最大大小、新生代大小</li><li><code>-XX:NewRatio</code>、<code>-XX:SurvivorRatio</code>：老年代和新生代的比值、Eden和Survivor的比值</li><li><code>-XX:MaxTenuringThreshold</code>：晋升Old区的年龄阈值</li><li><code>-XX:+PrintGCDetails</code>、<code>-XX:PrintGC</code>：打印GC详细日志、打印GC简略日志</li><li><code>-XX:HandlerPromotionFailure=true</code>：开启空间担保</li></ul><h3 id="堆与逃逸分析"><a href="#堆与逃逸分析" class="headerlink" title="堆与逃逸分析"></a>堆与逃逸分析</h3><p>Hotspot编译器可以通过逃逸分析，分析出对象是否只在本方法内使用</p><p>如果发现没有逃逸出去，则会<strong>考虑将对象分配在栈上</strong>，因此在开发中能定义局部变量就定义局部变量</p><p>其实逃逸分析，不仅仅只是对堆优化，它可以做到很多好处：</p><ul><li><strong>栈上分配</strong>：经过逃逸分析后发现对象没有逃逸，则可以考虑不在堆中分配对象，而是直接分配在栈上</li><li><strong>同步省略</strong>：如果一个对象只会在一个线程中被访问到，那么这个对象就可以不用考虑同步了，即<strong>锁消除</strong></li><li><strong>标量替换</strong>：标量指的就是基础数据类型，如果发现一个对象没有逃逸出去，则可以将成员变量拆出来，分成多个基础数据类型放到栈上</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈、堆、方法区的交互"><a href="#栈、堆、方法区的交互" class="headerlink" title="栈、堆、方法区的交互"></a>栈、堆、方法区的交互</h3><p>这三个是运行时数据区最重要的结构了，那么这三个在程序运行中是如何交互的呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406192323877.png" alt="image-20240619232327759" style="zoom:50%;" /><p>大概交互关系就是这样的了，栈中放的对象引用，堆中放的是对象实体，其中对象实体有一个标注该对象类型的指针，指向方法区中对应的对象类型数据块</p><p>方法区和堆一样，也会GC（JDK8并没有强制要求，但是Hotspot实现了），也会OOM，也是线程共享的</p><p>它逻辑上是堆的一部分，但是需要特殊对待，当JVM加载了太多的类，就会出现方法区OOM错误</p><h3 id="Hotspot中的方法区"><a href="#Hotspot中的方法区" class="headerlink" title="Hotspot中的方法区"></a>Hotspot中的方法区</h3><p>对于HotSpot虚拟机来说：</p><ul><li><p>JDK7以前的方法区放在堆中，定义为永久代，大小可用<code>-XX:PermSize=100m</code>，<code>-XX:MaxPermSize=100m</code>设置</p></li><li><p>JDK8以后方法区从堆移出来，定义为元空间，大小可用<code>-XX:MetaspaceSize=100m</code>，<code>-XX:MaxMetaspaceSize=100m</code>设置</p></li></ul><p>因为永久代是放在堆中的，使用的是JVM内存；而元空间从堆中移出来，直接使用<strong>本地内存</strong>（计算机的内存资源），因此永久代相比于元空间更容易OOM</p><h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><p>一般来说方法区存储的就是类型信息、域信息、方法信息、运行时常量池、静态变量、JIT编译缓存等信息</p><p>但是随着JDK版本的演变，还是会对里面的一些细节做了优化，比如字符串常量池从方法区移到堆中去了</p><ul><li><p>类型信息：class、interface、annotation、enum这些都是类型。需要存放的有：</p><ul><li>全限定名</li><li>父类是什么，但是对于interface、Object这两个来说没有父类</li><li>修饰符，比如public、abstract</li><li>实现的接口列表，按照定义类时候声明的顺序</li></ul><blockquote><p>java为单继承，因此类型信息中父类是字段，而接口是列表</p></blockquote></li><li><p>域信息：就是类中声明的成员变量，域信息会按照类中成员变量声明的顺序存储，包括：名称、修饰符、类型</p></li><li><p>方法信息：就是类中定义的方法，同也会按照声明顺序保存，同样也会保存名称、类型、修饰符</p><p>但是除了这些以外，还会保存方法的字节码、操作数栈和局部变量表的大小、异常表等等</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>在方法区中，除了类型信息（类信息、方法信息、域信息）以及JIT缓存以外，还有一个很重要的内容就是运行时常量池，这块部分重要到我把他单独拎出来讲</p><p>运行时常量池是和字节码文件中的常量池是对应的，类加载的时候会把字节码文件加载到方法区，这个时候就会读取类信息，并且把常量池读取到方法区生成运行时常量池</p><p>因此在了解运行时常量池之前我们需要搞清楚字节码中的常量池</p><h4 id="字节码中的常量池"><a href="#字节码中的常量池" class="headerlink" title="字节码中的常量池"></a>字节码中的常量池</h4><p>字节码中有一个常量池表，包括<strong>各种字面量和对类型、域、方法的符号引用</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406200118005.png" alt="image-20240620011828859" style="zoom: 40%;" /><p>看起来感觉很累赘的样子，为什么要搞这个东西？</p><p>字节码往往需要数据支持，比如方法的返回值、父类等等信息，这些不可能事先一股脑全写到字节码中，这样会造成字节码文件更大。因此，就使用常量池，当动态链接的时候会让这些引用指向真正的地方</p><h5 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>在每个类被加载后，就会为这个类生成一个运行时常量池，这个常量池就不再是符号引用了，而是指向的直接内存地址。</p><ul><li><strong>符号引用</strong>：类似常量池表中的CONSTANT_Class_info、CONSTANT_Fieldref_info这种东西，它实际上是用这样的常量代替了，因为还没有加载到内存，无法知道真正的内存地址</li><li><strong>直接引用</strong>：当被加载到内存，会根据不同的符号引用类型，解析程不同的符号引用，这其实就是连接阶段的解析过程做的事情。不同的符号引用会有不同的方式，比如：<ul><li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li><li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li><li>一个能间接定位到目标的句柄</li></ul></li></ul><blockquote><p>运行时常量池的内容并不是字节码中常量池确定好的，他虽然会加载字节码常量池的信息，但是在程序运行过程中，还会<strong>动态变化</strong>（<code>String.intern()</code>方法）</p></blockquote><h3 id="方法区的演变"><a href="#方法区的演变" class="headerlink" title="方法区的演变"></a>方法区的演变</h3><p>在说之前，需要明确一点：只有hotspot虚拟机有永久代；像Jrockit、J9这些只有元空间</p><p>那么HotSpot方法区到底是怎样变化的呢？</p><ul><li>JDK6及以前，用的永久代，并且字符串常量池、静态变量也放在永久代中</li><li>JDK7的时候，有永久代，但是字符串常量池、静态变量被拿出来了，放在了堆中</li><li>JDK8及以后，就从永久代转成直接内存的元空间了，但是<strong>字符串常量池和静态变量还是放在堆中</strong></li></ul><p>那为什么这就会有两个问题：</p><ul><li><p>为什么要从永久代到元空间呢？</p><p>要知道，永久代的内存大小是受JVM内存管控的，而元空间的内存使用的是直接内存和计算机内存资源挂钩</p><p>因此，永久代在设置大小的时候无法控制，而元空间满了的话就说明计算机内存不够用了，那也没有办法</p></li><li><p>为什么要把字符串常量池和静态变量放到堆中？</p><ul><li><p>首先，字符串会在程序运行中大量的缓存到常量池，很容易造成方法区空间不足造成OOM</p></li><li><p>其次，字符串常量应该被经常回收，而在方法区中只能通过full GC回收，因此转移至堆中</p></li></ul><blockquote><p>这里要注意的是，字符串常量池是放在堆中，但是静态变量是放在堆中Class对象的里面</p></blockquote></li></ul><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>Java虚拟机规范并没有强制要求JVM的方法区要做GC，但是HotSpot实现了方法区的GC</p><p>HotSpot虚拟机对方法区的GC主要是两个部分：常量池中废弃的常量以及不再使用的类</p><p>其中，废弃的常量回收很简单，就是不在引用了就直接回收，和对象的GC差不多</p><p>但是类的回收就很麻烦，需要满足下面<strong>三个条件</strong>：</p><ul><li>该类创建的所有实例（包括子类、实现类等），都被回收了</li><li>加载该类的加载器被回收了，基本只有自定义的加载器才会满足，很难</li><li>对应的Class对象没有被引用，即没有反射调用该类</li></ul><p><strong>到此，我们整个的运行时数据区就差不多了</strong>，最后我们应该能画出这样一个图出来：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406210006868.png" alt="image-20240621000559662" style="zoom: 33%;" /><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="从字节码看"><a href="#从字节码看" class="headerlink" title="从字节码看"></a>从字节码看</h4><p>当调用一个new方法的时候，会产生三个字节码：new、dup、invokespecial</p><ul><li>new：在堆中开辟一块内存，并给成员变量设置为零值</li><li>dup：开辟内存后，就会将对应的引用压栈，dup就是将栈顶的引用复制一份，因为其中有一个需要给构造方法用，用完就没了</li><li>invokespecial：调用构造方法</li></ul><h4 id="从执行流程来看"><a href="#从执行流程来看" class="headerlink" title="从执行流程来看"></a>从执行流程来看</h4><p>其实执行流程和字节码类似，就是按照字节码的三个指令来，但是会更加细化：</p><ol><li><p>查看new的类是否被加载，要是没加载就要读取字节码文件，走类加载的那三步流程</p></li><li><p>为对象分配内存，会先根据字节码计算所需空间的大小，分配有两种方法：</p></li></ol><ul><li><p>堆空间的内存是规整的，这就需要GC算法是标记-整理，那就拿一个指针记录空闲区域的起始地址</p></li><li><p>如果不规整，这就需要GC算法是标记-清除，那就需要维护一个空闲链表</p><p>当然，在分配内存的时候需要处理<strong>并发问题</strong>，同样也有两种方法：TLAB或者CAS</p></li></ul><ol start="3"><li><p>初始化分配的空间，就是设置为零值</p></li><li><p>设置对象头，也就是markword+classpointer，如果数组的话，会多一个length</p></li><li><p>执行构造函数</p><p>这里构造函数不仅仅就是你写的那个，他还会像clinit一样，收集成员变量、代码块的情况，在编译的时候也加到字节码里面去。比如下面的代码，最后的<code>&lt;init&gt;</code>方法字节码其实是id+name+account三个字段的赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-type">long</span> id=<span class="hljs-number">100L</span>;<br>    String name;<br>    Accout accout ;<br>    <br>    &#123;<br>        name=<span class="hljs-string">&quot;default name&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br>        account=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><blockquote><p>在说这个之前，我们要先讲讲Java的引用大小问题：</p><p>在64位的OS中一个指针的大小是8B的，但是Java默认开启了<strong>对象头指针压缩</strong>和<strong>成员变量对象指针压缩</strong>，压缩后的指针大小会从8B变成4B</p></blockquote><p>下面来聊一聊对象内存布局，我们以64bit的hotpot JVM为例：</p><p>对象内存布局分为两种，一个是普通对象，一个数组对象</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406032351484.png" alt="image-20240603235114382" style="zoom: 33%;" /><ul><li><p>一个对象分为三个部分：</p><ul><li><p><strong>对象头</strong>，包括markword、class pointer等</p><ul><li>markword，存储了hashcode、GC age等等，并且当成为锁对象后会重写markword（后面再说）</li><li>class pointer，指向方法区类元信息的指针（<strong>不是Class类！</strong>），标注它属于哪个类，由于开启指针压缩因此就是4B</li><li>数组对象会多一个数组长度信息</li></ul></li><li><p><strong>实例数据</strong>，存放数据的地方，但是如果这里有对象，那么就是指针的大小，由于默认开启了指针压缩，因此也是4B，<strong>数组的话就是所有数据按顺序堆叠起来</strong></p></li><li><p><strong>对齐</strong>，由于是64位的JVM，因此对齐按8B对齐</p></li></ul></li></ul><blockquote><p>注意：成员变量的long和Long占的字节分别是8B和4B</p></blockquote><h3 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h3><p>对象的访问方式一共有两种：直接访问和句柄访问。直接上图：</p><ul><li><p>句柄访问</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406210040767.webp" alt="img" style="zoom: 80%;" /></li><li><p>直接访问</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406210039514.webp" alt="img" style="zoom:80%;" /></li></ul><p>其中直接引用时hotSpot的实现，从对象头也可以看出来</p><p>因为句柄访问需要额外空间，并且还需要两次的地址访问，既耗时间又耗空间</p><p>但是句柄相对直接引用更灵活，可以更好的应对发生GC后对象的移动情况（晋升、标记-整理等）</p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>执行引擎是Java虚拟机的核心组成部分之一，但是和基于物理机的执行不同的是：</p><ul><li>物理机的执行引擎是直接基于机器指令和、处理器等部分的</li><li>虚拟机的执行引擎是软件实现的，不会受到硬件平台的限制</li></ul><p>也就是说JVM的执行引擎就是将Java字节码的指令解释（<strong>解释器</strong>）&#x2F;编译（<strong>JIT</strong>）为对应平台的机器指令</p><p>从运行时数据区的角度来看，执行引擎就是根据程序计数器的值，去执行对应的指令，然后根据指令对栈进行操作，比如局部变量表、操作数栈、新建一个栈帧等等</p><p>由于，执行引擎在执行字节码的时候，可能会解释执行，也可能通过JIT编译后的代码编译执行，因此Java语言是一门半解释半编译的语言</p><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>JVM设计的初衷就是跨平台性，实现跨平台性的方法就是设计了不同平台的JVM，这样可以保证对于不同平台，可以将相同的字节码翻译成对应的机器指令</p><p>那么解释器做的事情就是这个，不同平台的JVM解释器是不一样的，它可以根据当前平台的指令集，将字节码翻译成指定的指令，然后在对应平台上执行</p><p>但是这样做会导致程序运行的很低效，因为同一条字节码每次执行都需要翻译一遍。为了解决这一痛点，JIT即时编译器就出现了，它可以将部分代码提前编译好，等运行的时候直接运行就可以了</p><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><h4 id="编译器分类"><a href="#编译器分类" class="headerlink" title="编译器分类"></a>编译器分类</h4><p>Java编译器可以大致分为三种，分别是Java到字节码的编译器、JIT编译器、AOT编译器</p><ul><li>Java到字节码编译的过程，一般就是用sun的javac</li><li>JIT编译器是Hotspot比较重要的，有C1和C2</li><li>AOT编译器是直接完全将字节码翻译为机器码，比如GCJ（GNU compiler for the java）</li></ul><h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><p>为什么要搞这么个东西，而且又要把两个不同模式进行穿插使用呢？</p><p>我们要明确JIT和解释器的差别：</p><ul><li>JIT是编译完在执行机器码，执行起来速度很快，但是编译会耗费一定时间</li><li>解释器是上来就可以解释执行，但是每条字节码执行起来会慢点</li></ul><p>因此，最终JVM一个也没有抛弃，逐渐演变成了一个半解释半执行的语言</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>在HotSpot虚拟机中（JRockit没有用解释器），一个<strong>Java程序启动后</strong>：</p><ul><li>首先，解释器直接开始执行字节码，可以尽可能减小启动时间</li><li>然后，随着解释器的执行，JIT会通过热点探测找出热点代码，将其编译然后存放到方法区的JIT cache中</li><li>如果在解释执行的过程中，发现该代码块边JIT编译缓存了，那么就直接拿出来执行</li><li>最后，随着时间的推移，越来越到的代码被编译成机器码，程序会越来越快</li></ul><blockquote><p>这也就是为什么，Spring程序启动后，多发几次请求，后面的请求会比第一次快的原因之一</p><p>阿里为了解决这个问题，也采用了分批启动的方式，给出冷机和热机这样的名词</p></blockquote><h3 id="热点代码及探测"><a href="#热点代码及探测" class="headerlink" title="热点代码及探测"></a>热点代码及探测</h3><p>在HotSpot中，会实时的根据执行情况分析出热点代码，然后将其翻译为机器码缓存到方法区</p><p>那么什么才是热点代码呢?</p><p>其实就是根据执行频率来定的，比如被多次调用的方法或者循环次数很多的循环体（次数是通过计数器来计算的），而这也正好分成了两种方式，方法和循环</p><h4 id="方法JIT"><a href="#方法JIT" class="headerlink" title="方法JIT"></a>方法JIT</h4><p>方法使用的计数器叫做<strong>方法计数器</strong>，，其阈值进行即时编译是通过<code>-XX:CompileThreshold</code>来人为设定的</p><p>具体替换，其实就是栈上替换，因为一个方法就是栈帧，可以直接替换掉原本的栈帧，流程如下：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406240028093.png" alt="image-20240624002809965" style="zoom: 40%;" /><blockquote><p>要注意的是，JIT的阈值<strong>并不是一个绝对次数</strong>，如果程序超过规定的时间，阈值就会减半（称之为半衰期），可用参数<code>-XX:CounterHalfLifeTime</code>来规定半衰期大小</p></blockquote><h4 id="循环JIT"><a href="#循环JIT" class="headerlink" title="循环JIT"></a>循环JIT</h4><p>循环的使用的计数器叫<strong>回边计数器</strong>，大概思路和方法JIT差不多</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><h3 id="String的基本使用"><a href="#String的基本使用" class="headerlink" title="String的基本使用"></a>String的基本使用</h3><p>String可以通过字面量的形式或者new的形式构造出来，因为它很容易被我们当作是一种基本数据类型</p><p>String类实现了Serializable接口实现序列化，实现Comparable接口实现比较、排序</p><h4 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h4><p>String底层数据结构在不同JDK版本是不一样的，要注意的是JDK9及以后，从char数组改为了byte数组，因为Java团队发现大部分时候String存储的都是8字节的编码形式的数组，如果使用char会造成一半的空间浪费（相关的StringBuilder也修改了）</p><p>但是为了兼容16字节编码的字符串，JDK9及以后使用了byte+编码（决定是按1字节decode还是2字节decode）的形式来表示字符串</p><h4 id="String的不可变"><a href="#String的不可变" class="headerlink" title="String的不可变"></a>String的不可变</h4><p>String是不可被修改了，可以从两个角度来看：</p><ul><li><strong>String内部的存储结构</strong>（不管是char数组还是byte数组）是声明为final，</li><li><strong>String类也是声明为final</strong>的，因此String类无法被继承也没有暴露可修改的方法，甚至底层数据结构本身也无法修改</li></ul><h4 id="String底层的HashTable"><a href="#String底层的HashTable" class="headerlink" title="String底层的HashTable"></a>String底层的HashTable</h4><p>String常量池底层是一个哈希表，并且大小固定（可用<code>-XX:StringTableSize</code>来设置），使用拉链法解决冲突，因此字符串常量池不会存储相同的字符串。</p><p>如果字符串过多导致链表过长，就会导致调用String.intern时间过长</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发容器详解</title>
    <link href="/2024/06/04/2024-06-04-JUC%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/04/2024-06-04-JUC%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发容器详解"><a href="#JUC并发容器详解" class="headerlink" title="JUC并发容器详解"></a>JUC并发容器详解</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="Java并发的Map"><a href="#Java并发的Map" class="headerlink" title="Java并发的Map"></a>Java并发的Map</h3><p>Java可以提供并发的map的常用的有三种，分别是<code>HashTable</code>、<code>SynchronizedMap</code>（Collections.synchronizedMap方法提供）以及<code>ConcurrentHashMap</code>，那么这三者有什么区别呢？</p><p>首先，HashTable和SynchronizedMap都是直接通过synchronized关键字实现的，但是二者还是有区别的</p><ul><li><p>HashTable是直接在方法上加synchronized，但是SynchronizedMap是对方法的代码块加</p></li><li><p>而且SynchronizedMap可以自己提供synchronized的锁对象，不过默认情况下还是this</p></li><li><p>SynchronizedMap可以在不需要加锁的时候，直接使用原本的HashMap</p></li></ul><p>ConcurrentHashMap在JDK1.7和JDK1.8实现的方式是不同的，前者是分段锁+ReetrantLock，后者是synchronized+cas操作每个entry</p><blockquote><p>这样做的好处是，不用在对map操作的时候锁住整张表，而是将锁更加细化了</p><p><strong>full -&gt; segment -&gt; entry</strong></p></blockquote><h3 id="ConcurrentHashMap-JDK1-7"><a href="#ConcurrentHashMap-JDK1-7" class="headerlink" title="ConcurrentHashMap - JDK1.7"></a>ConcurrentHashMap - JDK1.7</h3><p>在1.7的ConcurrentHashMap中，使用的是分段锁的方法，对于一个key的操作，都会先根据其hashCode计算应该放到哪个Segement，然后再执行相应的get、put、remove等方法，而且扩容、上锁啥的都是以Segment为单位的，基本不会互相干扰</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406042321554.png" alt="img" style="zoom:40%;" /><p>Segment的个数是初始化的时候设置的，这个无法扩容且默认为16，并且这个Segment是继承了ReentrantLock类，可以直接使用其tryLock、lock等方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span><br></code></pre></td></tr></table></figure><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ol><li><p>首先，会让Segment的数量往上取到$2^n$，然后根据initialCapacity平均分配到每个Segment上，如果没有给initialCapacity的话，就会给Segment容量默认值：2</p><p>要注意的是，这个分配到Segment的大小是向上取整后，再往上取到$2^n$，并且这个只是Segment[0]的初始容量，其他的Segment只会在后续使用到的时候才进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity,</span><br><span class="hljs-params">                         <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)<br>        concurrencyLevel = MAX_SEGMENTS;<br>    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sshift</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ssize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span><br>    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;<br>        ++sshift;<br>        ssize &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//这两个值用来计算key对应的Segemnt</span><br>    <span class="hljs-comment">//由于是取高n位，因此先右移再和全1的mask按位与</span><br>    <span class="hljs-built_in">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;<br>    <span class="hljs-built_in">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br><br>    <span class="hljs-comment">// initialCapacity 是设置整个 map 初始的大小，</span><br>    <span class="hljs-comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> initialCapacity / ssize;<br>    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)<br>        ++c;<br>    <span class="hljs-comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> MIN_SEGMENT_TABLE_CAPACITY; <br>    <span class="hljs-keyword">while</span> (cap &lt; c)<br>        cap &lt;&lt;= <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 创建 Segment 数组，</span><br>    <span class="hljs-comment">// 并创建数组的第一个元素 segment[0]</span><br>    Segment&lt;K,V&gt; s0 =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="hljs-type">int</span>)(cap * loadFactor),<br>                         (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap]);<br>    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[ssize];<br>    <span class="hljs-comment">// 往数组写入 segment[0]</span><br>    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span><br>    <span class="hljs-built_in">this</span>.segments = ss;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>那么当执行put操作的时候，会先锁定对应的Segemnt，就是取key的hashCode的高n位为index</p><p>如果发现对应的Segment为空，那就会先调用<code>ensureSegment</code>进行Segment的初始化</p><p>这个初始化使用当前Segment[0]的参数来初始化，因为Segment[0]可能已经被扩容过了，初始化的时候，会先初始化一个Segemnt，然后通过CAS赋值进去</p><blockquote><p>这个CAS只会在当前Segment还是空的时候一直循环，一旦发现不是空就说明已经并发的有线程初始化过了，那就直接返回</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Segment&lt;K,V&gt; <span class="hljs-title function_">ensureSegment</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="hljs-built_in">this</span>.segments;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (k &lt;&lt; SSHIFT) + SBASE; <span class="hljs-comment">// raw offset</span><br>    Segment&lt;K,V&gt; seg;<br>    <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br>        <span class="hljs-comment">// 由于Segemnt[0]可能已经被扩容过了，因此需要取当前Segment[0]的参数初始化</span><br>        Segment&lt;K,V&gt; proto = ss[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> proto.table.length;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> proto.loadFactor;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(cap * lf);<br><br>        <span class="hljs-comment">// 初始化 segment[k] 内部的数组</span><br>        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>[cap];<br>        <span class="hljs-keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>            == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 再次检查一遍该槽是否被其他线程初始化了。</span><br><br>            Segment&lt;K,V&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(lf, threshold, tab);<br>            <span class="hljs-comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br>            <span class="hljs-keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))<br>                   == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="hljs-literal">null</span>, seg = s))<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> seg;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h5><ol><li><p>put操作首先会根据初始化算出的segmentShift和segmentMask计算出应该使用哪个Segment，然后如果发现对应的Segment为空的时候，会执行<code>ensureSegment</code>初始化Segment</p></li><li><p>找到对应的Segment后，就会执行该Segment的put操作，这才是真正的put</p><p>要注意的是，JDK1.7的拉链法采取的是<strong>头插法，且没有红黑树</strong></p><p>因此，，JDK会从头开始遍历链表，会有两种情况：</p><ul><li><p>一种是遍历的时候发现一样的key，就看看onlyIfAbsent是否允许覆盖，允许覆盖就覆盖完返回，不允许覆盖就直接返回；要是没发现一样的</p></li><li><p>第二种就是遍历完（可能本来first节点就是null），那就是该key不存在，就直接创建一个node，将next指向以前的first，再将node放到表头</p><blockquote><p>但是，这个node可能会在获取锁的时候调用scanAndLockForPut创建出来了，那就不用再初始化了，直接修改next指针就好，再放到表头</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value, <span class="hljs-type">boolean</span> onlyIfAbsent)</span> &#123;<br>    <span class="hljs-comment">// 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br>    <span class="hljs-comment">// tryLock失败了就会走scanAndLockForPut逻辑获取锁，可能会顺带创建出头节点！！</span><br>    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="hljs-literal">null</span> :<br>        scanAndLockForPut(key, hash, value);<br>    V oldValue;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这个是 segment 内部的数组</span><br>        HashEntry&lt;K,V&gt;[] tab = table;<br>        <span class="hljs-comment">// 再利用 hash 值，求应该放置的数组下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (tab.length - <span class="hljs-number">1</span>) &amp; hash;<br>        <span class="hljs-comment">// first 是数组该位置处的链表的表头</span><br>        HashEntry&lt;K,V&gt; first = entryAt(tab, index);<br><br>        <span class="hljs-comment">// 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                K k;<br>                <span class="hljs-keyword">if</span> ((k = e.key) == key ||<br>                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;<br>                    oldValue = e.value;<br>                    <span class="hljs-keyword">if</span> (!onlyIfAbsent) &#123;<br>                        <span class="hljs-comment">// 覆盖旧值</span><br>                        e.value = value;<br>                        ++modCount;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 继续顺着链表走</span><br>                e = e.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br>                <span class="hljs-comment">// 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br>                <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>                    node.setNext(first);<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> count + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br>                <span class="hljs-keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)<br>                    rehash(node); <span class="hljs-comment">// 扩容后面也会具体分析</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">// 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br>                    <span class="hljs-comment">// 其实就是将新的节点设置成原链表的表头</span><br>                    setEntryAt(tab, index, node);<br>                ++modCount;<br>                count = c;<br>                oldValue = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="put操作的其他两个函数"><a href="#put操作的其他两个函数" class="headerlink" title="put操作的其他两个函数"></a>put操作的其他两个函数</h5><p>put操作会有两个比较特殊的函数，一个是tryLock失败后会进行自旋的<code>scanAndLockForPut</code>，一个是put完成后检查发现超过threshold进行的<code>rehash</code></p><ol><li><p><strong>scanAndLockForPut</strong></p><p>这个函数会做两件事儿：</p><ul><li>tryLock，然后发现超过指定自旋次数，就会lock阻塞</li><li>在第一次自旋的时候，如果发现first为空，即该entry位置没有元素，那就顺便初始化一个node返回，这也就是为什么在put的时候，node有可能被初始化好了的原因</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashEntry&lt;K,V&gt; <span class="hljs-title function_">scanAndLockForPut</span><span class="hljs-params">(K key, <span class="hljs-type">int</span> hash, V value)</span> &#123;<br>    HashEntry&lt;K,V&gt; first = entryForHash(<span class="hljs-built_in">this</span>, hash);<br>    HashEntry&lt;K,V&gt; e = first;<br>    HashEntry&lt;K,V&gt; node = <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">retries</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// negative while locating node</span><br><br>    <span class="hljs-comment">// 循环获取锁</span><br>    <span class="hljs-keyword">while</span> (!tryLock()) &#123;<br>        HashEntry&lt;K,V&gt; f; <span class="hljs-comment">// to recheck first below</span><br>        <span class="hljs-keyword">if</span> (retries &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-comment">// speculatively create node</span><br>                    <span class="hljs-comment">// 进到这里说明数组该位置的链表是空的，没有任何元素</span><br>                    <span class="hljs-comment">// 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, <span class="hljs-literal">null</span>);<br>                retries = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.equals(e.key))<br>                retries = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 顺着链表往下走</span><br>                e = e.next;<br>        &#125;<br>        <span class="hljs-comment">// 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁</span><br>        <span class="hljs-comment">//    lock() 是阻塞方法，直到获取锁后返回</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<br>            lock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((retries &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp;<br>                 <span class="hljs-comment">// 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br>                 <span class="hljs-comment">//     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br>                 (f = entryForHash(<span class="hljs-built_in">this</span>, hash)) != first) &#123;<br>            e = first = f; <span class="hljs-comment">// re-traverse if entry changed</span><br>            retries = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>rehash</strong></p><p>这个没什么好说的，和HashMap的rehash差不多</p><p>由于只会在put和remove的时候发生rehash，而这两个操作都是已经获取了Segment的锁了，因此不需要考虑并发问题，所以直接rehash就好了</p></li></ol></li></ol><h5 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h5><p>get操作就比较简单了，就是先获取对应的Segment，然后如果为空直接返回，不为空就找到对应的entry列表的index，然后链表遍历就好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>    Segment&lt;K,V&gt; s;<br>    HashEntry&lt;K,V&gt;[] tab;<br>    <span class="hljs-comment">// 1. hash 值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;<br>    <span class="hljs-comment">// 2. 根据 hash 找到对应的 segment</span><br>    <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="hljs-literal">null</span> &amp;&amp;<br>        (tab = s.table) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 3. 找到segment 内部数组相应位置的链表，遍历</span><br>        <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile<br>                 (tab, ((<span class="hljs-type">long</span>)(((tab.length - <span class="hljs-number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);<br>             e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>            K k;<br>            <span class="hljs-keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))<br>                <span class="hljs-keyword">return</span> e.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ConcurrentHashMap-JDK1-8"><a href="#ConcurrentHashMap-JDK1-8" class="headerlink" title="ConcurrentHashMap - JDK1.8"></a>ConcurrentHashMap - JDK1.8</h3><p>在JDK1.7中使用的分段锁的思想，但是对于同一个Segment的entryList还是只允许一个线程操作，因此在JDK1.8中，摈弃了分段锁的思想，而是大量的使用CAS操作以及少量的synchronized</p><p>并且在JDK1.8中和原本的hashMap保持一致，使用<strong>链表+红黑树+尾插法</strong></p><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406042321355.png" alt="img" style="zoom:40%;" /><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="hljs-number">1</span>)) ?<br>               MAXIMUM_CAPACITY :<br>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">this</span>.sizeCtl = cap;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化的时候，会计算sizeCtl，就是初始容量的1.5倍+1，然后在向上取到$2^n$</p><p>这个sizeCtl比较特殊，正常情况下就是这个hashMap的容量阈值，超过就要扩容</p><p>但是在扩容的时候，就会将其置为-1，表示开始扩容，每来一个线程辅助扩容，就会-1。也就是说，$-N$就是表示有N个线程同时扩容，具体扩容后面会说</p><h5 id="put操作-1"><a href="#put操作-1" class="headerlink" title="put操作"></a>put操作</h5><p>这个源码就不放进去了，<strong>put操作是个大的循环</strong>，每次put失败，则表示有并发就会重新获取map的table数组，然后再次进行put，那么每次的put操作步骤如下：</p><ul><li>首先，看看table是不是空的，如果是空的则会初始化table，<code>initTable</code>方法</li><li>接着，计算hashCode对应的table的index，然后取出第一个节点进行判断：<ul><li>若为null，则直接CAS放进去</li><li>不为null，再看看hash值是不是-1，-1的hash值表示这一个ForwardingNode节点正在迁移table[i]，因此就会去辅助迁移，迁移完了，进入下一次put循环</li><li>不为null，也是正常的node，那就会锁住这个节点，然后进行修改操作。如果是链表则用尾插法，如果是红黑树就用红黑树的插入方法</li></ul></li><li>插入完如果发现满足转为红黑树条件，则转为红黑树</li><li>最后，容量加一，如果超过阈值则扩容</li></ul><h5 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h5><p>在执行put操作的时候，若发现table为空会先执行initTable方法来初始化，其实就是初始化一个数组</p><p>但是，为了防止多个线程同时初始化，需要通过CAS将sizeCtl改为-1，谁抢到谁初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 已经有线程开始初始化了</span><br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 初始化数组，长度为 16 或初始化时提供的长度</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    <span class="hljs-comment">// 将这个数组赋值给 table，table 是 volatile 的</span><br>                    table = tab = nt;<br>                    <span class="hljs-comment">// 将sizeCtl改为容量的1.5倍</span><br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h5><p>在JDK1.8的ConcurrentHashMap中，维持了一个nextTable，就类似Redis的ht[1]一样，平时一般都是空的，一到扩容的时候就会申请空间，然后将旧table的数据迁移过来，再将旧table的引用指向nextTable</p><p>但是和Redis不同的是，这个数据迁移并不是一个线程一批一批的迁移</p><p>在ConcurrentHashMap中，也是将整个迁移任务分为了多个，从n到0开始迁移，用一个transferIndex记录下次迁移的起始index，然后由发起迁移的线程进行一批一批的迁移，迁移完就会将对应table[index]处的头节点设置为ForwardNode类型的节点</p><blockquote><p>ForwardNode节点的hash值是-1，当后续如果在迁移过程中其他线程访问到这个table[index]，就会发现该节点是ForwardNode节点，会特殊处理</p><p>具体来说，put、remove这种修改操作会先进行helpTransfer；get操作则会去nextTable中找对应key</p></blockquote><p>在迁移的时候，会先看查看迁移地方的头节点状态：</p><ul><li><p>头节点为空，直接cas一个ForwardNode；</p></li><li><p>已经是ForwardNode，则已经迁移过了，就不管了</p></li><li><p>如果都不是，则synchronized这个地方，进行rehash并放到nextTable中，rehash完后会将旧table的头节点置为ForwardNode地方的头节点是ForwardNode</p></li></ul><p>当其他线程对这个地方put等操作的时候，会发现是ForwardNode，那么<strong>反正都是要挂起等待迁移完成，那为啥不帮着一起迁移呢？</strong>。因此，这些线程也会根据transferIndex领取一个迁移任务，进行迁移</p><p>rehash同样和HashMap一样，红黑树分完后<strong>如果节点个数小于6，也会退化为链表</strong></p><h5 id="addCount"><a href="#addCount" class="headerlink" title="addCount"></a>addCount</h5><p>在put操作后，会通过addCount将map的size+1，然后判断是否超过sizeCtl，若超过则也进行扩容</p><p>但是这里的加一，并不是直接暴力CAS让baseCount+1，因为要考虑多线程问题，所以为了提供效率，这里的addCount借鉴了LongAdder思想，一旦CAS失败就会存到一个CountCell数组里面</p><p>这里还是有很多特殊情况的，我们一个一个分析</p><ol><li>首先，最简单粗暴的就是，先CAS 让baseCount+1一下，如果成功就直接返回了</li><li>失败，那就要查看CountCell了，但是这个CountCell初始是空的，因此发现是空的就会执行<code>fullAddCount</code>函数；如果不为空，那就会找到相应的CountCell位置，若这个地方的CountCell为空还是会<code>fullAddCount</code>一下，不为空则CAS修改CountCell的值，失败还是会<code>fullAddCount</code></li></ol><p>总的来说，就是先CAS baseCount，失败了就会去CAS countCell，如果<strong>CountCell数组没有初始化或者CountCell[i]没有初始化</strong>，就会直接进入<code>fullCount</code>，同样<strong>CAS countCell失败也会</strong></p><blockquote><p>那么如果计算当前线程应该操作哪个CountCell呢？</p><p>会通过ThreadLocalRandom这个类来为当前线程生成一个随机数，然后拿这个随机数去取模</p></blockquote><h5 id="fullAddCount"><a href="#fullAddCount" class="headerlink" title="fullAddCount"></a>fullAddCount</h5><p>如果addCount失败，那就会进入fullAddCount，这里总的可以分为两种情况：</p><blockquote><p>在此之前，我们要知道：如果线程需要操作CountCell，那就需要先CAS cellBusy将其置为1，然后才能去操作，否则就会自旋，重新case下面三种情况</p></blockquote><ol><li><p>CountCell数组不为空，这个情况比较复杂</p><ul><li>先看看当前位置是不是空，为空则先抢cellBusy，抢到就创建一个CountCell放到指定位置</li><li>不是空的话，就先CAS countCell，如果失败，就说明也有线程跟当前线程操作的是一个CountCell单元，那就就会有两种解决措施：<ul><li>如果CountCell个数没有达到根据CPU核数计算出来的阈值，那就<strong>翻倍扩容</strong></li><li>达到了，那就说明无法扩容，只能重置随机数，自旋</li></ul></li></ul></li><li><p>CountCell数组为空</p><p>那就CAS cellBusy，抢到就将CountCell初始化为CountCell[2]</p><p>如果CAS失败，那就说明有其他线程在操作CountCell，那就直接CASbaseCount，失败就自旋</p></li></ol><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue是一个线程安全的队列，它和ConcurrentHashMap不一样，不使用synchronized这种会阻塞线程的锁，而是使用CAS来实现</p><p>在讲这个之前，<strong>我们要知道一点</strong>：</p><p>ConcurrentLinkedQueue的节点被封装为一个内部类Node，既然是queue那肯定是有一个head节点和一个tail节点，由于ConcurrentLinkedQueue底层是基于CAS的非阻塞形式，因此它<strong>对于head和tail的更新是采用一种延迟加载的策略</strong></p><p>这种延迟加载的策略会导致head或者tail并不是真正的head和tail，极有可能会出现下面这种情况：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406052317031.png" alt="img" style="zoom:67%;" /><p>这一点会贯穿整个底层实现，到底是如何这种延迟加载的，后面会说到。</p><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>在ConcurrentLinkedQueue中，定义了一个内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">volatile</span> E item;<br>    <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，还定义了两个链表的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure><blockquote><p>再次提醒一下，这个head和tail不是真实的head和tail，而是采用一种延迟加载的机制</p></blockquote><h3 id="poll操作"><a href="#poll操作" class="headerlink" title="poll操作"></a>poll操作</h3><p>为了方便offer更好的理解，我们先从poll操作讲起，我们不一定按照代码逻辑判断的顺序来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    restartFromHead:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> p.item;<br><br>            <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span> &amp;&amp; p.casItem(item, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (p != h)<br>                    updateHead(h, ((q = p.next) != <span class="hljs-literal">null</span>) ? q : p);<br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((q = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                updateHead(h, p);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                <span class="hljs-keyword">continue</span> restartFromHead;<br>            <span class="hljs-keyword">else</span><br>                p = q;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>首先，会先拿出当前维护的head节点，并将其赋值给p，然后拿出p里面的item</p></li><li><p>如果拿出来的item不是null并且CAS成功，那就返回item</p><p>但是返回之前，看看需不需要加载一下head：</p><ul><li>如果发现在p和head不相等了，那就说明p往后找了几个节点（有线程已经poll了几个但是没有更新head），那就要更新head为p后面的那个，执行updateHead(p.next)，当然，如果后面的节点是null的话，那就没必要更新为p.next了，直接updateHead(p)</li></ul></li><li><p>如果是null的话，那就说明已经到了队尾，那就返回null，但是在返回之前需要更新一下head</p></li><li><p>如果发现p&#x3D;q，那就是有其他队列已经更新了head，发生并发，那就要重新读取head，然后再次循环，为什么更新head会发生p.next&#x3D;q呢？</p><blockquote><p>在updateHead代码中，cas更新完head后，会讲原本的head指针的next指向自己，表示这个节点已经废了，如果有的线程发现了这个节点，那就需要重新读取</p></blockquote></li><li><p>最后，发现当前节点已经被读过了，并且当前head也是正常的，那就进入下一个节点继续判断</p></li></ol><h3 id="offer操作"><a href="#offer操作" class="headerlink" title="offer操作"></a>offer操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(e);<br><br>    <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>        Node&lt;E&gt; q = p.next;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// p is last node</span><br>            <span class="hljs-keyword">if</span> (p.casNext(<span class="hljs-literal">null</span>, newNode)) &#123;<br>                <span class="hljs-keyword">if</span> (p != t) <span class="hljs-comment">// hop two nodes at a time</span><br>                    casTail(t, newNode);  <span class="hljs-comment">// Failure is OK.</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// Lost CAS race to another thread; re-read next</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>            p = (t != (t = tail)) ? t : head;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// Check for tail updates after two hops.</span><br>            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>offer之前先检查是否为空，然后将tail赋值t和p，new一个待插入的节点，开始循环</p></li><li><p>如果p的next是空，那就尝试cas将p的next改为newNode，修改next失败，那就自旋</p><p>修改成功，那就看看有没有往后找了，有的话就要casTail，但是失败了不会自旋（CAS失败表示有线程更新成功了，即使和当前不一样，但是后续的poll还是会延迟加载）</p><blockquote><p>但是这里要注意的是，只要cas改掉了p的next，不管修改cas修改tail是否成功，都会返回true，因为即使没有改成功，后面也会延迟加载tail</p></blockquote></li><li><p>如果p和q相等，那就是head已经到tail后面去了，tail目前指向的是废弃节点（因为更新head 的时候，会把以前的head的next指向自己），那么就需要将从head节点开始一个一个往后找了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406052317376.png" alt="Node2从队列中出队后的状态" style="zoom:67%;" /><p>但是，在直接将p改为head之前，需要看看t和tail是否相等，因为很有可能就在<strong>这一刹那有一个线程已经将tail更新为正确的tail了</strong>，因此修改p的表达式为：<code>p=(t != (t = tail)) ? t : head</code></p></li><li><p>那走到最后，还是没有问题，那就说明已经有别的线程在该线程之前offer了一个节点，那就往后找，往后找同样需要判断在这一刹那是否已经有线程更新了tail，更新了那就直接将p改成新的tail，没更新，那就改为p.next（即q）：<code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code></p></li></ol><h3 id="延迟加载策略"><a href="#延迟加载策略" class="headerlink" title="延迟加载策略"></a>延迟加载策略</h3><p><strong>延迟加载是ConcurrentLinkedQueue非阻塞更新队列的核心</strong>，既然整篇都是延迟加载，那么就来讲一讲head和tail是什么时候延迟加载的吧</p><ul><li><p>head延迟加载：当发现当前head指向的节点为null，在返回item数据之前需要<strong>updateHead</strong>一下，</p><blockquote><p>不同于更改tail的一次CAS，更改head在CAS过后，为了标记出队的节点不可用，需要将原head的next指向自己</p><p>这样，当其他的offer、poll操作的时候，就会发现这个问题</p></blockquote></li><li><p>tail的延迟加载：若tail指向的不是最后一个节点（有线程已经插入了，或者前面很多次poll操作导致tail指向了废弃节点），那就会尝试CAS一下tail，但是不会管成功还是失败</p></li></ul><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列和前面刚刚提到的ConcurrentLinkedQueue不同，它是用于“生产者-消费者”模式的问题</p><p>当队列put满了，就会阻塞调用put的生产者线程；当队列take空了，就会阻塞调用take的消费者线程</p><p>而BlockingQueue是一个接口，它定义了如下操作：</p><p>&lt; img src&#x3D;”<a href="https://cdn.tobebetterjavaer.com/stutymore/BlockingQueue-20230818143620.png">https://cdn.tobebetterjavaer.com/stutymore/BlockingQueue-20230818143620.png</a>“ alt&#x3D;”img” style&#x3D;”zoom:70%;” &#x2F;&gt;</p><p>JUC提供了很多BlockingQueue的实现类，比如ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque等等</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue底层是通过ReentrantLock+Condition实现的，有两个Condition和一个lock</p><p>它是一个有界队列，在初始化的时候，必须传入capacity参数，表示队列容量且不能修改</p><p>此外，这一个循环队列，并且使用count的额外遍历来记录队列实际大小同时用于判断队列是否已满，而不是通过start&#x3D;end-1来判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Main lock guarding all access */</span><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><br><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure><p>put和take操作都会先通过ReentrantLock获取锁，然后才能进行队列操作</p><p>在进行put的时候：</p><ul><li>如果发现队列满，则会通过notEmpty阻塞，等到take出队成功就会调用notEmpty唤醒</li><li>如果队列没有满，则会调用enqueue函数，加入队列并调用notFull的signal，唤醒一个阻塞的take进程</li></ul><p>take方法则相反：</p><ul><li>如果发现队列空，则会通过notFull阻塞，等到put入队成功就会调用notFull唤醒</li><li>如果队列没有满，则会调用dequeue函数，加入队列并调用notEmpty的signal，唤醒一个阻塞的put进程</li></ul><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockQueue底层使用链表的数据结构，可以支持无界队列（不传capacity就是无界的），并且底层用的是两把ReentrantLock+两个Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Lock held by take, poll, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">/** Wait queue for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();<br><br><span class="hljs-comment">/** Lock held by put, offer, etc */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">/** Wait queue for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();<br></code></pre></td></tr></table></figure><p>和ArrayBlockingQueue不一样的是，LinkedBlockingQueue将put和take两个操作用两把锁，这样可以提高并发量，并且为了防止两个线程的并发问题，count使用的是AtomicInteger来保证安全性</p><p>其他的出队和入队的基本流程和ArrayBlockingQueue差不多</p><blockquote><p>ArrayBlockingQueue和LinkedBlockingQueue：</p><ul><li>二者都是基于ReentrantLock+Condition实现的</li><li>前者底层用的是数组并且有界，后者用的是链表可以支持无界</li><li>后者的锁粒度更细（put、take分离），并发量更大</li></ul></blockquote><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>这是一个无界的队列，底层是通过<code>PriorityQueue</code>+<code>ReentrantLock</code>+<code>Condition</code>实现，里面的元素需要实现Delayed接口因为需要获取延迟时间</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>通过优先队列根据<strong>任务到期时间</strong>（入队的currentTime+delayime）升序排序，这样可以保证每次出队的元素是最紧急需要执行的</p><p>每次出队的时候需要看看出队的元素是否到了执行时间，由于元素实现了Delayed接口，因此可以调用<code>getDelay</code>方法获取剩余的delayTime，$\le 0$则代表到期</p><p>当然这只是基本思想，由于每次入队一个元素需要唤醒所有线程，但是最终仍然只有一个线程会抢到任务，因此DelayQueue使用leader-follower模式，保证在有leader线程的情况下只会唤醒一个线程</p><h4 id="leader-follower模式"><a href="#leader-follower模式" class="headerlink" title="leader-follower模式"></a>leader-follower模式</h4><p>在这个模式中，如果有leader的情况下，任务会优先给leader消费，leader消费完后就会释放这个位置，唤醒所有的follower去竞争这个leader</p><p>这样的话，在有leader的情况下，不会调用signal的情况，减小CPU开销</p><h4 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h4><blockquote><p>要注意的是take和poll不一样，take在没有元素的情况下会一直等待，而poll会直接返回null</p><p>即使poll传入了等待时间，超过这个时间仍然会返回空</p></blockquote><ul><li><p>先拿出队首的元素，如果为空直接await()，因为队列为空，为了保证公平性不会设置leader</p></li><li><p>不为空，则看看是否到期，如果到期那就直接拿出来返回了</p></li><li><p>还没有到期，那就看看有没有leader，已经有leader在等这个任务那就await自己，等待全局唤醒</p></li><li><p>还没到期，而且还没有leader，那就把自己设为leader，<code>awaitNanos(delayTime)</code>时间就醒来拿这个任务</p></li><li><p><strong>最后有个finally操作</strong>，当leader的awaitNanos到了，如果发现leader还是自己，那就将leader置为空，并去拿任务，拿到了执行完了就会检测leader是否还是空并且队列是否还有元素，如果满足那就全局唤醒所有follower去争抢</p></li></ul><blockquote><p>awaitNanos(waitTime)返回的是剩余的等待时间，如果正常到期唤醒那就返回0，如果被提前signal唤醒，那就返回剩余的等待时间</p></blockquote><h4 id="offer操作-1"><a href="#offer操作-1" class="headerlink" title="offer操作"></a>offer操作</h4><p>是不是前面的take操作把自己设为leader后，就百分百锁定这个待到期的任务了呢？其实并不是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        q.offer(e);<br>        <span class="hljs-keyword">if</span> (q.peek() == e) &#123;<br>            leader = <span class="hljs-literal">null</span>;<br>            available.signal();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在offer的时候，会先入队，然后看看队列的第一个是不是刚入队的，如果是那就说明最紧急的任务发生了变化，那么以前的leader就不能再等到上一个任务到期的时间了，这个时候就会将leader置为空，然后全局唤醒</p><p>因此，很有可能在<code>awaitNanos(delayTime)</code>这个时间内，来一个更早执行的任务，那就会全局唤醒来争抢这个任务，争抢不到的第一个任务会更改leader为自己，其他线程全部await无限期阻塞</p><h4 id="poll操作-1"><a href="#poll操作-1" class="headerlink" title="poll操作"></a>poll操作</h4><p>不带等待时间的poll很简单，就是拿出来看看第一个任务有没有到期，到期直接返回任务；没到期或者队列空，那就直接返回null</p><p>我们重点来看看有等待时间的，同时还是先拿出第一个元素</p><ul><li><p>如果第一个元素为空，那就阻塞waitTime，如果有入队的元素全局唤醒会提前唤醒的</p><blockquote><p>阻塞waitTime的函数是<code>awaitNanos(waitTime)</code>，这个函数返回的是剩余的等待时间，如果正常到期唤醒那就返回0，如果被提前signal唤醒，那就返回剩余的等待时间</p></blockquote></li><li><p>如果不为空，那就取出来，发现已经到期了，那就直接返回</p></li><li><p>没到期，则就看看最紧急任务的剩余时间是不是大于等待时间，并再看看leader是否为空：</p><p><code>nanos &lt; delay || leader != null</code></p><p>只要二者条件满足一个就要awaitNanos(waitTime)，后者的判断是因为leader会先执行，执行完在finally中会全局唤醒</p></li><li><p>没有leader，并且最紧急任务的剩余时间小于等待时间，那就awaitNanos(delayTime)，并将leader设置为自己，并且如果被提前唤醒，需要更新下次等待的总时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">timeLeft</span> <span class="hljs-operator">=</span> available.awaitNanos(delay);<br>nanos -= delay - timeLeft;<br></code></pre></td></tr></table></figure></li></ul><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList使用的和Linux的fork函数一样的写时复制技术，用来处理多线程ArrayList的并发问题</p><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>内部维护一个Object数组（volatile修饰），然后读的时候就直接从这里面读</p><p>写的时候，会先获取锁（<strong>防止多个线程都复制一份，出现并发问题</strong>），然后将Object数组copy一份往里写，写完再将原本的Object数组引用换成写完后的新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The array, accessed only via getArray/setArray. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> get(getArray(), index);<br>&#125;<br><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>就是从数组中正常的读元素，没啥其他的</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>newElements[len] = e;<br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先获取锁，这是ReentrantLock实现的锁，防止多个线程同时复制，由于setArray不是CAS而且同时复制更容易OOM，因此只用一把写锁</li><li>拿到锁后，就复制一份，但是这一份</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发工具详解</title>
    <link href="/2024/06/03/2024-06-03-JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/03/2024-06-03-JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发工具详解"><a href="#JUC并发工具详解" class="headerlink" title="JUC并发工具详解"></a>JUC并发工具详解</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="进程、线程、管程"><a href="#进程、线程、管程" class="headerlink" title="进程、线程、管程"></a>进程、线程、管程</h3><p>太经典了，这个问题</p><p>进程是系统资源分配的单位，而线程是执行的最小单位</p><p>管程可以理解为monitor，只有一个线程持有管程的时候，才可以进入同步代码块</p><h3 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h3><p>用户线程是用户创建的，最典型的就是main方法的主线程</p><p>守护线程是为用户线程提供服务的，在后台运行，最典型的就是垃圾回收线程</p><p>假设当前JVM只有守护线程时，那么JVM就会退出</p><blockquote><p>即使main方法的主线程运行完了，但是里面创建的子线程还在运行，那么JVM仍然不会退出</p></blockquote><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><h3 id="线程是如何创建的？"><a href="#线程是如何创建的？" class="headerlink" title="线程是如何创建的？"></a>线程是如何创建的？</h3><p>这是一个老生常谈的问题了，都是说三种方法：继承Thread类、实现Runnable接口、实现Callable接口</p><p>但是实际上你看一看线程的构造函数，其实只有一个Runnable接口的构造注入，也就是说Thread除了你去继承他，实际上只有一个传入Runnable方法去构造Thread</p><p>也就是说调用线程的start的方法的时候：</p><ul><li>如果你是继承Thread类，那么你就是重写了run方法，没有Runnable对象</li><li>如果你是实现Runnable接口，并构造注入一个Thread类，那用的原生的Thread的run方法，这里会直接调用Runnable的run方法</li></ul><p>附代码：Thread类的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//这个target就是构造方法注入的Runnable对象</span><br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>        target.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>综上所述，其实启动线程说到底就两种方法，那Callable是如何启动线程的呢？</p><h3 id="Callable接口如何启动线程的"><a href="#Callable接口如何启动线程的" class="headerlink" title="Callable接口如何启动线程的"></a>Callable接口如何启动线程的</h3><p>Callable接口其实没有办法直接启动线程，而是通过构造注入FutureTask类，然后FutureTask实现了Runnable接口，从而通过FutureTask类构造注入Thread，来启动线程的</p><p>那为什么要搞这么麻烦呢？</p><p>这个Callable接口设计出来，就是为了获取线程执行的结果的，如果一个FutureTask构造注入了Callable方法，那么它实现的Runnable接口的run方法就会做两个事儿：</p><ul><li>执行callable的call方法</li><li>将callable方法的返回值赋给futureTask的返回值，这样你get的时候就能得到“所谓的线程执行的结果”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//...省略</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>            V result;<br>            <span class="hljs-type">boolean</span> ran;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//执行call，然后set结果</span><br>                result = c.call();<br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                result = <span class="hljs-literal">null</span>;<br>                ran = <span class="hljs-literal">false</span>;<br>                setException(ex);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ran)<br>                set(result);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//...省略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>既然知道了Callable是通过FutureTask来启动线程的，那么为啥要非这么多力气去搞一个FutureTask？</p><p>FutureTask实现了RunnableFuture接口，这个接口继承了Runnable和Future接口</p><p>Runnable接口就是用来创建线程的，Future接口做任务控制的（定义查看任务状态、获取任务结果等方法）</p><p>其次FutureTask还通过构造注入了Callable接口，尽管支持注入Runnable+result的方式，但是底层还是会通过这两个构造一个callable</p><p>那么既然搞了这三个东西，那这个futureTask可想而知，是一个<strong>三功能综合体</strong>：</p><ul><li>开启线程（Runnable接口）</li><li>实现任务管理（Future接口）</li><li>获取线程执行结果（Callable接口）</li></ul><p><strong>但是FutureTask获取执行结果有两个问题</strong>：</p><ul><li>使用get方法直接获取结果，就会导致线程阻塞</li><li>如果使用isDone方法轮询再获取结果就会占用CPU资源</li></ul><p>因此，如何解决这两个问题呢，就用到了CompletableFuture类</p><blockquote><p>在将CompletableFuture之前需要知道函数式接口，Java8函数式编程提供了四个接口：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406110034513.png" alt="image-20240611003414325" style="zoom: 33%;" /></blockquote><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>线程池是一个典型的池化技术实现，可以实现线程资源的复用，避免带来重复创建和销毁带来的性能上的开销</p><p>其实线程池不仅可以实现线程资源的复用，而且还可以实现线程资源的管控，防止不规范的创建使用线程</p><h3 id="线程池的构造参数"><a href="#线程池的构造参数" class="headerlink" title="线程池的构造参数"></a>线程池的构造参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池创建的核心线程数，线程池维护线程的最少数量，即使没有任务需要执行，也会一直存活</td></tr><tr><td>maximumPoolSize</td><td>最大线程池数量，当线程数&gt;&#x3D;corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务</td></tr><tr><td>keepAliveTime</td><td>当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量&#x3D;corePoolSize</td></tr><tr><td>TimeUnit</td><td>时间单位</td></tr><tr><td>workQueue</td><td><strong>阻塞队列</strong>：当核心线程数达到最大时，新任务会放在队列中排队等待执行，就是BlockingQueue</td></tr><tr><td>threadFactory</td><td>线程创建的工厂，一般用默认的 Executors.defaultThreadFactory()</td></tr><tr><td>handler</td><td><strong>拒绝策略</strong>：当pool已经达到max size的时候，如何处理新任务</td></tr></tbody></table><p>这里我们需要提一下拒绝策略：</p><ul><li><p>AbortPolicy：直接抛出异常</p></li><li><p>DiscardPolicy：丢弃新的任务，我们是不知道的！</p></li><li><p>DiscardPolicyOldestPolicy：这个是丢掉最老的任务，即FIFO</p></li><li><p>CallerRunsPolicy：让提交任务的线程去执行，比如异步功能，想要让线程池去做，但是线程池饱和了，线程池说，我不做，你自己做。<strong>其实就是从异步变成同步了</strong></p></li><li><p>自定义：实现接口RejectedExecutionHandler，重写<code>rejectedExecution</code>方法就行了</p></li></ul><h3 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h3><p>首先要知道的是，线程池有一个字段ctl，这个字段的高三位代表线程池的状态（RUNNING、SHUTDOWN、STOP、TERMINATED等），低29位代表线程池的线程个数</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406130102857.png" alt="img" style="zoom: 67%;" /><ul><li><p>在调用shutdown的时候，就会将线程池的状态置为SHUTDOWN，然后等待所有已经提交的任务（正在运行以及队列中阻塞的）都运行完，就会变为TIDYING状态，调用terminated才会置为TERMINATED</p></li><li><p>在调用shutdownNow的时候，就会将状态置为STOP，不会再运行队列中的任务了，只会等待正在运行的任务运行完，就会变为TIDYING状态，调用terminated才会置为TERMINATED</p></li></ul><h3 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h3><p>线程池有两种提交方式，一个是execute一个是submit，submit会返回一个Future对象用于获取结果</p><p>其实submit底层就是将Callable或者Runnable包装成了一个FutureTask类，然后再调用execute</p><p>因此我们来讲讲execute方法</p><p>这个方法就是整个任务提交的策略，很简单，直接上图</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406130119152.jpeg" alt="img" style="zoom:50%;" /><h3 id="如何实现线程复用的"><a href="#如何实现线程复用的" class="headerlink" title="如何实现线程复用的"></a>如何实现线程复用的</h3><p>线程提交后，会被封装到Work中调用，Work类继承了Runable接口，run方法就是执行worker的runWork方法</p><ul><li>当runWorker开启后，会先执行提交的第一个任务，即firstTask属性，这个会在创建的时候就初始化好了，因为只有提交了任务才有可能会触发创建线程</li><li>然后就会进入while无限循环，一直调用getTask方法拿任务，然后执行task的run方法</li><li>这个getTask方法很特殊，它对于当前线程是否是核心线程采用的不同的策略，当然他还会根据当前线程池的状态决定从不从阻塞队列里面拿，比如如果是STOP，那就直接返回null，然后销毁线程<ul><li>核心线程就是用take</li><li>非核心线程用的时候有时间的poll，这样当达到keepAlive时间还没有拿到就会返回null，然后就会销毁线程</li></ul></li></ul><h4 id="Excutors的四个典型的线程池"><a href="#Excutors的四个典型的线程池" class="headerlink" title="Excutors的四个典型的线程池"></a>Excutors的四个典型的线程池</h4><ol><li>newFixedThreadPool：固定个数，不会加也不会减，采用的无界队列容易OOM</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>newSingleThreadExecutor：相当于newFixedThreadPool特殊版本，只有一个线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>newCachedThreadPool：来一个任务就开启一个线程，因此使用的是直接队列，并且maximumPoolSize没有上限，同样会OOM</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>newScheduledThreadPool：支持定时，周期型的执行任务，使用的延时队列，同样会OOM</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE,<br>              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，用于为任务提供周期执行以及延迟执行的功能，可以认为是一种本地的任务调度系统，但是他和ThreadPoolExecutor还是有点不一样，它底层实现了很多东西：</p><ul><li>定义了内部类ScheduledFutureTask，用于执行周期任务、延迟任务、当然同样也兼容不需要时间调度的任务</li><li>写了一个BlockingQueue：DelayedWorkQueue，这是为该线程池定制的，这是一个无界队列</li></ul><h3 id="三种任务提交方式"><a href="#三种任务提交方式" class="headerlink" title="三种任务提交方式"></a>三种任务提交方式</h3><p>这个FutureTask的run方法需要支持周期任务、延迟任务、非周期任务三种形式</p><p>同样，ScheduledThreadPoolExecutor也提供了三种提交任务的函数，分别对应这三种任务性质：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安排一个Callable任务在给定的延迟后执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit&#123;</span><br><span class="hljs-params">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="hljs-params">        new ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit)</span>));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安排一个Runnable任务在给定的初始延迟后首次执行，随后每个period时间间隔执行一次。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                              <span class="hljs-type">long</span> initialDelay,<br>                                              <span class="hljs-type">long</span> period,<br>                                              TimeUnit unit)&#123;<br>    ScheduledFutureTask&lt;Void&gt; sft =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>                                      <span class="hljs-literal">null</span>,<br>                                      triggerTime(initialDelay, unit),<br>                                      unit.toNanos(period));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安排一个Runnable任务在给定的初始延迟后首次执行，随后每次完成任务后等待指定的延迟再次执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                 <span class="hljs-type">long</span> initialDelay,<br>                                                 <span class="hljs-type">long</span> delay,<br>                                                 TimeUnit unit)&#123;<br>    ScheduledFutureTask&lt;Void&gt; sft =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,<br>                                      <span class="hljs-literal">null</span>,<br>                                      triggerTime(initialDelay, unit),<br>                                      unit.toNanos(-delay));<span class="hljs-comment">//计算任务的执行周期</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：为了将三者区分开，period设置为了正数、0、负数三种，正好代表了这三种类型的任务</strong></p><p>这就是三种任务的提交方式，其实这三个方式最终都是构造了一个ScheduledFutureTask对象，然后调用delayExecute函数，放入队列或者开启新线程运行任务</p><p>delayExecute函数具体做法就是：</p><ul><li>如果发现线程已经处于关闭状态，那就拒绝任务执行拒绝策略</li><li>没什么问题的话，就放入队列中，然后在确保线程数</li></ul><blockquote><p>这和原始的ThreadPoolExecutor不一样，传统的线程池在加入任务的时候会先看看核心线程数是否达到，没到就直接将当前任务设置为新worker的firstTask然后直接运行</p><p>但是定时任务线程池是直接放到队列，然后开启一个线程自己从队列中取，<strong>因此新开的线程不一定就是运行当前这个任务</strong></p></blockquote><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>这个是提交任务，那么提交过后是如何实现周期运行的呢？这个是在ScheduledFutureTask的run方法中实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<span class="hljs-comment">//是否为周期任务</span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<span class="hljs-comment">//当前状态是否可以执行</span><br>        cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        <span class="hljs-comment">//不是周期任务，直接执行</span><br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>        setNextRunTime();<span class="hljs-comment">//设置下一次运行时间</span><br>        reExecutePeriodic(outerTask);<span class="hljs-comment">//重排序一个周期任务</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-comment">// p &gt; 0，说明是固定速率运行的任务</span><br>    <span class="hljs-comment">// 在原来任务开始执行时间的基础上加上p即可</span><br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>      time += p;<br>    <span class="hljs-comment">// p &lt; 0，说明是固定时延运行的任务，</span><br>    <span class="hljs-comment">// 下次执行时间在当前时间(任务执行完成的时间)的基础上加上-p的时间</span><br>    <span class="hljs-keyword">else</span><br>      time = triggerTime(-p);<br>&#125;<br></code></pre></td></tr></table></figure><p>在run方法中：</p><ul><li>首先会判断period是否等于0（即<code>isPeriod</code>方法）是不是周期任务，如果不是那就直接调用FutureTask的run方法直接执行</li><li>如果是的话就需要执行runAndReset方法执行，执行完还需要重新设置下次运行时间，并重新放入队列</li><li><strong>在设置时间的时候</strong>，仍然会进行区分:<ul><li>如果$period&gt;0$，那就说明是固定速率执行，那就是<code>time+period</code></li><li>如果$period&lt;0$，那就是每隔period执行，那就是当前时间<code>now()+(-peirod)</code></li></ul></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h4 id="ThreadLocal应用场景"><a href="#ThreadLocal应用场景" class="headerlink" title="ThreadLocal应用场景"></a>ThreadLocal应用场景</h4><ol><li>当一个线程中某个对象需要使用很多次，为了避免每次使用都要new一个的开销，我们可以用ThreadLocal给它存起来，后面用直接取就行了</li><li>线程内需要保存全局变量，来避免传参麻烦。就比如token的身份校验，一个请求中用户的身份应该都是同一个，那么我们可以将用户的身份解析出来然后存到threadLocal中</li></ol><blockquote><p>但是，在第二种场景中，我们在拦截器退出操作的时候，要记得ThreadLocal的remove，否则会<strong>内存泄漏</strong></p></blockquote><h4 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h4><p>基于Thread私有变量threadLocals，这个threadLocals是ThreadLocal类中定义的ThreadLocalMap变量，这个map的key是threadLocal对象实例，value就是这个ThreadLocal的值，那么我们就应该知道了ThreadLocal、Thread、ThreadLocalMap的关系了吧：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405191518040.png" alt="image-20240519151814888" style="zoom: 33%;" /><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>这个Map和HashMap可不一样，实现方式都是不同的</p><ul><li>首先，它处理哈希冲突的方式不是拉链法，而是开放定址法</li><li>其次，动态扩容的阈值也不一样，HashMap是数组容量的0.75，而ThreadLocalMap是$\frac{2}{3}$</li><li>最后，ThreadLocalMap的key是ThreadLocal变量的弱引用</li></ul><p>也就是说，如果发生GC，那么这个threadLocal的key就没了</p><blockquote><p>那为什么，我们ThreadLocal调用get为什么还是能拿到，不是发生GC就没了吗？</p><p>因为弱引用发生GC回收对象，只会出现在<strong>这个对象有且只有弱引用</strong>。如果有强引用指向它，那么仍然不会被GC掉，因此我们ThreadLocal变量一般声明为static final，这样强引用一直在，就不会被回收了</p></blockquote><h4 id="Thread-Local源码"><a href="#Thread-Local源码" class="headerlink" title="Thread Local源码"></a>Thread Local源码</h4><ul><li><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果从map里面get出来为空，那么我们就执行threadLocal的initialValue方法，初始化变量，否则只要你set过了，那么就算你重写了initialValue也不会执行，initialValue方法是<strong>懒加载的</strong></p></li><li><p>set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取当前线程的threadLocalMap，然后调用set方法</p></li></ul><h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><blockquote><p>这里先理清一下内存泄漏和内存溢出的区别</p><p>内存泄漏指的是：对象不使用了，应该被回收，但是没被回收</p><p>内存溢出指的是：就是申请的内存不够用，造成outofMemory</p></blockquote><p>由于ThreadLocalMap的key是一个弱引用，那么没有强引用的时候就会发生，那么啥时候会发生呢？</p><p>对于一个线程来说，线程没了就没了，没啥好说的，value肯定会被回收掉</p><p>但是如果是线程池，由于<strong>线程是会被复用</strong>的，那么如果key被GC掉了，但是value还在，此时如果你不手动remoce的话那么value就会一直在，发生内存泄漏</p><h2 id="AQS抽象队列同步器"><a href="#AQS抽象队列同步器" class="headerlink" title="AQS抽象队列同步器"></a>AQS抽象队列同步器</h2><p>AQS全程是AbstractQueueSynchronizer，即抽象队列同步器。</p><p>既然是抽象的，那肯定就是某一类组件的公共基础部分的抽取，其实AQS就是JUC并发工具的基石框架，主要解决的问题就是：<strong>多线程下锁的分配问题</strong></p><p>AQS本质就是，通过一个FIFO的队列完成对资源state的管控，完成对多线程的控制同步</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406050105638.png" alt="CLH 队列" style="zoom:50%;" /><h3 id="AQS模版方法"><a href="#AQS模版方法" class="headerlink" title="AQS模版方法"></a>AQS模版方法</h3><p>在AQS中，定义了很多final方法，比如acquire、release</p><p>在这些方法中，定义了获取和释放资源的执行逻辑，但是需要用户去自定义如何去获取和释放资源</p><p>这是AQS提供的几个可以重写的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">tryAcquire(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><p><strong>用户可以自定义如何去获取资源，但是获取失败后的入队、唤醒、阻塞的逻辑AQS已经帮你写好了，并且声明为final接口，不可被重写</strong></p><p>并且这些方法必须重写，不重写就会执行默认的方法：直接抛出UnsupportedOperationException</p><h3 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h3><p>AQS将每个线程封装在一个Node类中，这个Node对象就是AQS队列中的每个节点，它按照入队的顺序进行存储，并且对于<strong>某个节点只能由其前驱节点唤醒</strong></p><blockquote><p>虽然说ReentrantLock有公平和非公平两种实现形式，<strong>但是最终如果入队了，还是按照入队的顺序一个一个获取锁</strong>，只是说在tryAcquire的时候非公平锁只要发现可以占有就直接占有，而公平锁就算可以占有，但队列有节点在排队还是不会占有。</p></blockquote><p>对于Node对象，除了封装了等待的Thread类以外，还有一个叫waitStatus，这个很重要，一共有五个值：</p><ul><li><code>CANCELLED</code>，值为1，表示当前的线程被取消。</li><li><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。</li><li><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中。</li><li><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。</li><li>初始，值为0，表示当前节点在sync queue中</li></ul><h3 id="acquire函数"><a href="#acquire函数" class="headerlink" title="acquire函数"></a>acquire函数</h3><p>在AQS中，提供了一个模版函数acquire，用于获取资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数由三个部分组成：<code>tryAcquire</code>+<code>addWaiter</code>+<code>acquireQueued</code></p><p>其中<strong>tryAcquire函数</strong>是需要在子类中被重写，并且是必须重写的，因为在AQS中这个tryAcquire函数定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquire函数是通过用户定义的方式来获取资源，即改变state，如果不满足获取条件就会返回false，接下来就会调用AQS定义的<code>addWaiter</code>+<code>acquireQueued</code>这两个函数，处理入队、阻塞等逻辑</p><p>而这两个函数是AQS中被声明为final的函数，也就是说这些阻塞、入队逻辑由AQS提供，用户只需要考虑如何获取资源就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//private是隐式的final</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是acquire函数的大致思想（模版方法），具体这两个函数怎么工作的后，下面会详细介绍</p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>这个函数会创造一个新的节点，然后将这个节点入队，具体入队操作就是：</p><ul><li>将tail的next指向新节点，再CAS将tail指针指向新节点</li></ul><p>这个操作只会在tail不为空的时候进行，如果AQS队列还没有初始化或者CAS失败了，那就要进入enq函数，进行自旋直至替换tail成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果发现队列还没有初始化，就说明tail和head都是null，那就需要在第一次循环中先创建一个虚拟头节点，将tail和head都指向它，然后在进入第二次循环</p><p>在后面的循环中，重复执行入队操作直至CAS成功</p><blockquote><p>为什么要创建虚拟头节点？</p><p>因为队列中被阻塞的节点都需要被前驱节点唤醒，如果把搞一个虚拟头节点，那么第一个入队的节点就没人唤醒了，导致整个队列都无法被唤醒！</p></blockquote><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>这个函数就是阻塞等待唤醒，唤醒后获取资源的函数，这个函数返回值是 该线程在park的时候有没有被inturrpt唤醒。如果被唤醒了就会返回true，并且会在获取资源后，执行<code>selfInterrupt</code>方法，再次把中断标记置为true</p><p>在每次循环中：</p><ul><li>如果发现其前驱是头节点，那么就tryAcquire一下，成功了就把自己设为头节点，因为头节点的任务已经完成了（唤醒了后继节点），那么接下来就由抢到资源的节点去唤醒下一个头节点了</li><li>如果发现不是头节点，那么要做两件事：<ul><li>一个是将其前驱节点的waitStatus设置为SIGNAL，让其释放锁的时候去唤醒它；如果前驱节点是cancle状态，那就找到前面第一个不是cancle的节点修改其为自己前驱，然后再设置为SIGNAL</li><li>第二件事就是park，在park的时候为了防止被inturrpt唤醒，一旦被唤醒就会通过Thread.interrupted操作将其中断标记改为false并返回true，然后一直死循环到其前驱节点是头节点，才会出去</li></ul></li></ul><blockquote><p>这样做的原因是，由于AQS是不允许inturrupt唤醒线程的，因此一旦被唤醒就直接让其进入死循环，这样还是相当于什么事也干不了，让用户对于被inturrupt唤醒这件事无感知（以为还是阻塞，其实已经被inturrupt唤醒在里面死循环）</p><p>但是，有时候又需要知道这个线程是否被inturrupt过，因此在获取到资源后，如果被打断过，就需要<code>selfInterrupt</code>一下，重新把打断标记置为true</p></blockquote><h3 id="release函数"><a href="#release函数" class="headerlink" title="release函数"></a>release函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放成功</span><br>        <span class="hljs-comment">// 保存头节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空并且头节点状态不为0</span><br>            unparkSuccessor(h); <span class="hljs-comment">//释放头节点的后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>release方法也是一个模版方法，用户自定义AQS同步器的时候，需要重写tryRelease方法，来对state操作，但是释放后，如何去唤醒其他线程那是AQS自己定义的</p><p>操作完资源后，就会让头节点去唤醒它的后继节点，执行<code>unparkSuccessor</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span><br>        <span class="hljs-comment">// 比较并且设置结点等待状态，设置为0</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-comment">// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span><br>        s = <span class="hljs-literal">null</span>; <br>        <span class="hljs-comment">// 从尾结点开始从后往前开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>             <span class="hljs-comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span><br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>) <br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 该结点不为为空，释放许可</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果后续节点是cancel状态，那就找到后面的第一个不是canel的节点，将其唤醒；如果是那就唤醒</p><p>唤醒的节点就会重新开始acquireQueued中的死循环，由于是被头节点并且还是前驱节点唤醒的，因此就会执行tryAcquire获取资源，拿到资源就会把自己设置为头节点，方便唤醒后继节点</p><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>如果想像synchronized一样，在执行的时候调用wait函数来释放锁，并在别的线程中通过notify函数重新唤醒来重新去争抢锁</p><p>那就需要通过AQS中的ConditionObject来实现，它提供的await和signal方法就分别对应了wait和notify方法，下面一个一个介绍吧</p><h4 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h4><p>这个就不放源码了，比较简单</p><ul><li>首先会创建一个waitStatus为CONDITION的节点，然后将其放入Condition的等待队列中</li><li>然后就会释放持有的锁，就是调用AQS提供的release方法释放，释放完就park自己</li><li>一旦park结束就会先校验是不是意外打断导致的唤醒，如果是就继续park，否则就开始重新获取资源，调用acquireQueued方法</li></ul><h4 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h4><p>那么await中被park住的线程是如何被唤醒的呢？就是通过signal调用unpark方法释放</p><ul><li>首先，它会找到waiter队列中的第一个节点，取出来然后更新队列</li><li>更新完了后，就将该节点放到AQS队列中，然后unpark一下去竞争，这个时候刚刚await方法中的park结束继续执行下去，调用acquireQueued方法（其实这个方法执行中该阻塞还是会阻塞）</li></ul><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch底层用到的是共享锁的acquire和release，正好接着这个来看一看共享锁是如何acquire和release的</p><p>CountDownLatch基本思想就是，初始化state为n，然后n个线程分别调用countDown使state减1，接着如果调用了await函数，就会阻塞，直到state为0的时候就会释放</p><p>由于await操作是共享的，当队列里有多个节点被await阻塞了，应该以传播的方式依次唤醒，所以整个CountDownLatch使用的是共享的acquire和release</p><h3 id="acquireShared方法"><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h3><p>当调用await的时候实际上调用的是acquireSharedInterruptibly，但是这个和acquireShare差不多，我们就拿acquireShared来分析分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法调用Sync的tryAcquireShared以及AQS的doAcquireShared，而在countDownLatch中的tryAcquireShared就是看看state是不是0，是就返回1，不是就返回-1</p><p>接着如果发现小于0就说明无法获取共享资源，那就需要执行AQS提供的doAcquireShared方法</p><p><code>doAcquireShared</code>方法和以前tryAcquire方法类似，也是先addWaiter，但是这里创建的Node的waitStatus是<code>Node.SHARED</code>，一样如果发现是头节点就会尝试获取锁，不然就shouldPark再park阻塞</p><p>但是不同的是，当doAcquireShared成功tryAcuqireShared后，就不是单纯的setHead，而是<code>setHeadAnPropagate</code>，这个操作不但会把当前节点设置为头节点，并且如何其后继节点也是因为SHARED状态，也会释放（<strong>因为是共享阻塞，一旦共享锁可获取，因为此等待的线程都应该被唤醒去尝试获取</strong>）</p><h3 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h3><p>当调用CountDownLatch的countDown方法，就会调用releaseShared方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法同样也是模版方法，会先调用CountDownLatch重写的tryReleasedShared方法，在调用doReleaseShared方法</p><p>tryReleasedShared会将当前state减1，然后看看state是否到0，如果到了就需要返回true，这样才能调用doReleaseShared去唤醒阻塞线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个释放会释放后续所有的为SIGNAL线程，因为每次释放后，其他线程都会去抢锁把自己设置为head</p><p>因此最后只有发现释放完原本的没有变化就说明释放完了，不然的话一旦unpark了一个节点就会tryAcuqireShared一次然后再次更新head，，这样刚开始拿到的h和现在的head不想等，无法break出去；只有后续没有节点释放了，先开始拿到的head还是head，这样最后满足条件，才会break出去</p><p>也就说<code>doReleaseShared()</code>方法会以一种风暴的形式唤醒后续的第一个获取写锁之前的所有获取读锁的节点，没有写锁将会唤醒整个队列</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM内存模型理解</title>
    <link href="/2024/05/30/2024-05-30-JMM%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/"/>
    <url>/2024/05/30/2024-05-30-JMM%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JMM内存模型理解"><a href="#JMM内存模型理解" class="headerlink" title="JMM内存模型理解"></a>JMM内存模型理解</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="什么是JMM"><a href="#什么是JMM" class="headerlink" title="什么是JMM"></a>什么是JMM</h3><p>在计算机底层系统中，都知道是有主存-&gt;cache-&gt;寄存器这样一个等级的，但是在多核高并发的情况下，就会出现内存的读写不一致的问题，那么该如何解决呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406010153682.png" alt="image-20240601015358523" style="zoom: 33%;" /><p>首先，要知道的是OS对于读写一致性是由解决方法的，比如总线嗅探机制的MESI协议</p><p>但是，对于不同的硬件平台和OS搞出一套不同的解决方案那是不可行的，并且这些协议是由OS将数据写回主存，<strong>为了屏蔽硬件和操作系统的差异并且可以自己决定写回内存的时机</strong>，JMM定义了一堆东西比如volatile、synchronized，定义了一个变量的读写方式、可见性、原子性、有序性等等问题，由用户通过JMM提供的这些方式进行同步</p><p><strong>因此，JMM是一种抽象的概念和规范</strong>，有了JMM你只需要考虑线程工作内存、主内存这两个东西，你不需要考虑寄存器、这个CPU有几级cache那些玩意儿一层层的同步。</p><p>JMM告诉你，要想实现可见性，你就可以用volatile、synchronized</p><blockquote><p>其实，JVM底层这些关键字的实现还是对于不同平台有不同的实现，只不过对用户屏蔽了</p></blockquote><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406010129724.png" style="zoom: 33%;" /><h3 id="JMM三大特性：原子性、有序性、可见性"><a href="#JMM三大特性：原子性、有序性、可见性" class="headerlink" title="JMM三大特性：原子性、有序性、可见性"></a>JMM三大特性：原子性、有序性、可见性</h3><ol><li><p><strong>原子性</strong>：要和数据库事务区别，在并发中指的是多个指令的执行不允许被中断</p><p>在java中如果有一个<code>i++</code>操作，其实分为了三步 load 、add、store，如果运行完load执行后其他线程抢占了时间片，先一次性执行了这三个操作修改了i的值，那么等到原线程回来恢复寄存器后，执行add操作那么add的src操作数还是先开始修改前的值在store回去，那就出问题了，相当于只修改了一次。</p><blockquote><p>那么该如何保证操作的原子性呢？</p><p>通过<strong>锁</strong>实现：<strong>synchronized、lock、AomicInteger（CAS锁）</strong></p></blockquote></li><li><p><strong>有序性</strong>：指令在CPU调度执行时，CPU为了提升效率（比如缓存局部性原理重排后提高cache命中），在不影响结果的前提下，对CPU指令重排序</p><p><strong>重排的原则必须遵循happens-before</strong>，不满足会导致运行结果不同，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">11</span>;<span class="hljs-comment">//1</span><br>    <span class="hljs-type">int</span> y=<span class="hljs-number">11</span>;<span class="hljs-comment">//2</span><br>    x=x+<span class="hljs-number">5</span>;   <span class="hljs-comment">//3</span><br>    y=x*x;   <span class="hljs-comment">//4</span><br>    <span class="hljs-comment">//为了增加cache命中，搞不好顺序就会被重排为1324，但是绝对不会重排为4123（影响结果了）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是指令重排对于单线程是没有问题的，一旦开启多线程就会出现问题,最典型的问题就是单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">//分为三步：1.申请内存空间 2.构造函数 3.返回指针赋值给引用instance</span><br>         <span class="hljs-comment">//原则上，123和132结果都一样</span><br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是多线程情况下，如果new对象的时候三步发生指令重排，<strong>导致2排在3后面</strong>，那么就会出现引用已经拿到对象地址，但是对象还没有执行构造函数，如果其他线程获取到了这个未初始化的引用，那么执行get方法获取属性就有可能会出问题</p><p>如果不希望CPU重排序，JMM给你规范了，可以对属性追加volatile修饰，禁止对该属性的操作指令重排序</p></li><li><p><strong>可见性</strong>：CPU处理时，需要从内存读取数据，走总线传到寄存器中，然后进行计算，算完后将结果写回内存。</p><p>但是，从寄存器写回内存，并不是立即写回而是会遵循MESI协议。这就会导致内存不同步的问题。</p><p>解决方法：volatile每次操作就会写回主存、synchronized触发和释放的时候会同步一次</p></li></ol><h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>happens-before是对有序性和可见性的约束，它是对程序员的承诺，如果你的顺序满足happens-before条件，你就不需要考虑可见性问题，就不要每个变量都要volatile、synchronized</p><p>如果一个操作happens-before另一个操作，那么第一个操作执行结果对第二个操作可见，如果重排序后的结果不会影响满足happens-before规则的执行结果，那么就可以重排序。</p><p>但是JMM对于不会影响happens-before结果的重排序不进行保障，因此还是需要volatile保证有序性，这也被写在happens-before原则中了。</p><blockquote><p>也就说，happens-before其实保证了有序性和可见性，如果发生重排序导致结果不对，那是因为你没有充分利用happens-before，因为你可以利用volatile规则来约束有序性</p><p>happens-before无法保证原子性，即使执行顺序对，但多线程中指令的穿插执行仍然会导致不符合预期的结果</p></blockquote><p>happens-before规则一共有8条</p><ol><li><p><strong>次序规则</strong>：一个线程内，按照代码的顺序，前面的操作先行发生于后面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">11</span>;<span class="hljs-comment">//1</span><br>    <span class="hljs-type">int</span> y=x;<span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中：x&#x3D;11对y&#x3D;x可见这个虽然从直观角度没啥问题，但这个其实是JMM规定的，如果不限制很可能2重排到1前面了</p></li><li><p><strong>锁定规则</strong>：unlock操作发生于<strong>后面</strong>对同一个锁的lock操作</p><blockquote><p>这里后面是指：<strong>多线程下，只要当前unlock时间发生在其他线程lock前面</strong>，那么其他线程看到的一定是解锁的状态</p><p>在后续规则中，凡是涉及<strong>后面</strong>，不做说明都是指多线程中发生时间上的先后，不是代码指令顺序的先后</p></blockquote></li><li><p><strong>volatile变量规则</strong>：对一个volatile的写操作先行发生于<strong>后面</strong>对这个变量的读操作</p></li><li><p><strong>传递规则</strong>：A happens-before B &amp;&amp; B happens-before C -&gt; A happens-before C</p></li><li><p><strong>线程启动规则</strong>：线程的start方法，先行于线程中run方法中的所有指令</p></li><li><p><strong>线程终端规则</strong>：线程的interrupt方法，先行于线程检测到中断事件</p></li><li><p><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检测</p></li><li><p><strong>对象终结规则</strong>：一个对象的构造函数先行发生于它的finalize方法</p></li></ol><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="Volatile用处"><a href="#Volatile用处" class="headerlink" title="Volatile用处"></a>Volatile用处</h3><p>被volatile修饰的变量可以保证变量的可见性和有序性，因为加了volatile就相当于对于这个变量操作加了一条happens-before规则的约束，这个规则可以保证可见和有序</p><p>从<strong>内存访问角度</strong>看：volatile变量的写是直接写到主内存中，读是先让本地内存的旧值无效，再从主内存中读</p><p>那底层是怎么实现的呢？那就是<strong>内存屏障</strong></p><h3 id="从JVM看：内存屏障"><a href="#从JVM看：内存屏障" class="headerlink" title="从JVM看：内存屏障"></a>从JVM看：内存屏障</h3><p>JMM给了8条happens-before规则，那么底层到底是怎么实现的的呢？从JVM层面来看，就是使用内存屏障</p><p>JVM规定了任何虚拟机的实现都需要实现四种内存屏障：LoadLoad、LoadStore、StoreLoad、StoreStore</p><p>就是说这两个操作不能交换顺序，即不允许重排序</p><p>那么对于volatile修饰的变量，就是在读写操作时，加这两个内存屏障就可以保证可见性和有序性</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406022252939.png" alt="image-20240602225236798"></p><h3 id="从Hotpot和CPU看"><a href="#从Hotpot和CPU看" class="headerlink" title="从Hotpot和CPU看"></a>从Hotpot和CPU看</h3><p>volatile有不同的实现方式，比如对于不同的CPU写汇编，插入mfence（全屏障）、lfence（读屏障）、sfence（写屏障），或者就是直接简单粗暴的lock总线，保证同一时间只有一个线程在访问内存</p><p>那么hotpot为了开发更加简单，选择了后者，因为lock指令是不同CPU都提供的指令，更具有普适性</p><h3 id="Volatile的应用"><a href="#Volatile的应用" class="headerlink" title="Volatile的应用"></a>Volatile的应用</h3><p>最典型的就是DCL单例实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;单例初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(singleton==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;<br>                <span class="hljs-keyword">if</span>(singleton==<span class="hljs-literal">null</span>)&#123;<br>                    singleton=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>禁止创建对象的重排序，防止出现先赋值引用再执行初始化的情况</p><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><h3 id="从JMM角度来看"><a href="#从JMM角度来看" class="headerlink" title="从JMM角度来看"></a>从JMM角度来看</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405302238988.png" alt="image-20240530223817853" style="zoom: 33%;" /><p>对于AQS的lock以及synchronized锁，都有可能阻塞线程发生用户态到内核态的转换，因此<strong>CAS更轻量</strong></p><p>CAS全称叫CompareAndSwap，由于一个进程管理资源，当多个线程访问一个资源并且想要修改的时候:</p><ul><li>首先会先把旧值读到工作内存中并保存，然后根据这个值计算，并将结果放入同样保存一份到工作内存</li><li>根据offset和对象本身地址计算目标数据在主内存中的位置，将主存的值和上一步读入工作内存的值比较，如果一样就将计算结果直接写进内存中，否则自旋</li></ul><h3 id="从CPU角度看"><a href="#从CPU角度看" class="headerlink" title="从CPU角度看"></a>从CPU角度看</h3><p>由于Java不用户提供操作内存方法，因此Java的CAS只是给native方法传四个值：</p><p>读到工作内存的值、对象在主存的地址、目标数据相对于对象的偏移、想写入主存的值</p><p>然后根据这四个值，调用<code>CMPXCHG</code>指令，但是不同的CPU平台实现是不一样的，因此会有很多实现</p><p>但是要注意的是，<code>CMPXCHG</code>本身并不能保证原子性，因为对于多核而言<strong>真的会并行</strong>，所以如果是多核CPU那么就要在前面加上lock指令防止别的线程在执行该条指令的时候修改内存</p><blockquote><p>比如，正在从总线往内存写的时候，别的线程也改了，那么还是会覆盖，因此需要加入lock指令，lock指令只允许一个核对同一处内存操作</p></blockquote><p>因此最终CAS的底层实现最终是指令<code>LOCK CPMXCHG CX DX</code>实现的</p><p>CAS虽然不会阻塞线程性能更高，但是会带来一下几个问题：</p><ol><li>只能对一个变量修改保证原子性，无法实现同步代码块</li><li>ABA问题，版本号解决</li><li>如果并发太夸张，导致CAS一直在自旋，占用CPU资源</li></ol><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>由于synchronized的实现和对象头中的markword息息相关，因此先来看看一个java对象的内存组成有哪些</p><h3 id="宏观来看"><a href="#宏观来看" class="headerlink" title="宏观来看"></a>宏观来看</h3><blockquote><p>在说这个之前，我们要先讲讲Java的引用大小问题：</p><p>在64位的OS中一个指针的大小是8B的，但是Java默认开启了<strong>对象头指针压缩</strong>和<strong>成员变量对象指针压缩</strong>，压缩后的指针大小会从8B变成4B</p></blockquote><p>下面来聊一聊对象内存布局，我们以64bit的hotpot JVM为例：</p><p>对象内存布局分为两种，一个是普通对象，一个数组对象</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406032351484.png" alt="image-20240603235114382" style="zoom: 33%;" /><ul><li><p>一个对象分为三个部分：</p><ul><li><p><strong>对象头</strong>，包括markword、class pointer等</p><ul><li>markword，存储了hashcode、GC age等等，并且当成为锁对象后会重写markword（后面再说）</li><li>class pointer，指向方法区类元信息的指针（<strong>不是Class类！</strong>），标注它属于哪个类，由于开启指针压缩因此就是4B</li><li>数组对象会多一个数组长度信息</li></ul></li><li><p><strong>实例数据</strong>，存放数据的地方，但是如果这里有对象，那么就是指针的大小，由于默认开启了指针压缩，因此也是4B，<strong>数组的话就是所有数据按顺序堆叠起来</strong></p></li><li><p><strong>对齐</strong>，由于是64位的JVM，因此对齐按8B对齐</p></li></ul></li></ul><blockquote><p>注意：成员变量的long和Long占的字节分别是8B和4B</p></blockquote><h3 id="Markword"><a href="#Markword" class="headerlink" title="Markword"></a>Markword</h3><p>Markword具体内容和锁的级别息息相关</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202406040003561.png" alt="image-20240604000307369" style="zoom: 45%;" /><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p>早期的Synchronized一上锁就是重量级，但是后面lock出来、CAS出来，Java团队在JDK1.6不得不对synchronized进行了优化，优化总共分为三部分：<strong>锁升级、锁消除、锁粗化</strong></p><p>其中<strong>锁升级</strong>极为重要！！！</p><h3 id="锁升级总体过程"><a href="#锁升级总体过程" class="headerlink" title="锁升级总体过程"></a>锁升级总体过程</h3><p>由于原本的synchronized过于庞大，一使用直接干到内核态，十分消耗时间和资源，因此在JDK1.6中，为了尽可能减少进入内核态的次数，并且<strong>主观上认为synchronized同步的代码块往往并发量不高且运行时间不长</strong></p><p>JDK1.6团队提出了锁升级的概念：<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong></p><p>那么我们先一个一个介绍这几个锁吧</p><p>（太难了，我就自己理解理解，写出来很有可能是错的，有时间把JVM源码看明白了再写）</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>延时、hashCode</p><p>cas_set_mark(mark,header)：查看对象的header是否和mark一样，一样就swap</p><p>偏向锁也会生成lock record（第一次进入都是一个无锁的markword+ref_object，和轻量级锁一样），并且重入一次就会再生成一个</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JIT会对方法进行逃逸分析，如果锁对象并没有出现在调用方法外，那么synchronized(object)就会被JIT无视</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">//该锁对象不会出现在该方法外</span><br>    <span class="hljs-keyword">synchronized</span> (o)&#123;<br>        System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>如果连续很多个代码块，用的同一个锁对象，那么不会synchronized多次，而是只会synchronzied一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">5000</span>);<br>    Object o=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-comment">//连续三个synchronized</span><br>        <span class="hljs-keyword">synchronized</span> (o)&#123;<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (o)&#123;<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (o)&#123;<br>            System.out.println(<span class="hljs-string">&quot;OK&quot;</span>);<br>        &#125;<br>    &#125;).start();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElasticSearch总结</title>
    <link href="/2024/05/18/2024-05-18-ElasticSearch%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/18/2024-05-18-ElasticSearch%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch总结"><a href="#ElasticSearch总结" class="headerlink" title="ElasticSearch总结"></a>ElasticSearch总结</h1><h4 id="ES和MySQL"><a href="#ES和MySQL" class="headerlink" title="ES和MySQL"></a>ES和MySQL</h4><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p>相比于MySQL的文档id找text的方式，es是将text分词过后，通过每个term去找对应文档</p><p>ES中分词后的word叫做term，所以我们这里也&#x3D;都就这么叫了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405180055247.png" alt="image-20240518005521205" style="zoom:50%;" /><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>term是经过排序的一个字典列表，我们称为term dictionary，当然如果把这个放在内存中，一旦数据海量了，必然内存会爆，那么该如何实现搜索呢？</p><p>用的是字符串前缀树，它可以快速锁定前缀在term dictionary中的位置，然后顺序往下找，因此lucence的倒排索引其实最终是长这个样子的：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405180053048.jpeg" alt="img" style="zoom:50%;" /><p>此外，lucence对于term dictionary还有两个优化点：</p><ol><li>term dictionary是以block存储在文件中的，如果block中的term具有相同前缀，可以把term的公共前缀删掉，比如block里面都是 Ab 开头的单词就可以把Ab省去，开头记录一次</li><li>term index底层使用FST存储的（FST后续会看看）</li></ol><h2 id="postings-list"><a href="#postings-list" class="headerlink" title="postings list"></a>postings list</h2><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>对于term dictionary、term index ，ES都进行了底层优化，那么每个term对应的id list（这里叫posting list），肯定也得优化，具体的痛点有这几个：</p><ul><li>虽然说id只是一个唯一标识的字段，但是如果有海量数据，那么id存储空间还是会比较大的，因此如何压缩也是个问题</li><li>对于联合查询，比如and 、or，这些，我们如何对postinglist做交集并集运算？</li></ul><h4 id="存储压缩"><a href="#存储压缩" class="headerlink" title="存储压缩"></a>存储压缩</h4><p>posting list的压缩主要用到了两个技术，分别是FOR（Frame Of Reference）和稀疏位图（Roaring Bitmaps）</p><ul><li><p>FOR</p><p>lucence的FOR就是单纯的做增量存储，由于差值不会特别大，相比于直接存储id，所需的存储空间更小，比如<code>[73, 300, 302, 332, 343, 372]</code>增量存储形式就是<code>[73, 227, 2, 30, 11, 29]</code>。在这个增量列表里面，每个元素都小于255，那么理论上可以只需要8bit就可以存下来了。</p><p>但是ES对于这个做的更精细，他首先将这个posting list同样分成多个block，每个block规定包含256个id，对这些id做增量存储，然后<strong>它会计算这些元素表示所需要的最大bit数是多少</strong>，算出来放在block头里面，进一步实现了位压缩。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405180053261.jpeg" alt="img" style="zoom: 50%;" /><p>比如对于增量列表<code>[73,227,2]</code>，那么最大的227需要8bit存储，因此block头置为8</p><blockquote><p>实际上就是把整型的存储从32位这样的一种表达形式，改成了一个用冗余字段表示的多种表达形式了</p></blockquote></li></ul><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ</title>
    <link href="/2024/05/17/2024-05-17-RocketMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2024/05/17/2024-05-17-RocketMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405170111562.png" alt=" "></p><ul><li>Producer Group：同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</li><li>Consumer Group：同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。<strong>广播模式</strong>下，一个队列的消息会发给每一个消费者，<strong>集群模式</strong>下，每个队列只会和一个消费者绑定，只会被消费一次。</li><li>NameServer Cluster：一个Broker与Topic路由的注册中心，Broker需要和NameServer保持长连接，定时发送心跳检测。并且还保存Broker路由信息以及队列信息，方便Consumer和Producer拉取信息消费。</li><li>BrokerCluster：Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。</li></ul><blockquote><p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的<br>Consumer将不能消费消息。</p><p>此外：</p><ol><li>消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息</li><li>一个消费者组中的消费者必须订阅完全相同的Topic</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405170114120.jpeg" alt="img"></p><h2 id="消息生产和存储"><a href="#消息生产和存储" class="headerlink" title="消息生产和存储"></a>消息生产和存储</h2><h4 id="消息生产"><a href="#消息生产" class="headerlink" title="消息生产"></a>消息生产</h4><p>Producer可以将消息写入到某Broker中的某Queue中，其经历了如下过程：</p><ol><li>向NameServer发出获取消息Topic的路由信息的请求</li><li>NameServer返回该Topic的路由表及Broker列表</li></ol><blockquote><ul><li>路由表：key为topic，value是<strong>队列列表</strong>，但是这个队列列表的元素是按broker为单位分的，也就是说队列列表是一个二维列表</li><li>Broker列表：key为topic，value是<strong>Broker列表</strong>，Broker列表中的元素是一个Broker的主从集群作</li></ul></blockquote><ol start="3"><li>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</li><li>Producer向选择出的Queue所在的Broker发出<strong>RPC</strong>请求，将消息发送到选择出的Queue</li></ol><h4 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h4><ol><li><p>commitLog文件</p><ul><li><p>commitLog存放了所有发到这个Broker上的消息（不区分topic），在RocketMQ的commitlog目录中存放着很多的mappedFile文件，每个文件大小为1G，文件名由20位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p></li><li><p>当一条消息进来后，就会<strong>顺序写入</strong>commitLog，当前mppedFile满了，就会创建新的继续写入</p></li><li><p>其中存放的最小单元是消息单元，</p></li><li><p>包含消息总长度MsgLen、消息的物理位置physicalOffset、消息体内容Body、消息体长度BodyLength、消息主题Topic、Topic长度TopicLength、消息生产者BornHost、消息发送时间戳BornTimestamp、消息所在的队列QueueId、消息在Queue中存储的偏移量QueueOffset等近20余项消息相关属性。</p></li></ul></li><li><p>consumequeue</p><ul><li>RokcetMQ同样也会为每个topic创建一个目录，每个topic目录下会为每个队列创建目录，目录名为queueId</li><li>每个队列目录下放了多个consumequeue文件，它里面存放的每个单元是该消息在commitLog中的偏移量，即存放的是索引</li></ul><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405170134407.png" alt="image-20240517013452373"></p></li></ol><h4 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h4><p>一条消息进入到Broker后经历了以下几个过程才最终被持久化。</p><ul><li>Broker根据queueId，获取到该消息对应索引条目要在consumequeue目录中的写入偏移量，即<br>QueueOffset</li><li>将queueId、queueOffset等数据，与消息一起封装为消息单元，写入到commitlog，形成消息索引条目</li><li>将消息索引条目分发到相应的consumequeue，如果消息包含key，则写入indexFile</li></ul><h2 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h2><h4 id="IndexFile结构"><a href="#IndexFile结构" class="headerlink" title="IndexFile结构"></a>IndexFile结构</h4><p>每个Broker都有一组IndexFile文件，名称是该文件创建时候的时间，一个IndexFile文件分为三个部分，分别是：indexHeader，slots槽位，indexData索引数据</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172344006.png" alt="img"></p><ul><li><p>indexHeader存放的是该索引文件的信息，比如索引条目个数、填充的slot条目个数等等</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172344431.png" alt="img"></p></li><li><p>slots就是一个hsh表，存放的是该索引条目在indexData中的位置，其底层处理冲突的方式是拉链法</p></li><li><p>indexData存放的是索引数据，存放对应msg在commitLog中位置等信息</p></li></ul><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172344523.png" alt="img"></p><blockquote><p>timeDiff是插入这条index时候距离索引创建时间（索引文件名获取）的偏移，方便按时间查找</p></blockquote><h4 id="IndexFile写入"><a href="#IndexFile写入" class="headerlink" title="IndexFile写入"></a>IndexFile写入</h4><p>当一个消息需要存到indexFile中的时候，会经过一下几个步骤：</p><ol><li><p>计算key的hash值，然后试图存放到indexFile中，会有两种情况需要新建一个indexFile：</p><ul><li>当前为第一个消息，还没有indexFile</li><li>indexFile的索引个数达到2000W，那么也需要新建</li></ul></li><li><p>存放的时候，会将hash(key)%500w，结果为存放的slots位置</p><ul><li><p>如果没有发生冲突，那么直接存放到indexData中，前驱indexDataNo置为空，并将该slots对应的indexNo置为存放的位置</p></li><li><p>如果发生冲突，就需要使用拉链法处理，构建indexData后，需要将原本slot底下的indexData的前驱indexDataNo置为新的indexDat的位置，然后slot也存放新的indexDataNo</p><blockquote><p>slot只存放最新的indexData在index部分的位置，类似undo log，index存放的才是实际拉链的链表顺序结构</p></blockquote></li></ul></li></ol><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><h4 id="维护顺序"><a href="#维护顺序" class="headerlink" title="维护顺序"></a>维护顺序</h4><p>对于<strong>集群模式</strong>而言：在RocketMQ的服务端有一个<code>ConsumserOffset.json</code>文件，他保存了每个消费者组对于每个消费队列的消费进度，每次发送pull request都会先找broker要offset</p><p>对于<strong>广播模式</strong>而言：由于每个消费者都要去消费topic的每个消息，因此这个offset保存在本地，不用去远程拉</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405172353960.png" alt="image-20240517235309926"></p><h4 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h4><p>当一个消费者start后，就会调用pullMessageService.start()，这个就就会开启一个线程，做的事情就是从一个阻塞队列里面去读，读到一个pullRequest就拉去消息，然后回调pushCallBack函数处理消息，处理完就会更新pullRequest然后再放回去，这就实现了推送型接收</p><p>那么还有两个问题：</p><ol><li><p>pullRequest怎么放进去的？</p><p>负载均衡的时候，会重新分配一个队列，分配完就会将这个队列对应的pullRequest放进去</p><p>也就是说，一个队列对应一个pullRequest</p></li><li><p>如果pull的时候没有消息怎么办？</p><p>Broker的<strong>长轮询机制</strong>，Broker收到pullRequest后先根据tag过滤，然后看看对应的offset有没有新消息，有就立刻返回，没有就保留pullRequest，每五秒查询一次，查到再返回</p></li></ol><blockquote><p>pullConsumer就是单纯的从某个地方拉取多少条消息，没啥好说的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团面试笔试题</title>
    <link href="/2024/05/11/2024-05-11-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <url>/2024/05/11/2024-05-11-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团面试笔试题"><a href="#美团面试笔试题" class="headerlink" title="美团面试笔试题"></a>美团面试笔试题</h1><h2 id="多线程求和"><a href="#多线程求和" class="headerlink" title="多线程求和"></a>多线程求和</h2><p>输入一个int数组，和线程个数K，多线程求和输出最终sum</p><p>这题其实就是多线程，要注意的是如何给每个线程分配要求和的部分。其实可以有很多种方法，比如取模，或者直接暴力顺序拆分，而我在面试中使用的就是取模方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zenith.example.solution;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SumCalculator [] threads=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SumCalculator</span>[k];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            threads[i]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SumCalculator</span>(i);<br>            threads[i].start();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(SumCalculator thread:threads)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                thread.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (SumCalculator thread : threads) &#123;<br>            sum += thread.getSum();<br>        &#125;<br><br>        System.out.println(sum);<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SumCalculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sum;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SumCalculator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>            <span class="hljs-built_in">this</span>.index=index;<br>            <span class="hljs-built_in">this</span>.sum=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i*k+index&lt;array.length;i++)&#123;<br>                sum+=array[i*k+index];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="前K个频率最高数字"><a href="#前K个频率最高数字" class="headerlink" title="前K个频率最高数字"></a>前K个频率最高数字</h2><p>给你一个数组，和一个K。返回前K个出现频率最高的数字，最终输出一个数组</p><p>不管怎样，首先肯定先要用一个map来统计每个数字出现的个数。</p><h4 id="O-nlogn-方法"><a href="#O-nlogn-方法" class="headerlink" title="O(nlogn)方法"></a>O(nlogn)方法</h4><p>暴力排序，我们可以直接用不限容量的优先队列，一个一个往里放，最后输出前n个就行</p><p>但是这个方法可以优化</p><h4 id="O-nlogk-方法"><a href="#O-nlogk-方法" class="headerlink" title="O(nlogk)方法"></a>O(nlogk)方法</h4><p>由于我们只需要前k个，因此我们通过使用容量为K的优先队列</p><p>如果key的次数大于优先队列队尾的次数，那么就替换掉，由于优先队列是小顶堆且容量为K，因此时间复杂度为klogk，然后我们要从头遍历一次，最终为nlogk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zenith.example.solution;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:array)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.getOrDefault(num , <span class="hljs-number">0</span>);<br>            map.put(num ,cur+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>                <span class="hljs-keyword">return</span> map.get(a) - map.get(b);<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span>(Integer key:map.keySet())&#123;<br>            <span class="hljs-keyword">if</span>(pq.size()&lt;k)&#123;<br>                pq.add(key);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(map.get(key)&gt;map.get(pq.peek()))&#123;<br>                pq.poll();<br>                pq.offer(key);<br>            &#125;<br>        &#125;<br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            res.add(pq.poll());<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="O-n-的方法"><a href="#O-n-的方法" class="headerlink" title="O(n)的方法"></a>O(n)的方法</h4><p>我们还有一个极致的空间换时间的方法，由于次数对应的数字是唯一的，那么我们可以直接反过来保存从次数到数字的映射，然后次数最大不会超过n，那么我们就从n反过来遍历，有数字就输出，直到输出了k个数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zenith.example.solution;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[]array=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> k=<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:array)&#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> map.getOrDefault(num , <span class="hljs-number">0</span>);<br>            map.put(num ,cur+<span class="hljs-number">1</span>);<br>        &#125;<br><br>        Map&lt;Integer,Integer&gt; countMap=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(Integer key:map.keySet())&#123;<br>            countMap.put(map.get(key),key);<br>        &#125;<br><br>        List&lt;Integer&gt; res=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=array.length;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!countMap.getOrDefault(i,-<span class="hljs-number">1</span>).equals(-<span class="hljs-number">1</span>))&#123;<br>                res.add(countMap.get(i));<br>                k--;<br>            &#125;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列基础</title>
    <link href="/2024/05/10/2024-05-10-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/10/2024-05-10-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="消息队列基础"><a href="#消息队列基础" class="headerlink" title="消息队列基础"></a>消息队列基础</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="MQ能干什么"><a href="#MQ能干什么" class="headerlink" title="MQ能干什么"></a>MQ能干什么</h4><p>MQ做的是事儿就是三大点：<strong>异步、解耦、削峰</strong></p><ol><li><p>异步</p><p>对于不同服务之间的相互调用，如果使用RPC的话那么就是同步的，一旦调用链很长就会十分耗时。</p><p>使用消息队列，就可以立即返回处理好的结果，剩下的后续的补充操作（比如秒杀后的创建订单、发送验证码）可以通过消息队列由Consumer尽自己最大能力的执行</p></li><li><p>解耦</p><p>为了保证服务的可扩展性，主服务可以只管发布消息，至于后续有多少其他服务接入进来不关主服务的事儿了，只需要订阅这个topic就好了。</p><p>但是如果不使用消息队列，每次增删改一个其他操作，就需要修改代码，耦合性很大</p></li><li><p>削峰</p><p>其实就是为了解决不同服务之间的性能差异，如果使用同步RPC调用，抛开耗时不谈，一旦主服务和子服务性能差异很大，那么当主服务接受很多请求的时候同步调用子服务就会导致子服务崩溃。</p><p>使用消息队列，可以缓存这些高并发的请求，由子服务尽最大努力的处理请求</p></li></ol><h4 id="MQ带来的问题"><a href="#MQ带来的问题" class="headerlink" title="MQ带来的问题"></a>MQ带来的问题</h4><p>加入这样一个中间件虽然有好处，但是也带来了很多副作用</p><ul><li>加入中间件首当其冲的就是会增加系统的复杂度，这个中间件挂了怎么办？集群怎么搞？消息丢失了怎么办？</li><li>消息重复消费问题，保证幂等性</li><li>消息顺序消费问题，到达有序并且发送有序，那么重发过后如何保证严格有序呢？</li><li>分布式事务问题，如果有一串消息需要作为事务执行，那么如何保证一起提交一起回滚？</li><li>消息堆积问题，如果消费者不给力或者其他原因，导致消息队列内存要满了怎么办？</li></ul><h4 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h4><ul><li><strong>队列模型</strong>很简单，就是把消息放到队列里面去，一个生产一个读取，没什么好说的，就是一个1对1的架构</li><li><strong>主题模型</strong>就不一样了，生产者只会一股脑的发送消息，放一个叫主题的地方，消费者可以自行订阅主题，只要订阅了这个主题的消费者，就会收到该主题关联的消息</li></ul><h2 id="MQ相关问题的解决"><a href="#MQ相关问题的解决" class="headerlink" title="MQ相关问题的解决"></a>MQ相关问题的解决</h2><h4 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h4><p>顺序消费分为<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。前者就是同一个消费队列收到的消息是有顺序的，后者则是消费者收到的所有消息有序，即使发生重试也要保证有序</p><p>严格有序会导致系统的性能严重下降，因为需要十分严格的确认机制</p><p>这里我们讨论普通有序，那就是正常解决方案，同一业务流发送到同一队列，消费者使用缓存队列开启本地多线程，然后同一业务流分配给同一线程</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>RocketMQ的分布式事务分为两个阶段，一个是发送事务，一个是消费事务</p><h4 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h4><p>这里我们需要注意的是，我们无法一味的增加消费者，因为RocketMQ的queue只会绑定一个Consumer，如果消费者数目大于queue，那么就失效了</p><p>其次，我们要看看是不是消费者消费过慢了，还是生产者发送太快了。</p><p>我们可以同时增加队列和消费者来解决，或者让同一个消费者本地开多线程去解决</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>Producer、Cosumer、Broker、Topic、Partition</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405100116685.png" alt="img" style="zoom:50%;" /><p>Partition的多副本，为每个Partiotion搞了一堆副本（可以指定数量），然后里面有一个leader副本，其他相当于备份副本，只有leader副本才会和Producer、Consumer交互</p><h4 id="Kafka消息的有序性"><a href="#Kafka消息的有序性" class="headerlink" title="Kafka消息的有序性"></a>Kafka消息的有序性</h4><p>我们要知道的是，对于Kafka来说对于一个Partition中的消息是有序的，因此解决方案两种：</p><ol><li>每个Topic只分配一个Partition（但是这肯定不合理！）</li><li>对于同一个业务流，我们发送到同一个partition，比如对于同一个订单的操作，我们根据订单的id决定发送到那个partition上</li></ol><h4 id="Kafka如何保证消息不丢失"><a href="#Kafka如何保证消息不丢失" class="headerlink" title="Kafka如何保证消息不丢失"></a>Kafka如何保证消息不丢失</h4><p>丢失消息会出现在三个地方</p><ul><li>生产者：保证到达kafka，send的回调机制</li><li>Kafka内部：集群的某个节点丢失，多副本机制</li><li>消费者：offset手动</li></ul><h4 id="Kafka消息重复消费问题"><a href="#Kafka消息重复消费问题" class="headerlink" title="Kafka消息重复消费问题"></a>Kafka消息重复消费问题</h4><p>Consumer端做幂等性</p><h4 id="Kafka重试机制"><a href="#Kafka重试机制" class="headerlink" title="Kafka重试机制"></a>Kafka重试机制</h4><p>这会导致一个问题，重试过后，原本顺序为AB的发送顺序变成了BA</p><p>要保证这种严格的顺序消费，可以设置<code>max.in.flight.requests.per.connection</code>这个参数</p><p>该参数指定了生产者在收到服务器响应之前可以发送多少个消息（ACK一个才能往Kafka发一个）。它的值越高，就会占用越多的内存，同时也会提升吞吐量。把它设为1就可以保证消息是按照发送的顺序写入服务器的</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis总结</title>
    <link href="/2024/05/08/2024-05-08-Redis%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/08/2024-05-08-Redis%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h1><h2 id="Redis基础问题"><a href="#Redis基础问题" class="headerlink" title="Redis基础问题"></a>Redis基础问题</h2><h3 id="Redis可以用来做什么"><a href="#Redis可以用来做什么" class="headerlink" title="Redis可以用来做什么"></a>Redis可以用来做什么</h3><p>一般来说，我用到最多的就是两个：一个是<strong>缓存</strong>，一个是<strong>分布式锁</strong></p><p>还有一些其他的应用，比如排行榜、计数器这种的</p><p>而至于有人说可以做消息队列、延迟队列啥的我觉得没有必要，因为有专门的东西来做比如RabbitMQ</p><h3 id="Redis为啥这么快"><a href="#Redis为啥这么快" class="headerlink" title="Redis为啥这么快"></a>Redis为啥这么快</h3><p>这是一个很老的问题，总的来说一共有三点：</p><ol><li><p>Redis是基于内存的，当然比基于磁盘的MySQL这种数据库快</p></li><li><p>Redis是单线程的，可以避免线程切换、锁获取释放的时间开销。</p><blockquote><p>但是我认为这也是高并发场景下的结果，如果并发不高，其实这个开销相比于多线程并行的提升可以忽略掉</p></blockquote></li><li><p>Redis采用的I&#x2F;O是多路复用。多路复用其实就是内核等待I&#x2F;O准备好通知内核来读取，而不是一直等待或者轮询I&#x2F;O是否准备就绪</p></li></ol><blockquote><p>如果要问你Redis这么快的主要原因，那么一定是基于内存的，这个相比于磁盘读取的速度快的可不是一星半点！</p></blockquote><h2 id="Redis的线程模型"><a href="#Redis的线程模型" class="headerlink" title="Redis的线程模型"></a>Redis的线程模型</h2><p>Redis快的一个原因就是IO多路复用，那么到底在什么地方用了呢？多线程又是在什么地方用了呢？</p><h3 id="Redis那些地方用了多线程"><a href="#Redis那些地方用了多线程" class="headerlink" title="Redis那些地方用了多线程"></a>Redis那些地方用了多线程</h3><ol><li>Redis2.6的时候，加了两个后台线程，一个是<strong>AOF刷盘</strong>，一个是<strong>异步文件关闭</strong></li><li>Redis4.0的时候，新增一个后台线程，用于异步释放key。比如调用“unlink key”指令的时候，就是异步释放内存。</li></ol><blockquote><p>也就说说，如果用的时候4.0以上版本，我们释放大key的时候，最好用<code>unlink</code>，而不是同步删除指令<code>del</code></p></blockquote><ol start="3"><li>Redis6.0以后，由于发现Redis的瓶颈在于内存和网络IO，而不是CPU，因此在网络IO处开启了多线程，默认是4个，可以修改配置</li></ol><h3 id="Redis的事件触发机制"><a href="#Redis的事件触发机制" class="headerlink" title="Redis的事件触发机制"></a>Redis的事件触发机制</h3><ul><li>首先，Redis的事件驱动模块就是一个无限循环的IO多路复用，它会一直循环如果发现有socket准备好，就会触发相应的事件处理器然后处理。</li><li>当事件触发后，就会先执行<code>beforeSleep</code>，然后获取触发的事件并一个一个处理事件，最后执行<code>afterSleep</code>。</li></ul><blockquote><p>比如：当新建事件触发后，就会注册命令请求处理器，<strong>绑定回调函数</strong><code>readQueryFromClient</code>，一旦客户端发起命令请求就会触发该事件，就会先执行<code>beforeSleep</code>，执行<code>readQueryFromClient</code>方法，最后执行<code>afterSleep</code></p></blockquote><h3 id="Redis6-0之前的单线程模式"><a href="#Redis6-0之前的单线程模式" class="headerlink" title="Redis6.0之前的单线程模式"></a>Redis6.0之前的单线程模式</h3><ul><li><p>在单线程模式中，发生命令请求，就会调用<code>readQueryFromClient</code>方法，该方法会读取socket并解析，解析后执行命令，最后会将返回结果写到缓冲区中，但是<strong>并没有写回客户端</strong>！</p></li><li><p>真正写回客户端，<strong>是在第二次事件触发的<code>beforeSleep</code>后</strong>，才会调用<code>handleClientsWithPendingWrites</code>，写回客户端。</p></li></ul><blockquote><p>要注意的是，单线程模式中，从读取socket到最后执行命令写到结果缓冲区，都是主线程通过for循环一个一个处理的</p></blockquote><h3 id="Redis6-0的多线程"><a href="#Redis6-0的多线程" class="headerlink" title="Redis6.0的多线程"></a>Redis6.0的多线程</h3><p>Redis6.0除了执行命令是主线程做的，从读取socket到解析命令都是IO线程做的，并且从结果缓冲区写回客户端也是IO线程做的。</p><ul><li>第一次事件触发的时候，由于写缓冲区没有数据，因此<code>beforeSleep</code>不会触发<code>handleClientsWithPendingWrites</code>，那么执行<code>readQueryFromClient</code></li><li>在<code>readQueryFromClient</code>中，会先判断是否开启多线程<ul><li>如果开启，那么就会将这些socket请求放到pending_read队列中，并标记为pending_read，然后就执行结束，直接进入aferSleep</li><li>如果没开启，那么就跟单线程一样，从读取socket到最后把结果写到缓冲区一直由主线程执行完</li></ul></li><li>在afterSleep中，会执行<code>handleClientsWithPendingReadsUsingThreads</code>，如果开启多线程，那么就会分配给多个IO线程让它们去执行<code>readQueryFromClient</code></li><li>由于已经标记为pending_read了，那么就会读取socket并解析命令而不是再次放到pending_read队列中，最后标记为pending_command（<strong>如果不标记，就会按照单线程逻辑继续顺序执行到<code>processCommandAndResetClient</code>执行命令</strong>，但是标记后解析完就会直接返回了）</li><li>在主线程中会while(1)，等待这些IO执行完，执行完后就会统一顺序执行<code>processCommandAndResetClient</code>方法，执行命令写到结果缓冲区，当下次事件触发，就会在<code>beforeSleep</code>方法中执行<code>handleClientsWithPendingWrites</code>方法，写回客户端</li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis既然是基于内存的，那么他是如何保证数据不丢失的呢？</p><p>答案就是持久化，redis给了三种持久化的方式：<strong>AOF</strong>、<strong>RDB</strong>、Redis4.0以后的<strong>混合持久化</strong></p><h3 id="AOF持久化概述"><a href="#AOF持久化概述" class="headerlink" title="AOF持久化概述"></a>AOF持久化概述</h3><p>AOF(Append Only File)，会将redis执行的每一条写命令追加到AOF日志文件中，然后重启redis后就会顺序执行文件中的命令并执行它，就相当于恢复数据了</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321174.png" alt="img" style="zoom: 50%;" /><p>可以看出，和mysql的双写日志不一样，redis这里是先执行命令再写到日志为什么呢？</p><ul><li><strong>避免额外检查的开销</strong>。如果执行的命令有错，你在执行前就写到AOF日志中，要么就得校验要么就等指令出错再回滚。这两种方法都要多花时间。</li><li><strong>不会阻塞当前写操作命令的执行</strong>。因为是先执行命令再写日志，那么当前命令可以得到立即执行，最后写日志，不会受到写日志的IO阻塞</li></ul><p>当然，这样做也不是没有风险：</p><ul><li><p>还是会出现数据丢失的情况，如果执行完命令，还没来得及把AOF写入磁盘就宕机了，就会发生数据丢失</p></li><li><p>如果并发很高，指令很密，那么就会影响后面指令的执行</p></li></ul><h3 id="AOF文件刷盘策略"><a href="#AOF文件刷盘策略" class="headerlink" title="AOF文件刷盘策略"></a>AOF文件刷盘策略</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405272321396.png" alt="img" style="zoom:50%;" /><p>上述发生数据丢失，都是和AOF数据刷盘时机相关的，Redis给出了三个策略：</p><ul><li><strong>Always</strong>：每次写操作命令执行完后，同步将AOF日志数据写回硬盘。<strong>只会发生一条指令的丢失</strong></li><li><strong>Everysec</strong>：每次写操作命令执行完后，先将命令写入到AOF文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘。<strong>会发生1秒钟的数据丢失</strong></li><li><strong>No</strong>：不由 Redis 控制写回硬盘的时机，将命令写入到 AOF 文件的内核缓冲区后，由操作系统决定何时将缓冲区内容写回硬盘。<strong>无法确定</strong></li></ul><blockquote><p>其实，控制从内核缓冲区写到磁盘，就是调用<code>fsync()</code>函数</p></blockquote><h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>如果Redis一直持续的执行写命令，那么总有时候AOF文件的大小会超过阈值导致磁盘溢出，因此Redis提供了一个AOF重写机制，当大小超过用户设置的阈值的时候，就会执行重写，压缩AOF文件</p><blockquote><p>当AOF文件大小大于<strong>64M</strong>的时候，执行重写机制就会通过后台线程执行，底层是通过fork子进程来实现的：</p><p>fork的子进程最先是和父进程共享内存，但是只是<strong>只读模式</strong>，一旦有一方进行写操作，内存就会发生<strong>写时复制</strong>，二者独立内存</p><p>要注意的是：写时复制<strong>操作的只是发生异常的页</strong>，而不是整个内存全部复制</p></blockquote><p>因此，如果主进程接收到写命令，那么就会发生内存复制，出现数据不一致的情况，该怎么解决呢？</p><ul><li>Redis又提供了一个<strong>AOF重写缓冲区</strong>，在AOF执行重写的时候，主进程出了执行写命令和写到AOF缓冲区以外，还会写入AOF重写缓冲区</li><li>当子进程重写结束后，<strong>主进程</strong>会将AOF重写缓冲区的内容写到新的AOF文件，然后对原AOF文件覆盖</li></ul><p><strong>AOF后台重写发生阻塞的地方</strong>：写时复制、AOF重写缓冲区写入</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB（Redis DataBase）快照用于保存某一瞬间Redis内存的完整状态，因此相比于AOF：</p><ul><li><strong>RDB恢复时间更快</strong>，直接读入内存而不是一条条指令的执行</li><li>但是由于需要保存内存的完整内容，因此<strong>耗费资源更多</strong></li></ul><p>RDB快照生成有两种方式：save和bgsave，其中后者是fork一个子进程进行保存。那么既然涉及子线程就会涉及写时复制，在RDB的bgsave中我们要注意的是：</p><blockquote><ul><li>写时复制保证了快照保存的是执行bgsave指令那一刻的内存快照，因为一旦主线程修改了某个key，那么其涉及的物理页就会发生写时复制，fork的子进程仍然会保存旧key的值</li><li>极端情况就是所有物理页都被修改，那么就会复制所有物理页导致redis占用内存为<strong>原本的两倍</strong>，发生内存溢出</li></ul></blockquote><p>RDB的bgsave指令会有以下几种情况会执行：</p><ol><li>用户配置的，多少秒内修改多少次就会自动执行bgsave</li><li>redis关闭的时候，会自动bgsave以下</li><li>主动在客户端执行</li></ol><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>RDB优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p><p>AOF 优点是丢失数据少，但是数据恢复不快。</p><p>因此，Redis4.0推出了混合持久化：</p><ul><li>在AOF重写日志的时候，fork一个子进程，先保存当前内存的RDB快照到AOF文件中</li><li>同时，主线程修改的数据会被记录在AOF重写缓冲区中</li><li>RDB快照保存到AOF文件后，就会将AOF重写缓冲区的内容追加到AOF文件的RDB快照后面</li><li>最后，<strong>AOF重写后的文件前一半是RDB快照，后一半是AOF日志</strong></li></ul><h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><h3 id="Redis底层的key和value是怎么存储的？"><a href="#Redis底层的key和value是怎么存储的？" class="headerlink" title="Redis底层的key和value是怎么存储的？"></a>Redis底层的key和value是怎么存储的？</h3><ul><li>Redis的value和eky都被Redis统一包装为了redisObject类型，其中key的ptr是SDS</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<span class="hljs-comment">//对象类型（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<span class="hljs-comment">//编码（4位=0.5字节）</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;<span class="hljs-comment">//记录对象最后一次被应用程序访问的时间（24位=3字节）</span><br>    <span class="hljs-type">int</span> refcount;<span class="hljs-comment">//引用计数。等于0时表示可以被垃圾回收（32位=4字节）</span><br>    <span class="hljs-type">void</span> *ptr;<span class="hljs-comment">//指向底层实际的数据存储结构(8字节)</span><br>&#125; robj;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280040314.png" alt="img" style="zoom: 50%;" /><ul><li>二者被封装为dictEntry，作为hash表中的对象</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key;<span class="hljs-comment">//指向key，即sds</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<span class="hljs-comment">//指向value</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个key-value键值对(拉链法解决哈希冲突)</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280038734.png" alt="img" style="zoom: 33%;" /><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>这是Redis最基本的key-value结构，这里的String类型不仅仅是字符串，也可以是数字（整数、浮点数），也可以是二进制字节，它的大小最大可以达到<strong>512M</strong></p><p>Redis底层的String是自己设计的：<strong>简单动态字符串SDS</strong>（Simple dynamic string），Redis3.2以前如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span>&#123;</span><br>  <span class="hljs-type">int</span> len;<span class="hljs-comment">//记录buf数组已使用的长度，即SDS的长度(不包含末尾的&#x27;\0&#x27;)</span><br>  <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<span class="hljs-comment">//记录buf数组中未使用的长度</span><br>  <span class="hljs-type">char</span> buf[];<span class="hljs-comment">//字节数组，用来保存字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在redisObject中，SDS字符串对应的type就是<code>REDIS_STRING</code>，而encoding编码方式有三种：</p><ul><li><ul><li>int编码（OBJ_ENCODING_INT）：当存储的字符串是整型，并且可以用long表示，redisObject中的联合体的<strong>value指针直接从void*变为unit_64</strong></li></ul></li><li>embstr编码（OBJ_ENCODING_EMBSTR）：当当字符串对象中存储的是字符串，且长度小于 44 （Redis3.2版本之前是 39）时，Redis会选择使用embstr编码来存储。这时候，redisObject和SDS的内存是连续的</li></ul><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280017411.png" alt="img"></p><ul><li>raw编码（OBJ_ENCODING_RAW）：当字符串对象中存储的是字符串，且长度大于embstr编码规定的长度，那就会采取raw编码进行存储。此时，ptr指针指向SDS的内存地址</li></ul><blockquote><p>embstr编码</p><ul><li>embstr由于是和redisObject连续存储的，因此申请和释放内存的时候只需要进行一次操作</li><li>但是embstr是只读的，一旦使用append改写，即使没有超出embstr长度限制，也<strong>会升级为raw且不会回退</strong>（int的append同理，int编码append后，就没法进行incr这种操作了）</li><li>由于redisObject被规定为大小不能大于64字节，而其本身的固定长度就是16字节，那么除去SDS的额外长度剩下的就是embstr的最大存储字符长度了：<ul><li>Redis3.2之前，由于有一个flag和一个len都是int，因此是8字节，然后字符串还有个’\0’，所以是<strong>64-16-8-1&#x3D;39字节</strong></li><li>而Redis3.2之后，对于64字节的字符串做了优化，变成了sdshdr8类型，这个类型的额外字段长度为1+1+1&#x3D;3字节的长度，除去’\0’，那么最后为<strong>64-16-3-1&#x3D;44字节</strong></li></ul></li></ul></blockquote><p>Redis3.2对于不同长度的SDS，有不同定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr5</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^5=32B</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, and 5 msb of string length */</span><br>    <span class="hljs-comment">//实际存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^8=256B</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-comment">//除去头跟空终止符分配的空间</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">//标识字符，3位用于类型，5位未使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-comment">//使用存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^16=64KB</span><br>    <span class="hljs-type">uint16_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint16_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^32=4GB</span><br>    <span class="hljs-type">uint32_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint32_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr64</span> &#123;</span><br>    <span class="hljs-comment">//长度为2^64，但redis规定string长度小于512M，故没用过</span><br>    <span class="hljs-type">uint64_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-type">uint64_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果调用redis的append函数导致sds超出分配的buf大小即alloc大小，那么就会<strong>扩容</strong>：</p><ul><li>如果大小小于1MB，那么翻倍扩容</li><li>如果大于1MB，那么递增1MB的方式扩容</li><li><strong>如果发现sds的类型对应的大小超过了</strong>，那么就会重新申请空间，并释放掉原有的sds空间</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List类型的底层数据结构是由list或ziplist实现的，而redis3.2后就用quicklist实现了</p><ul><li>如果列表的元素个数小于 512 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 64字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li></ul><p>在Redis3.2版本之后，List数据类型底层数据结构就<strong>只由quicklist实现了</strong></p><ol><li><strong>list数据结构</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> &#123;</span><br>    <span class="hljs-comment">//前置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-comment">//后置节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">listNode</span> *<span class="hljs-title">next</span>;</span><br>    <span class="hljs-comment">//节点的值</span><br>    <span class="hljs-type">void</span> *value;<br>&#125; listNode;<br></code></pre></td></tr></table></figure><p>Redis中的listNode就是正常定义的，但是redisObject中的ptr指向的是重新包装后的list对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-comment">//链表头节点</span><br>    listNode *head;<br>    <span class="hljs-comment">//链表尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">//节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值释放函数</span><br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值比较函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">//链表节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>&#125; <span class="hljs-built_in">list</span>;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280101820.png" alt="img" style="zoom: 33%;" /><ol start="2"><li><strong>ziplist数据结构</strong></li></ol><p>list无法很好的利用cpu缓存并且额外数据太多，因此redis设计了一个内存紧凑型的数据结构——<strong>压缩链表</strong>：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280104063.png" alt="img" style="zoom:50%;" /><ul><li><strong>zlbytes</strong>：记录整个压缩列表占用对内存字节数</li><li><strong>zltail</strong>：记录末尾节点距离起始地址多少字节，也就是列表尾的偏移量</li><li><strong>zllen</strong>：记录压缩列表包含的节点数量</li><li><strong>zlend</strong>：标记压缩列表的结束点，固定值 0xFF</li></ul><p>压缩列表节点包含三部分内容：</p><ul><li><strong>prevlen</strong>：记录了「前一个节点」的长度，目的是为了实现从后向前遍历<ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值</li></ul></li><li><strong>encoding</strong>：记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数</li><li><strong>data</strong>：记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定</li></ul><blockquote><p>encoding的类型有很多：1个字节的类似uint_8, unit_16这种整型，还有字符串类型（因为要额外保存字符串长度，会根据长度决定使用1字节&#x2F;2字节&#x2F;5字节的空间来保存，而整型的类型就已经决定了长度，不需要额外保存）</p></blockquote><blockquote><p><strong>连锁更新</strong></p><p>由于前一个节点的长度大于等于254，prelen就会变成5个字节，那么：</p><ul><li>如果当前所有节点长度全是250-253之间，这时候在头部插入一个长度为255的字节的listNode</li><li>那原本的一个节点的prelen就会变成5字节导致自己的长度也超过255</li><li>那么原本第二个节点的prelen也会变为5字节，以此类推<strong>最后全量更新扩容</strong></li></ul></blockquote><ol start="3"><li><strong>quicklist数据结构</strong></li></ol><p>quicklist就是<strong>双向链表+压缩链表</strong>，其底层就是一个双向链表，然后listNode的data是一个压缩链表</p><blockquote><p>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能</p></blockquote><ul><li>和list一样，先定义链表节点quicklistNode</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>     <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-comment">//下一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">//后一个quicklistNode</span><br>    <span class="hljs-comment">//quicklistNode指向的压缩列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;              <br>    <span class="hljs-comment">//压缩列表的的字节大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;                <br>    <span class="hljs-comment">//压缩列表的元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;        <span class="hljs-comment">//ziplist中的元素个数 </span><br>    ....<br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><ul><li>再用quicklist封装至redisObject</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    <span class="hljs-comment">//quicklist的链表头</span><br>    quicklistNode *head;      <span class="hljs-comment">//quicklist的链表头</span><br>    <span class="hljs-comment">//quicklist的链表尾</span><br>    quicklistNode *tail; <br>    <span class="hljs-comment">//所有压缩列表中的总元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;<br>    <span class="hljs-comment">//quicklistNodes的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;       <br>    ...<br>&#125; quicklist;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405280117106.png" alt="img" style="zoom:50%;" /><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的，Redis7.0以后<strong>压缩链表被listpack代替</strong>：</p><ul><li>如果列表的元素个数小于512个（默认值，可由<code>list-max-ziplist-entries</code>配置），列表每个元素的值都小于64字节（默认值，可由<code>list-max-ziplist-value</code>配置），Redis会使用<strong>压缩列表</strong>作为List类型的底层数据结构</li><li>如果列表的元素不满足上面的条件，Redis 会使用<strong>哈希表</strong>作为Hash类型的底层数据结构</li></ul><p>压缩列表前面已经说过了，接下来我们来看一看hash和listpack</p><ol><li><strong>Hash数据结构</strong></li></ol><p>Redis的哈希表结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    <span class="hljs-comment">//哈希表数组</span><br>    dictEntry **table;<br>    <span class="hljs-comment">//哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;  <br>    <span class="hljs-comment">//哈希表大小掩码，用于计算索引值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-comment">//该哈希表已有的节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303665.png" alt="img" style="zoom:33%;" /><p>可以看出，Redis处理哈希冲突的方法是拉链法，但是Redis中的hash表是如何扩容的呢？</p><p>Redis对hash表的dictht又再次封装了一层，用于<strong>解决rehash问题</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    …<br>    <span class="hljs-comment">//两个Hash表，交替使用，用于rehash操作</span><br>    dictht ht[<span class="hljs-number">2</span>]; <br>    …<br>&#125; dict;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302097.png" alt="img" style="zoom: 33%;" /><ul><li><p>Redis定义了两个dictht，用于扩容的时候一个提供使用，一个用于扩容</p></li><li><p>一般情况下，Redis只会使用ht[0]，只要发生rehash的时候，才会使用ht[1]</p></li><li><p>当达到rehash条件的时候，就会开始rehash，由于防止哈希表数据过多，导致阻塞主线程时间过长，因此数据迁移并不是一次完成，而是使用一个渐进hash的策略：</p><ul><li>给ht[1]分配空间，一般会比ht[0]大一倍</li><li>在rehash期间，新增操作全部在ht[1]中完成</li><li>对于查找、删除、更新操作，先去ht[0]中找找到就直接对ht[0]操作，没找到再对ht[1]操作</li></ul><blockquote><p>上述两个操作，可以保证ht[0]的数据只会一直减少，不会增加</p></blockquote><ul><li>每次对该hash表操作时，就会按顺序从ht[0]中迁移一部分数据到ht[1]中，最终一定会迁移完毕</li></ul></li></ul><ol start="2"><li>listpack数据结构</li></ol><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282303192.png" alt="img" style="zoom: 33%;" /><p>相比于ziplist，listpack的每个entry不再存储前一个node的长度，而是指存储自己的长度</p><p>这样，当插入节点的时候，不会引起其他节点的长度变化，从而<strong>解决了连锁更新的问题</strong></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于512（默认值，set-maxintset-entries配置）个，Redis会使用<strong>整数集合</strong>作为Set类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则Redis使用<strong>哈希表</strong>作为Set类型的底层数据结构</li></ul><h3 id="Zset——跳表skipList"><a href="#Zset——跳表skipList" class="headerlink" title="Zset——跳表skipList"></a>Zset——跳表skipList</h3><p>在Zset中，底层一个实现就是跳表和哈希表，但是哈希表仅仅只是用来以O(1)的复杂度查询元素的分数，底层的范围查询啥的还是通过skipList实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zset</span> &#123;</span><br>    dict *dict;<br>    zskiplist *zsl;<br>&#125; zset;<br></code></pre></td></tr></table></figure><ol><li><strong>跳表结构设计</strong></li></ol><p>跳表是在链表基础上改进过来的，实现了一种多层的有序链表，每一层在链表上的跨度不一样，并且还提供了查找前驱节点的能力</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282302552.png" alt="img" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    <span class="hljs-comment">//Zset 对象的元素值</span><br>    sds ele;<br>    <span class="hljs-comment">//元素权重值</span><br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-comment">//后向指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><br><br>    <span class="hljs-comment">//节点的level数组，保存每层上的前向指针和跨度</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<br>    &#125; level[];<br>&#125; zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<br>    <span class="hljs-type">int</span> level;<br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>跳表节点查询过程</strong></li></ol><p>当查询一个节点的时候，会先从头节点的最高层开始查，有两个判断条件：</p><ul><li>如果下一个节点的next的权重比指定权重小，那么直接进入下一个节点</li><li>如果下一个节点的next的权重和指定权重一样，但是元素小于下一个节点的元素，那么也进入下一个节点</li></ul><p>最终，如果上述两个条件都不满足，那就往下一层继续判断（也是一种贪心法吧，尽可能跨度大点）</p><ol start="3"><li><p><strong>Redis往跳表插入节点</strong></p><ol><li><p>插入节点的level应该设置为多大</p><p>Redis在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25，那么层数就增加 1 层，然后继续生成一个随机数，直到随机数大于0.25结束，最终确定该节点的层数</p><p>但是，Redis规定最大层数不能超过32，也就说<strong>zskiplist的头节点的高度直接设置为32</strong></p></li><li><p>如何插入</p><p>就是单纯的链表插入，只需要根据权重找到应该插入的位置，往前修改每个跨度的节点的指针，在往后指向每个跨度的节点</p></li></ol></li><li><p>为什么Redis不用树，而是用跳表</p></li></ol><ul><li>B+树属于磁盘友好型，对于redis来说并不实用，而且会<strong>多很多插入删除的额外操作</strong></li><li>树结构最起码需要两个指针（左右子树），但是跳表用redis的概率方法，平均下来只有1.33个指针，<strong>更节省空间</strong></li></ul><h2 id="Redis高可用"><a href="#Redis高可用" class="headerlink" title="Redis高可用"></a>Redis高可用</h2><p>Redis高可用有三种方式，分别是：<strong>主从复制、哨兵模式、切片集群</strong>，下面一个一个来说</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282307680.png" alt="图片" style="zoom: 50%;" /><p>在Redis主从集群之间，是读写分离的，数据修改只会在主服务器上进行，但是二者如何实现数据一致性的呢？</p><ol><li><strong>第一次全量同步</strong></li></ol><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282323846.png" alt="图片" style="zoom:50%;" /><p>第一次全量同步分为三步：</p><ul><li><p>当执行了replicaof指令后，slave就会给master发送psync指令</p><p>master收到后，就会把自己的runID和当前同步进度offset发给salve，并告诉slave进行全量同步</p></li></ul><blockquote><p>psync有两个参数分别是主服务器的runID和同步进度offset。</p><p>由于是第一次同步，因此第一次psync指令的参数是？-1，因此发送的psync指令为<code>psync ? -1</code></p></blockquote><ul><li><p>master在把自己的runID和offset发给salve后，就会执行bgsave指令生成RDB快照，然后发送给slave</p><p>slave收到后，就会清空内存读取RDB，接着就会给master回复一个ACK</p><p>但是，master在bgsave的时候也会写数据，这个时候就会用一个replication_buffer缓冲区来存储bgsave时执行的命令</p></li><li><p>当slave读取完RDB给master回复一个ACK后，master就会将replication_buffer的内容发给slave同步新的写入数据</p></li></ul><blockquote><p>master会为每个slave建立一个replication_buffer，一旦<strong>缓冲区溢出就会强制终止全量同步</strong></p></blockquote><ol start="2"><li><strong>命令传播</strong></li></ol><p>完成第一次全量同步后，master就会和slave建立一个TCP连接</p><p>后续有写指令，master就会将该指令传给slave异步执行，同时slave会更新自己的offset</p><ol start="3"><li><strong>增量同步</strong></li></ol><p>由于命令传播依靠的是TCP连接，那如果TCP连接断开会怎么办？</p><p>连接恢复后，slave就会调用psync runID offset，只不过这里的runID和offset就有值了</p><p>master收到后，就会根据offset和自己的offset查看，环形缓冲区repl_backlog_buffer是否被覆盖，如果被覆盖就告知slave全量同步，还没有被覆盖就执行增量同步</p><p>增量同步就会把slave发送的offset到目前master记录的offset之间的指令全部写到replication_buffer中，然后发送给slave</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405282359203.png" alt="图片" style="zoom:50%;" /><ol start="4"><li>集群脑裂问题</li></ol><p>当主从结构中，如果原master和集群失联，但是和客户端仍然保持联系，那么：</p><ul><li>客户端仍然将数据写入旧master</li><li>哨兵发现旧master失联，因此选出新的master</li></ul><p>当旧master重新连接，哨兵会通知旧master有新的master，这样旧master会执行全量同步清空旧数据，导致客户端写入的数据丢失</p><h3 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h3><p>如果主从集群中的master挂了，那么如何自动化的实现发现并进行主从切换？这就是哨兵集群的功能了！</p><p>哨兵节点主要负责的就是三个事儿：监控节点状态、选择新的主节点、通知客户端和从节点 master发生变更</p><ol><li><strong>如何监控状态</strong></li></ol><p>每个哨兵节点每隔一秒就会给所有节点发送ping命令，节点收到后就会返回一个pong，一旦超过时间阈值没有返回pong命令，该哨兵节点就会认为这个节点<strong>主观下线</strong></p><p>如果有一个哨兵节点认为主节点主观下线了，那么就会发起投票，看看其他哨兵节点怎么认为的，超过用户配置的个数阈值，就会认为该主节点客观下线，就要开始进行故障转移</p><blockquote><p>注意的是，任何节点只要认为master主观下线了都会发起投票，一旦超过阈值就会认为master客观下线</p></blockquote><ol start="2"><li><strong>故障转移</strong></li></ol><p>故障转移分为两步，分别是选出主导这次故障转移的leader以及选择新的主节点</p><ul><li><p>选leader</p><p>每个认为客观下线的哨兵节点都会作为leader的候选者，然后开始投票</p><p>其中在选leader的时候，每个哨兵只有一次投票机会，哪个候选者先来请求就先投给谁，而且<strong>候选leader自己的一票会投给自己</strong></p><p>最终超过半数投票（故哨兵数量应为<strong>奇数</strong>）并且超过配置阈值才会被认为是leader，开始主导本次故障转移</p></li><li><p>选新的master</p><p>选择新的master会先过滤掉网络状况不好的节点（主从断连次数超过10次），然后有三轮排序：</p><ol><li>根据设置的优先级排序，人为设置，可根据服务器配置进行设置</li><li>如果优先级一样，就根据同步的offset排序</li><li>offset一样，根据自己的runID排序</li></ol></li></ul><ol start="3"><li><strong>通知变更</strong></li></ol><p>master的变更需要通知三个：</p><ul><li>给其他从节点发送slaveOf命令，通知新的主节点</li><li>给客户端发送指令，通知新的master的IP和端口</li><li>监视旧主节点，一旦旧的主节点上线，发送slaveOf指令</li></ul><h2 id="Redis过期删除和淘汰"><a href="#Redis过期删除和淘汰" class="headerlink" title="Redis过期删除和淘汰"></a>Redis过期删除和淘汰</h2><h3 id="Redis-主从模式中，对过期键如何处理"><a href="#Redis-主从模式中，对过期键如何处理" class="headerlink" title="Redis 主从模式中，对过期键如何处理"></a>Redis 主从模式中，对过期键如何处理</h3><p>要注意的是，<strong>slave永远不会修改自己的数据，哪怕是过期了</strong></p><p>只有当master发现key过期了，就会删除该key，并在AOF中添加一条对应的DEL指令，然后同步给slave</p><blockquote><p> master不处理读请求，如何发现key过期：过期删除策略是惰性+定时部分删除的</p></blockquote><h3 id="Redis-持久化时，对过期键如何处理"><a href="#Redis-持久化时，对过期键如何处理" class="headerlink" title="Redis 持久化时，对过期键如何处理"></a>Redis 持久化时，对过期键如何处理</h3><ol><li>RDB持久化<ul><li>RDB文件生成的时候，会对每个key检查，过期的不会写入RDB文件</li><li>RDB文件加载的时候，master会对key检查，但是slave不会</li></ul></li><li>AOF持久化<ul><li>AOF文件追加的时候，发现过期key不会删除，等待清理的时候追加一条DEL语句</li><li>AOF文件重写的时候，发现过期key，不会保存到AOF重写中去</li></ul></li></ol><h3 id="内存淘汰中LRU和LFU有什么区别"><a href="#内存淘汰中LRU和LFU有什么区别" class="headerlink" title="内存淘汰中LRU和LFU有什么区别"></a>内存淘汰中LRU和LFU有什么区别</h3><p>在redisObject中，有一个lru字段</p><p>当使用LRU算法的时候，lru就是用来记录最近访问的时间戳，等需要淘汰的时候，就删掉lru最小的</p><p>当使用LFU算法的时候，lru的高16位记录访问的时间戳，低8位记录访问次数，删除访问次数最少的，若很多一样则删掉时间戳最小的</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的一些问题</title>
    <link href="/2024/05/08/2024-05-08-Spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2024/05/08/2024-05-08-Spring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring的一些问题"><a href="#Spring的一些问题" class="headerlink" title="Spring的一些问题"></a>Spring的一些问题</h1><p>Spring 其实就是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架</p><p>目前企业开发的标配就是：<strong>Spring5+SpringBoot2+JDK8</strong></p><h2 id="Spring应用的设计模式"><a href="#Spring应用的设计模式" class="headerlink" title="Spring应用的设计模式"></a>Spring应用的设计模式</h2><p>Spring中用到的设计模式还是很多的，我们一个一个讨论</p><ol><li>工厂模式：这其实就是Spring的核心技术IoC，整个IoC容器其实就是一个巨大的工厂，需要什么就提供什么。</li><li>代理模式：这也是Spring的另一个核心技术AOP，AOP的切面增强功能就是基于代理模式实现的。如果这个类继承于某个接口，一般就是JDK动态代理；如果没有，那么就是通过CGLIB搞一个继承它的子类。</li><li>单例模式：Spring容器中的Bean默认就是单例模式</li></ol><p>后面其实就是一些相对不是很重要的设计模式了，比如：</p><ul><li>模板模式：JdbcTemplate、RedisTemplate … 这些就是模板模式</li><li>观察者模式：Listener …</li><li>适配器模式：HandlerAdapter …</li></ul><h2 id="自己实现一个简陋版IoC"><a href="#自己实现一个简陋版IoC" class="headerlink" title="自己实现一个简陋版IoC"></a>自己实现一个简陋版IoC</h2><p>其实就是先在bean.properties文件里面配置好bean的name和对应的全限定包名</p><p>然后我们通过懒加载的方式获取并放到缓存里面就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//待实现</span><br></code></pre></td></tr></table></figure><h2 id="Spring-Bean的相关问题"><a href="#Spring-Bean的相关问题" class="headerlink" title="Spring Bean的相关问题"></a>Spring Bean的相关问题</h2><h4 id="Bean实例化的方式"><a href="#Bean实例化的方式" class="headerlink" title="Bean实例化的方式"></a>Bean实例化的方式</h4><p>construct、factory</p><h4 id="Bean依赖注入的方式"><a href="#Bean依赖注入的方式" class="headerlink" title="Bean依赖注入的方式"></a>Bean依赖注入的方式</h4><p>construct、setter、factory</p><h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>Bean的生命周期分为主要分为四个大阶段：构造函数、设置属性（依赖注入）、初始化、销毁</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405092234967.png" alt="三分恶面渣逆袭：Spring Bean生命周期" style="zoom: 33%;" /><ul><li>构造函数就是构造函数，没啥好说的</li><li>设置对象属性，其实就是依赖注入，但是我们要注意的是这里的依赖注入应该是只针对xml文件的注入方式，如果是通过<code>@Autowired</code>注解注入的话，走的是初始化中的后置处理器，并不是在这里注入的</li><li>初始化：初始化其实又分为很多个步骤<ol><li>首先会检查很多Aware相关的接口，比如BeanName就是在这里获取的</li><li>然后会执行前置处理器，BeforeProcess</li><li>接着执行初始化，比如<code>@PostConstruct</code>修饰的函数就是在这执行的</li><li>然后执行后置处理器，比如AOP代理、Autowired依赖注入等</li></ol></li></ul><h4 id="Bean循环依赖的解决（三级缓存）"><a href="#Bean循环依赖的解决（三级缓存）" class="headerlink" title="Bean循环依赖的解决（三级缓存）"></a>Bean循环依赖的解决（三级缓存）</h4><p>循环依赖就没啥好说的了，但是我们要注意的是Spring的循环依赖解决方式只能解决setter注入的且是非懒加载的循环依赖</p><p>三级缓存的定义分别是：</p><ul><li>一级缓存：已经初始化完的对象</li><li>二级缓存：没完全初始化完的对象</li><li>三级缓存：没完全初始化完的对象的工厂对象</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405100125794.png" alt="三分恶面渣逆袭：三级缓存" style="zoom: 50%;" /><p>我们就举一个简单的例子，A和B有循环依赖</p><ul><li>首先按照初始化的顺序，我们先初始化A（这个时候没有人需要A，因此A目前放在的是三级缓存中），当发现需要依赖注入B的时候发现1、2、3级缓存都没有，那么就会去初始化B</li><li>B初始化的时候，由于也没有人需要B，那么也是放在三级缓存中的，等到依赖注入的时候发现需要A，那么就又会去缓存中找，这个时候在三级缓存找到了A</li><li>那么B就会通过三级缓存的工厂对象搞出一个A来，不管是A本身还是代理对象，反正就是搞出来了一个A</li><li>那么既然搞出来了一个A，那这个A就会被放到二级缓存了，同时会将这个A注入到B中，至此B初始化完毕，放到一级缓存中</li><li>最后，继续回到A的初始化，A这次就从一级缓存中拿到了B，那么就可以注入进来，至此A也初始化完毕，也放到一级缓存</li></ul><h2 id="SpringMVC的两种工作流程"><a href="#SpringMVC的两种工作流程" class="headerlink" title="SpringMVC的两种工作流程"></a>SpringMVC的两种工作流程</h2><h4 id="使用ModelAndView"><a href="#使用ModelAndView" class="headerlink" title="使用ModelAndView"></a>使用ModelAndView</h4><p>这个已经背烂了，没啥好说的直接上图：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405100125392.png" alt="三分恶面渣逆袭：Spring MVC的工作流程" style="zoom:50%;" /><blockquote><p>注意的是：HandlerAdapter和Handler应该是一一对应的，它是为了将Request适配到对应的Handler上</p></blockquote><h4 id="不使用ModelAndView"><a href="#不使用ModelAndView" class="headerlink" title="不使用ModelAndView"></a>不使用ModelAndView</h4><p>当我们在Controller的某个方法上加上了<code>@ResponseBody</code>注解的话，那么返回的就是json格式的数据了，而不是ModelAndView，那么这时候工作流程是怎样的呢？</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405092259092.png" alt="Spring MVC Restful请求响应示意图" style="zoom: 20%;" /><ul><li><p>其实先开始都是一样的，先通过HandlerMapping找到Handler，然后通过HandlerAdapter调用对应的Handler</p></li><li><p>但是等到HandlerAdapter返回的时候，因为没有视图，返回的这个ModelAndView是NULL</p></li><li><p>在调用完Handler方法后，Adapter会进一步调用HandlerMethodReturnValueHandler来处理返回值，简单说就是将json序列化，写到 ServletServerHttpResponse（封装了原生的HttpServletResponse）中返回</p></li></ul><h2 id="SpringBoot的相关问题"><a href="#SpringBoot的相关问题" class="headerlink" title="SpringBoot的相关问题"></a>SpringBoot的相关问题</h2><p>SpringBoot一句话来说，就是为了简化Spring开发中的一堆复杂的配置</p><h4 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h4><p>SpringBoot的自动装配是由SpringBootApplicaiton这个注解实现的，这个注解包含三个部分：</p><ul><li><code>@SpringConfiguration</code></li><li><code>@EnableAutoConfiguration</code></li><li><code>@ComponentScan</code></li></ul><p>其中EnableAutoConfiguration注解就是开启了自动配置，它Import了一个AutoConfigurationImportSelector，接下来这个东西做了一下几步：</p><ol><li>首先，这个东西读取所有的MEAT-INF&#x2F;spring.factories里面的所有自动配置类，这里的每个类都是是加了<code>@Configuration</code>注解，也就是说这里面声明的所有Bean都<strong>有可能</strong>会被加载（为什么是有可能看后面）</li><li>然后这个Selector会根据SpringBootApplication注解中的exclude和excludeName排除掉不需要的自动配置类</li><li>最后，也不是剩下的这些东西所有配置类都会被加载，他会根据一系列ConditionOnxxx的条件，过滤掉不需要加载的配置类，剩下的就是会自动配置的类了</li></ol><blockquote><p>注意的是，这里MEAT-INF&#x2F;spring.factories不仅仅是spring底下的，只要你maven依赖的jar包，里面只要有这个文件，都会读取出来的</p></blockquote><h4 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h4>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>Java八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL总结</title>
    <link href="/2024/05/06/2024-05-05-MySQL%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/06/2024-05-05-MySQL%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL总结"><a href="#MySQL总结" class="headerlink" title="MySQL总结"></a>MySQL总结</h1><h2 id="MySQL中的一条记录是如何存放的"><a href="#MySQL中的一条记录是如何存放的" class="headerlink" title="MySQL中的一条记录是如何存放的"></a>MySQL中的一条记录是如何存放的</h2><p>在InnoDB存储引擎中，默认的存储格式是Compact格式，其基本结构如下：</p><p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405051730936.png" alt="img"></p><ul><li>变长字段长度列表存放的每个元素表示的是对应的varchar字段的真实长度</li><li>NULL值列表存放的是每个没有设置为NULL字段是否为空，只需要一个bit就可以</li></ul><p>但是，我们要注意的是：这个两个列表存放的顺序是和表中DDL语句声明的字段相对的顺序是反着的。因为，这每条记录中指向下一条记录的指针指向的是记录头信息最后的位置，反着存放是为了<strong>指针往右走可以按顺序读取列的真实值，往左走可以按顺序读取列表</strong>。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405051736137.png" alt="img" style="zoom:50%;" /><h2 id="联合索引问题"><a href="#联合索引问题" class="headerlink" title="联合索引问题"></a>联合索引问题</h2><h4 id="最左匹配查询"><a href="#最左匹配查询" class="headerlink" title="最左匹配查询"></a>最左匹配查询</h4><h4 id="范围查询失效"><a href="#范围查询失效" class="headerlink" title="范围查询失效"></a>范围查询失效</h4><h2 id="B-树问题"><a href="#B-树问题" class="headerlink" title="B+树问题"></a>B+树问题</h2>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人笔记</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里Lazada笔试第一题</title>
    <link href="/2024/04/29/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E9%A2%98/"/>
    <url>/2024/04/29/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里Lazada笔试第一题"><a href="#阿里Lazada笔试第一题" class="headerlink" title="阿里Lazada笔试第一题"></a>阿里Lazada笔试第一题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小红定义一个01串的权值为:相邻两个字符都是’1’的对儿数。例如，”110111”的权值为3。 </p><p>现在小红希望你求出所有长度为<code>n</code>的01串的权值之和。你能帮帮她吗?</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>一个正整数<code>n</code></p><p>$$<br>1\le n \le 10^9\<br>$$</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure></blockquote><h4 id="Example-02"><a href="#Example-02" class="headerlink" title="Example-02"></a>Example-02</h4><blockquote><p>Input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ul><li>首先，我们可以先求出从<code>dp[i-1]</code>到<code>dp[i]</code>的递推公式，它拥有两个部分：<ol><li>当<code>str[i]</code>为’0’时，那么所有01串的权值和为：<code>dp[i-1]</code></li><li>当<code>str[i]</code>为’1’时，那么所有01串的权值和为：<code>dp[i-1]</code> + 最后两个是‘11’的01串的个数</li></ol></li><li>那么根据上述两个部分，可以算出递推公式：</li></ul><p>$$<br>dp[i]&#x3D;dp[i-1]+dp[i-1]+2^{i-2}&#x3D;dp[i-1] \times 2+2^{i-2}<br>$$</p><ul><li>由于n的最大值为10e9，因此不能循环暴力求解，我们可以由递推公式算出直接公式：</li></ul><p>$$<br>dp[i]&#x3D;(i-1)\times2^{i-2}<br>$$</p><ul><li>再利用费马小定理（因为10e9+7是质数），可以直接得到计算公式：</li></ul><p>$$<br>dp[i]&#x3D;(i-1)\times2^{(i-2) \mod (10^9+6)}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n=in.nextInt();<br><br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">6</span>;<br>        <span class="hljs-type">long</span> res=n-<span class="hljs-number">1</span>;<br>        res=(res*(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">2</span>,(n-<span class="hljs-number">2</span>)%mod))%mod;<br>        System.out.println(res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索二维矩阵</title>
    <link href="/2024/04/28/2024-04-28-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
    <url>/2024/04/28/2024-04-28-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h1><h4 id="Problem-240-搜索二维矩阵-II"><a href="#Problem-240-搜索二维矩阵-II" class="headerlink" title="Problem: 240. 搜索二维矩阵 II"></a>Problem: <a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240. 搜索二维矩阵 II</a></h4><p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>$$<br>1\le m,n \le 300\<br>-10^9 \le matrix[i][j], target \le 10^9<br>$$</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,4,7,11,15]</span>,<span class="hljs-comment">[2,5,8,12,19]</span>,<span class="hljs-comment">[3,6,9,16,22]</span>,<span class="hljs-comment">[10,13,14,17,24]</span>,<span class="hljs-comment">[18,21,23,26,30]</span>]</span><br>target = 20<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="Example-02"><a href="#Example-02" class="headerlink" title="Example-02"></a>Example-02</h4><blockquote><p>Input</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,4,7,11,15]</span>,<span class="hljs-comment">[2,5,8,12,19]</span>,<span class="hljs-comment">[3,6,9,16,22]</span>,<span class="hljs-comment">[10,13,14,17,24]</span>,<span class="hljs-comment">[18,21,23,26,30]</span>]</span><br>target = 5<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution-01"><a href="#Solution-01" class="headerlink" title="Solution-01"></a>Solution-01</h4><p>对每一行二分查找，同时可以做一些简单的剪枝</p><p>如：如果该行第一个数字比<code>target</code>大，那么就可以直接返回<code>false</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> [] row:matrix)&#123;<br>            <span class="hljs-keyword">if</span>(row[<span class="hljs-number">0</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> index=binarySearch(row,target);<br>            <span class="hljs-keyword">if</span>(index !=-<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums,<span class="hljs-type">int</span> target)</span>&#123;<br>        <span class="hljs-type">int</span> low=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>            <span class="hljs-type">int</span> mid=(low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> num=nums[mid];<br>            <span class="hljs-keyword">if</span>(num==target)&#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num&gt;target)&#123;<br>                high=mid-<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                low=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Solution-02"><a href="#Solution-02" class="headerlink" title="Solution-02"></a>Solution-02</h4><p>还有一种时间复杂度为<code>O(m+n)</code>的方法——“Z字查找”：我们可以从矩阵右上角（即<code>matirx[0][m-1]</code>）开始遍历：</p><ol><li>如果当前元素小于<code>target</code>，我们就往下走</li><li>如果当前元素大于<code>target</code>，我们就往左走</li><li>如果当前元素等于<code>target</code>，直接返回<code>true</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=matrix[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;matrix.length&amp;&amp;j&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j]&lt;target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="/2024/04/28/2024-04-28-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2024/04/28/2024-04-28-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h4 id="Problem-LCR-120-寻找文件副本"><a href="#Problem-LCR-120-寻找文件副本" class="headerlink" title="Problem: LCR 120. 寻找文件副本"></a>Problem: <a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/">LCR 120. 寻找文件副本</a></h4><p>设备中存有 <code>n</code> 个文件，文件 <code>id</code> 记于数组 <code>documents</code>。若文件 <code>id</code> 相同，则定义为该文件存在副本。请返回任一存在副本的文件 <code>id</code>。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>$$<br>0\le document[i]\le n−1\<br>2\le n\le 100000<br>$$</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">documents = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>或 <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution-01"><a href="#Solution-01" class="headerlink" title="Solution-01"></a>Solution-01</h4><ul><li>很简单直接用hash表记录遍历过的元素，然后再次碰到直接返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatDocument</span><span class="hljs-params">(<span class="hljs-type">int</span>[] documents)</span> &#123;<br>        Map&lt;Integer,Boolean&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:documents)&#123;<br>            <span class="hljs-keyword">if</span>(map.get(num)==<span class="hljs-literal">null</span>)&#123;<br>                map.put(num,<span class="hljs-literal">true</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Solution-02"><a href="#Solution-02" class="headerlink" title="Solution-02"></a>Solution-02</h4><p>还有一种空间复杂度为<code>O(1)</code>的方法，由于题目中说到数字在0到n-1之间，那么其实给的这个数组就是一个天然的hashmap，因此我们可以直接在这个数组上做文章：</p><ol><li><p>我们需要遍历每个索引<code>i</code>，如果当前索引取出来的数等于<code>i</code>，那么就可以继续遍历下一个索引</p></li><li><p>如果不等于，我们就要看看：</p><ul><li><code>documents[documents[i]]==documents[i]</code>：这种情况就说明存在两个位置的数字是一样的，那么就返回<code>documents[i]</code>。</li><li><code>documents[documents[i]]!=documents[i]</code>：这种情况说明当前索引没有存在它应该存的值，我们就把<code>documents[i]</code>存的这个数放在它应该存的地方，然后把挤出来的数（原本的<code>documents[documents[i]]</code>）拿到当前索引来继续处理看看这个数应该放在哪。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findRepeatDocument</span><span class="hljs-params">(<span class="hljs-type">int</span>[] documents)</span> &#123;<br>        <span class="hljs-type">int</span> n=documents.length;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(documents[i]==i)&#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> temp=documents[i];<br>            <span class="hljs-keyword">if</span>(documents[temp]==temp)&#123;<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                documents[i]=documents[temp];<br>                documents[temp]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里Lazada笔试第二题</title>
    <link href="/2024/04/27/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98/"/>
    <url>/2024/04/27/2024-04-29-%E9%98%BF%E9%87%8CLazada%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里Lazada笔试第二题"><a href="#阿里Lazada笔试第二题" class="headerlink" title="阿里Lazada笔试第二题"></a>阿里Lazada笔试第二题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小红拿到了一个数字串，她想取一个长度为<code>k</code>的子序列，满足这个子序列对应的正整数是<code>4</code>的倍数。小红想知道有多少种不同的选择方案?</p><p> 请注意，选择的子序列包含前导零也是合法的。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入两个正整数<code>n</code>，<code>k</code>，代表数字串的长度和取的子序列长度。</p><p>第二行输入一个长度为<code>n</code>的、仅由数字字符组成的字符串。<br>$$<br>1\le k \le n \le 200000<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>一个整数，代表合法的子序列数。由于答案可能过大，请对<code>10e9+7</code>取模</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li><p>dp数组含义：</p><ul><li><code>dp\[i]\[j][h]</code>：前<code>i</code>个数字串，取<code>j</code>个字符，模4等于<code>h</code>的合法组合数</li></ul></li><li><p>状态转移方程，这里我们有三种情况需要处理，我们令<code>num</code>为第i个数： </p><ul><li><p>组合不包含第i个数字的个数：这种情况就是前面的<code>dp</code>大小，即<code>dp[i][j][h]=dp[i-1][j][h]</code></p></li><li><p>组合包含第i个数字的个数：这种情况就是把前面去j-1个串然后加上num取模的结果加到当前<code>dp</code>上去，即<code>dp[i][j][(h*10+num)%4]+=dp[i-1][j-1][h]</code></p><p>这里可以证明，推导如下：<br>$$<br>对于原本数字，我们可以设为：x&#x3D;b_i\times 4^i+b_{i-1}\times 4^{i-1}+…+b_0\times4^0\<br>我们令h&#x3D;x % 4&#x3D;b_0 % 4\<br>原本的数x末尾加上num后结果可以表示为：\<br>x’&#x3D;b_i\times 4^i\times10+b_{i-1}\times 4^{i-1} \times 10+…+b_0\times 4^0 \times 10+num\<br>因此，x’% 4&#x3D;(b_0\times 4^0 \times 10+num)%4&#x3D;(h\times10+num)% 4<br>$$</p></li></ul></li></ol><ul><li>组合<strong>只</strong>包含第i个数字的个数：这种情况其实就是取1个字符的结果，模多少对应的dp就加一，即<code>dp[i][1][num%4]++</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> times=<span class="hljs-number">4</span>;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n=in.nextInt();<br>        <span class="hljs-type">int</span> k=in.nextInt();<br>        in.nextLine();<br><br>        <span class="hljs-type">char</span>[] nums = in.nextLine().toCharArray();<br>        <span class="hljs-type">long</span> [][][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n+<span class="hljs-number">1</span>][k+<span class="hljs-number">1</span>][times];<br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>) Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-type">int</span> num=nums[i-<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>;h&lt;times;h++)&#123;<br>                    dp[i][j][h]=dp[i-<span class="hljs-number">1</span>][j][h];<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=<span class="hljs-number">0</span>;h&lt;times;h++)&#123;<br>                    dp[i][j][(h*<span class="hljs-number">10</span>+num)%times]+=dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][h];<br>                    dp[i][j][(h*<span class="hljs-number">10</span>+num)%times]%=mod;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>)&#123;<br>                    dp[i][j][num%times]++;<br>                    dp[i][j][num%times]%=mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(dp[n][k][<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团笔试第四题</title>
    <link href="/2024/04/27/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E5%9B%9B%E9%A2%98/"/>
    <url>/2024/04/27/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E5%9B%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团笔试第四题"><a href="#美团笔试第四题" class="headerlink" title="美团笔试第四题"></a>美团笔试第四题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小美拿到了一棵树，其中有一些节点被染成红色。小美定义一个红色连通块的权值为:所有节点编号乘积的因子数量。<br>小美想知道，所有红色连通块的权值之和是多少?由于答案过大，请对<code>10e9+7</code>取模。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入一个正整数<code>n</code>，代表节点数量。</p><p>第二行输入一个长度为<code>n</code>的，仅由’R’和’W’组成的字符串，第<code>i</code>个字符为’R’代表<code>i</code>号节点被染成红色，’W’代表未被染色。保证至少有一个节点被染成红色。<br>接下来的<code>n - 1</code>行，每行输入2个正整数<code>u</code>，<code>v</code>，代表<code>u</code>号节点和<code>v</code>号节点有一条边连接。<br>$$<br>1 \le n \le 10^5\<br>1 \le u,v \le n<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>一个整数，代表所有红色连通块的权值之和。</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">WRR</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li>这题其实就是要找连通分量，我们可以在输入的时候就做预处理：<strong>只保留红色节点和红色节点相邻的边，其余的边一律不保留</strong></li><li>然后就可以直接dfs或者bfs遍历每个连通分量了，我们只需要在遍历的时候记录这个节点visit过，防止重复遍历就好</li><li>最后直接计算因子个数</li></ol><blockquote><p>但是我觉得这样会超时，当时现场没有时间写，不知道这种解法对不对</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> []visit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, List&lt;Integer&gt;&gt; graph;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> n=in.nextInt();<br>        in.nextLine();<br>        String str=in.nextLine();<br><br>        graph=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">boolean</span>[] isRed=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br>        visit=<span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            isRed[i+<span class="hljs-number">1</span>]= str.charAt(i) != <span class="hljs-string">&#x27;W&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> u=in.nextInt();<br>            <span class="hljs-type">int</span> v=in.nextInt();<br>            <span class="hljs-keyword">if</span>(isRed[u]&amp;&amp;isRed[v])&#123;<br>                List&lt;Integer&gt; uNeighbor = graph.getOrDefault(u , <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                uNeighbor.add(v);<br>                graph.put(u,uNeighbor);<br><br>                List&lt;Integer&gt; vNeighbor = graph.getOrDefault(v , <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                vNeighbor.add(u);<br>                graph.put(v,vNeighbor);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>            <span class="hljs-keyword">if</span> (!visit[i]&amp;&amp;isRed[i]) &#123;<br>                visit[i] = <span class="hljs-literal">true</span>;<br>                res=(res+get_sum(dfs(i)))%mod;<br>            &#125;<br>        &#125;<br>        System.out.println(res);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span>&#123;<br>        List&lt;Integer&gt; neighbors = graph.getOrDefault(node , <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        <span class="hljs-type">long</span> ans=node;<br>        <span class="hljs-keyword">for</span>(Integer neighbor:neighbors)&#123;<br>            <span class="hljs-keyword">if</span>(visit[neighbor])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            visit[neighbor]=<span class="hljs-literal">true</span>;<br>            ans*=dfs(neighbor);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_sum</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>&#123;<br>        <span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)tot++;<br>        <span class="hljs-keyword">return</span> tot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里淘天笔试第三题</title>
    <link href="/2024/04/27/2024-04-27-%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/"/>
    <url>/2024/04/27/2024-04-27-%E9%98%BF%E9%87%8C%E6%B7%98%E5%A4%A9%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里淘天笔试第三题"><a href="#阿里淘天笔试第三题" class="headerlink" title="阿里淘天笔试第三题"></a>阿里淘天笔试第三题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小红拿到了一个长度为”的数组。她定义一个子序列是“好的”，且仅当该子序列所有元素之和为奇数。现在小红想求出所有“好的”子序列的元素和之和。你能帮帮她吗?由于答案可能过大，请对<code>10e9+7</code>取模。定义一个数组的子序列是，数组中取若干元素(可以不连续)按原数组顺序形成的新数组。</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入一个正整数<code>n</code>，代表小红拿到的数组。<br>第二行输入<code>n</code>个正整数，代表数组中的元素。<br>$$<br>1\le n\le 10^5\<br>1\le a_i \le 10^9<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>所有“好的”子序列的元素和之和，答案对<code>10e9+7</code>取模。</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li><p>dp数组含义：</p><ul><li><p><code>dp[0][i]</code>：前i个数字，和为<strong>偶数</strong>的子序列之和</p></li><li><p><code>dp[1][i]</code>：前i个数字，和为<strong>奇数</strong>的子序列之和</p></li></ul></li><li><p>count数组含义：</p><ul><li><code>count[0][i]</code>：前i个数字，和为<strong>偶数</strong>的子序列<strong>个数</strong>之和</li><li><code>count[1][i]</code>：前i个数字，和为<strong>奇数</strong>的子序列<strong>个数</strong>之和</li></ul></li><li><p>状态转移方程：</p><ul><li>当第i个数为奇数的时候：<ul><li>偶数子序列之和为：前i-1个数字的偶数子序列之和 + 带上第i个数字的前i-1个奇数子序列之和，即<code>dp[0][i] = dp[0][i - 1] + dp[1][i - 1] + count[1][i - 1] * a[i - 1]</code></li><li>奇数数子序列之和为：前i-1个数字的奇数子序列之和 + 带上第i个数字的前i-1个偶数子序列之和+它自己，即<code>dp[1][i] = dp[0][i - 1] + count[0][i - 1] * a[i - 1] + dp[1][i - 1] + a[i - 1]</code></li></ul></li><li>当第i个数为奇数的时候:<ul><li>偶数子序列之和为：前i-1个数字的偶数子序列之和 + 带上第i个数字的前i-1个偶数子序列之和+它自己，即<code>dp[0][i] = dp[0][i - 1] + count[0][i - 1] * a[i - 1] + dp[0][i - 1] + a[i - 1]</code></li><li>奇数数子序列之和为：前i-1个数字的奇数子序列之和 + 带上第i个数字的前i-1个奇数子序列之和，即<code>dp[1][i] = dp[1][i - 1] + count[1][i - 1] * a[i - 1] + dp[1][i - 1]</code></li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span> , <span class="hljs-number">3</span> , <span class="hljs-number">2</span> , <span class="hljs-number">4</span> , <span class="hljs-number">5</span> , <span class="hljs-number">6</span> , <span class="hljs-number">7</span>&#125;;<br>        <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>) Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span>[][] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">2</span>][n + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = (dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod + dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>])%mod;<br>                count[<span class="hljs-number">0</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)%mod;<br>                dp[<span class="hljs-number">1</span>][i] = (dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod + dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])%mod;<br>                count[<span class="hljs-number">1</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])%mod;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[<span class="hljs-number">0</span>][i] = (dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod)%mod;<br>                count[<span class="hljs-number">0</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>])%mod;<br>                dp[<span class="hljs-number">1</span>][i] = (dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>]%mod + dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>])%mod;<br>                count[<span class="hljs-number">1</span>][i] = (count[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + count[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)%mod;<br>            &#125;<br>        &#125;<br>        System.out.println(dp[<span class="hljs-number">1</span>][n]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团笔试第三题</title>
    <link href="/2024/04/27/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/"/>
    <url>/2024/04/27/2024-04-27-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%89%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团笔试第三题"><a href="#美团笔试第三题" class="headerlink" title="美团笔试第三题"></a>美团笔试第三题</h1><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><p>小美拿到了一个数组，她每次操作可以将两个相邻元素<code>a[i]</code>合并为个元素，合并后的元素为原来两个元素之和。小美希望最终数组的最小值不小于<code>k</code>。她想知道有多少种不同的合并结果?</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>第一行输入两个正整数<code>n,k</code>，代表数组大小和数组的最大值。</p><p>第二行输入<code>n</code>个正整数<code>a[i]</code>，代表小美拿到的数组。</p><p>$$<br>1 \le n, k, a_i \le 200<br>$$</p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>输出一个整数，代表小美可以得到多少种不同的结果。由于结果可能很大，输出对<code>10e9+7</code>取模的结果。</p></blockquote><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><blockquote><p>Input</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure></blockquote><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><ol><li><p>dp数组含义：</p><ul><li><code>dp[i][j]</code>：从<code>i</code>到<code>j</code>的合并方式数量</li></ul></li><li><p>状态转移方程：</p><ul><li><p>选取一个<code>h</code>但是，这是一个在<code>i</code>和<code>j</code>之间的量，代表合并<code>h</code>到<code>j</code>的所有数字，如果这个数字大于<code>k</code>那么就会多出<code>dp[i][h-1]</code>种方式出来。（这相当于固定<code>h</code>到<code>j</code>，前面<code>i</code>到<code>h-1</code>可以随便合并）</p></li><li><p>那么我们就可以得到状态转移方程：<br>$$<br>dp[i][j]&#x3D;\sum^{h&#x3D;i}_{i\le h\le j}dp[i][h-1]<br>$$</p></li><li><p>但是这里比较重要的是初始化：</p><ul><li>首先，对于<code>dp[i][i]</code>来说，就是单独一个数字，如果<code>a[i]</code>比<code>k</code>大那么<code>dp[i][i]=1</code>，否则<code>dp[i][i]=0</code></li><li>其次，对于<code>dp[i][0]</code>，我们令其为<code>1</code>（这其实相当于从头加到尾了，如果满足sum&gt;k的条件，那么就应该+1）</li></ul></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-type">int</span> n=in.nextInt();<br>            <span class="hljs-type">int</span> k=in.nextInt();<br>            <span class="hljs-type">int</span> [] a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                a[i]=in.nextInt();<br>            &#125;<br>            <span class="hljs-type">long</span> mod=(<span class="hljs-type">long</span>)Math.pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;<br><br>            <span class="hljs-type">long</span> [][]dp=<span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span> [n+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>                dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(a[i-<span class="hljs-number">1</span>]&gt;k)&#123;<br>                    dp[i][i]=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n+<span class="hljs-number">1</span>;j++)&#123;<br>                    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> h=j;h&gt;=i;h--)&#123;<br>                        sum+=a[h-<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">if</span>(sum&gt;=k)&#123;<br>                            dp[i][j]=(dp[i][j]+dp[i][h-<span class="hljs-number">1</span>])%mod;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            System.out.println(dp[<span class="hljs-number">1</span>][n]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试题总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
      <tag>笔试</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八股文精简版</title>
    <link href="/2023/12/17/2023-12-17-%E5%85%AB%E8%82%A1%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/17/2023-12-17-%E5%85%AB%E8%82%A1%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="八股文精简版"><a href="#八股文精简版" class="headerlink" title="八股文精简版"></a>八股文精简版</h1><h2 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h2><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>底层实现就是数组</p><p>其数组的初始化如果不给容量参数，那么就会初始化为0，在我们第一次添加数据的时候才会变成10</p><p>其次，在往后的添加数据过程中，只要添加后的容量没有超出底层数组的容量，就会直接添加</p><p>否则，就会先将底层数组的数据拷贝到一个长度为1.5倍的数组里，在添加（不是一味的扩容1.5倍，扩容后检测是否超出最大限制）</p><blockquote><p>由于是直接拷贝长度，因此扩容后的新数组实际上可能存在脏数据，所以我们取值用的是get方法，他会根据size判断你取值是否越界，避免脏数据</p></blockquote><p>当执行<code>Arrays.toList</code>的时候，返回的是一个内部类，不是util中的ArrayList，而且其底层的数组是引用，二者<strong>共用同一地址</strong></p><blockquote><p>无法add操作，底层用了final定义</p></blockquote><p>当执行ArrayList中的toArray的时候，是开辟新的空间，把数据拷贝进去，二者<strong>地址不同</strong></p><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>底层是一个双向链表</p><h6 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h6><ul><li>底层数据结构不同：ArrayList是一个动态数组，LinkedList是一个双向链表</li><li>操作数据效率不同</li><li>内存占用不同：ArrayList使用数组，连续存储，节省内存；LinkedList用的链表，额外存储了prev和next指针</li><li>二者都不是线程安全的</li></ul><h4 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h4><h6 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h6><p>底层使用的是哈希表的结构，发生冲突时候会使用拉链法（后面追加链表）</p><p>但是不同的是这里不是简单的链表，当链表的长度达到8以上且数组的长度大于64的时候，会将其转化为红黑树的结构</p><p>这样即使在最坏的情况下，查找效率也是$O(log{n})$</p><blockquote><p>jdk1.8之前用的是链表的结构，之后才引入了红黑树</p></blockquote><h6 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h6><ul><li>查看当前hashmap有没有被初始化，如果没有就执行扩容</li><li>根据计算出来的hash值和当前容量按位与（因为容量是2的n次幂），得到对应的数组地址</li><li>如果对应位置为空，直接赋值，不为空则：<ul><li>​查看当前key和数组的key是否一样，一样则为更新操作，直接覆盖</li><li>不一样再向其中插入节点，其中如果是红黑树则走红黑树插入的逻辑，是链表直接放到链表尾部，但是链表插入完要看看长度是否超过8，超过的话再看看数组容量是否达到64，没达到需要先扩容，达到了才会转成红黑树结构</li><li>其次，插入遍历链表的过程中，发现key一样的直接覆盖</li></ul></li><li>上述逻辑执行完，相当于插入了一条数据，都会查看当前元素的数量是否超过数组数量$\times 0.75$，超过则需要扩容</li></ul><h6 id="扩容操作"><a href="#扩容操作" class="headerlink" title="扩容操作"></a>扩容操作</h6><ul><li>先检查有无初始化，没有初始化则初始化为16，直接结束</li><li>否则，将数组容量$\times 2$，然后遍历原数组的每个元素，如果该元素的next为空，则计算新的hash值插入数组，否则：<ul><li>是链表，需要对每个元素重新hash再逐个插入</li><li>是红黑树，执行红黑树插入</li></ul></li></ul><h6 id="寻址算法"><a href="#寻址算法" class="headerlink" title="寻址算法"></a>寻址算法</h6><p>给定一个key，它在数组中为值为：<code>(hash(key)^(hash(key)&gt;&gt;16))&amp;(capacity-1)</code></p><p>使用这样的方法计算哈希值，可以使得哈希值分布的更加均匀</p><h6 id="为什么数组长度是2的n次幂"><a href="#为什么数组长度是2的n次幂" class="headerlink" title="为什么数组长度是2的n次幂"></a>为什么数组长度是2的n次幂</h6><ol><li>在计算数组位置的时候，可以使用(capacity-1)&amp;hash，而不是模运算，减少开销</li><li>在扩容的时候，计算重新计算hash值不是真的重新计算，而是oldCapacity&amp;hash，如果为0则一样，如果为1说明hash的新一位和原来的不一样，则新位置改为：原位置+oldCapacity</li></ol><h6 id="jdk1-7中hashMap多线程死循环问题"><a href="#jdk1-7中hashMap多线程死循环问题" class="headerlink" title="jdk1.7中hashMap多线程死循环问题"></a>jdk1.7中hashMap多线程死循环问题</h6><p>根本原因：jdk1.7扩容时，数据迁移用的是头插法，但是由于put操作用的尾插法，会导致扩容后的链表顺序相反</p><p>发生场景：</p><ul><li>线程一准备扩容的时候，阻塞，此时item和next指针都已经指向了链表的第一个元素和第一个元素的next</li><li>此时线程二开始扩容，扩容完毕后，原本第一个元素的next变成了null</li><li>线程一开始迁移，由于next指针和当前真实的链表顺序不符，此次迁移完毕后链表会形成<strong>环状结构</strong>，下次get操作会导致死循环问题</li></ul><blockquote><p>在jdk1.8中，改成了尾插法，因此扩容后不会改变原有顺序</p></blockquote><h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><h4 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h4><p>Spring是一款开源的轻量级Java开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>其提供的最主要的核心功能就是IoC（Inversion of Control，控制反转）和AOP（Aspect Oriented Programming，面向切面编程）。</p><p>它有几个比较重要的模块：spring-core(IoC)、spring-bean、spring-jdbc、spring-aop、spring-webmvc</p><h4 id="Spring、Spring-MVC、Spring-Boot的关系"><a href="#Spring、Spring-MVC、Spring-Boot的关系" class="headerlink" title="Spring、Spring MVC、Spring Boot的关系"></a>Spring、Spring MVC、Spring Boot的关系</h4><p>Spring其实包含了很多的功能模块（上述已经提到了几个），而其中的spring-webmvc是其中比较重要的一个模块。</p><p>Spring MVC主要提供了快速构建MVC架构的web程序的能力</p><p>在Spring开发过程中手动配置过于繁琐，尤其是有时候需要编写复杂的xml文件，为了简化这一过程，Spring Boot诞生了。</p><blockquote><p>要注意的是，Spring Boot仅仅是为了简化开发中繁琐的配置。</p><p>比如我们进行MVC开发时候还得使用Spring MVC，但是我们使用了Spring Boot简化了Spring MVC的配置过程。</p></blockquote><h4 id="SpringBoot、Spring-Cloud、Spring-Cloud-Alibaba的关系"><a href="#SpringBoot、Spring-Cloud、Spring-Cloud-Alibaba的关系" class="headerlink" title="SpringBoot、Spring Cloud、Spring Cloud Alibaba的关系"></a>SpringBoot、Spring Cloud、Spring Cloud Alibaba的关系</h4><p>随着SpringBoot项目越来越大，我们开发难度也陡然上升，同时维护难度也在上升</p><p>因此SpringCloud提出了一套微服务的规范，广义上的SpringCloud其实就这个，它提供了一套微服务架构的标准规范，比如网关、负载均衡、服务发现等等，至于每个模块用什么技术，那么就是下面的实现问题了</p><p>常用的两个实现就是SpringCloudNetflix以及SprinCloudAlibaba，其中前者就是狭义上的SpringCloud</p><p>二者都为对应SpringCloud给出的对应模块给出了相应的技术实现：</p><ul><li><p><strong>SpringCloudNetflix</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405191756153.jpeg" alt="img" style="zoom: 67%;" /></li><li><p><strong>SpringCloudAlibaba</strong></p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202405191757679.png" alt="img" style="zoom: 50%;" /></li></ul><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>IoC（Inversion of Control ）即控制反转&#x2F;反转控制，它是一种思想不是一个技术实现。</p><p>比如说：现在有一个类A，依赖于类B，那么就有两种常用的方法</p><ul><li>自定义A的构造函数，在其中new一个实例B</li><li>使用IoC，在初始化A的时候注入类B的实例</li></ul><p><strong>我们放弃了自己创建、管理对象的权力，将其交给Spring，但是我们同时也就不需要考虑创建、管理对象这一系列过程。</strong></p><p><strong>控制反转指的是：</strong></p><ul><li>控制：管理、创建对象</li><li>反转：将权力交给外部框架，如Spring</li></ul><p>IoC降低了对象之间的耦合度以及依赖程度，并且使得资源管理变得容易，只要将其加入了容器，你可以随时随地的注入。</p><h6 id="IoC与DI"><a href="#IoC与DI" class="headerlink" title="IoC与DI"></a>IoC与DI</h6><p>IoC（Inversion of Control）是一种设计思想或者说是某种模式，但是这设计思想在其他框架中也是使用了的。</p><p><strong>而IoC的较为普遍的、最合理的实现方式就是DI（Dependency Injection，依赖注入）</strong></p><h4 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h4><h6 id="如何声明Bean对象"><a href="#如何声明Bean对象" class="headerlink" title="如何声明Bean对象"></a>如何声明Bean对象</h6><p>Bean实际上就是指的被Spring IoC管理的那些对象，最基本的我们可以通过@Component注解来声明一个类为bean对象。</p><p>除此之外，在Spring MVC中由于分为了持久层、业务层、控制层，为了提高分辨率衍生了出了三个注解分别为@Repository、@Service、@Controller。</p><p>另外，对于通过方法声明的自定义bean，我们可以在方法上面加上@Bean注解来声明。</p><blockquote><p>@Bean与@Component有什么区别？</p><ol><li>@Bean作用与方法，而@Component作用与类</li><li>由于@Bean使用的方法，因此自定义性更强，比如定义RedisTemplate的序列化器</li></ol></blockquote><h6 id="如何注入Bean对象"><a href="#如何注入Bean对象" class="headerlink" title="如何注入Bean对象"></a>如何注入Bean对象</h6><p>一般来说，使用Spring提供的@Autowired或者JDK内置的@Resource注解</p><p>但是@Autowired注解是byType方式注入的，如果某个接口有多个实现类，那么就需要再加上一个@Qualifier注解，使用byName方式注入，而@Resource默认是byName方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><h6 id="Bean是线程安全的吗"><a href="#Bean是线程安全的吗" class="headerlink" title="Bean是线程安全的吗"></a>Bean是线程安全的吗</h6><p>在IoC中，有两种常见的作用域，分别为prototype和singleton，这两种作用域下是不同的。</p><p>对于prototype来说，由于每次获取都会new一个新对象，因此是线程安全的</p><p>但是对于singleton来说，由于使用的是单例模式，因此如果该bean对象是<code>有状态的</code>，那么就不是线程安全的。</p><p><strong>有两种解决方法</strong></p><ul><li>尽量不要定义有状态的bean对象</li><li>对于状态字段，可以使用ThreadLocal变量来保存</li></ul><h6 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h6><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231207163100469.png" alt="image-20231207163100469" style="zoom: 50%;" /><ul><li>执行构造函数实例化bean</li><li>bean依赖注入</li><li>处理一系列Aware结尾的接口</li><li>执行bean的前置处理器</li><li>初始化方法（PostConstruct自定义初始化、内置的初始化）</li><li>执行bean的后置处理器，一般在这做AOP，动态代理</li><li>销毁bean</li></ul><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><h6 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h6><p>AOP（Aspect-Oriented Programming:面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度</p><blockquote><p>Spring AOP主要基于<strong>动态代理技术+拦截器</strong>，对于有实现接口的类，会使用JDK proxy去创建代理对象，而对于没有实现接口的类会使用Cglib生成一个该类的子类作为代理对象。</p></blockquote><h6 id="几个重要术语"><a href="#几个重要术语" class="headerlink" title="几个重要术语"></a>几个重要术语</h6><ul><li>横切关注点（cross-cutting concerns） ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制等）。 </li><li>切面（Aspect）：对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。 </li><li>连接点（JoinPoint）：连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。 </li><li>通知（Advice）：通知就是切面在某个连接点要执行的操作。通知有五种类型：Before、After、AfterReturning、AfterThrowing、Around。</li><li>切点（Pointcut）：一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。</li><li>织入（Weaving）：织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。</li></ul><h6 id="常见的实现方式"><a href="#常见的实现方式" class="headerlink" title="常见的实现方式"></a>常见的实现方式</h6><p>有两种：<code>Spring AOP 与 AspectJ AOP</code></p><p>前者使用的是运行时增强（基于Dynamic Proxy），而后者使用的是编译时增强（基于字节码）。</p><h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><h6 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h6><p>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务、数据、显示三者分离来组织代码</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401181452594.png" alt="image-20240117161209710" style="zoom: 33%;" /><p><code>MVC更多的可以看看作是一种设计模式，而不是软件开发规范</code></p><h6 id="Spring-MVC的核心组件"><a href="#Spring-MVC的核心组件" class="headerlink" title="Spring MVC的核心组件"></a>Spring MVC的核心组件</h6><ul><li>DispatcherServlet：核心的中央处理器，负责接收请求、分发，并给予客户端响应。 </li><li>HandlerMapping：处理器映射器，根据URL去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。 </li><li>HandlerAdapter：处理器适配器，根据HandlerMapping 找到的Handler，调用对应的 Handler</li><li>Handler：请求处理器，处理实际请求的处理器。 </li><li>ViewResolver：视图解析器，根据 Handler 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 DispatcherServlet响应客户端</li></ul><h6 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h6><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401181451517.png" alt="image-20240117161537732" style="zoom: 33%;" /><ul><li>用户发起请求，DispatcherServlet拦截到用户的请求</li><li>DispatcherServlet根据URL路径，去HandlerMapping找到响应的Handler，并且会和拦截器一起返回一个调用链</li><li>DispatcherServlet调用HandlerAdapter，让Adapter去调用Handler</li><li>HandlerAdatpter调用Handler，然后返回ModelAndView对象</li><li>DispatcherServlet收到后，会去调用ViewResolver去解析，返回一个View视图对象</li><li>DispatcherServlet返回View视图给用户</li></ul><h4 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h4><p>在Spring中，一般使用@Transactional注解来开启事务（侵入性更小），但是要在配置类上加上@EnableTransactionManagement注解</p><h6 id="Spring事务管理接口"><a href="#Spring事务管理接口" class="headerlink" title="Spring事务管理接口"></a>Spring事务管理接口</h6><p>Spring框架中，和事务有关的有三个类：</p><ul><li>PlatformTransactionManager：（平台）事务管理器，Spring 事务策略的核心。</li><li>TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、 回滚规则)。</li><li>TransactionStatus：事务运行状态</li></ul><p>其中，PlatformTransactionManager是SPI的形式，它定义好了接口，由JDBC、Hibernate等自己去实现自己的事务管理器。在该接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> &#123;<br>    <span class="hljs-comment">//获得事务</span><br>    TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//提交事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>    <span class="hljs-comment">//回滚事务</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus var1)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h6><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。比如，到底是新开启一个事务，还是加入当前事务</p><p>在Spring中，定义了这么几种形式</p><ol><li><p>TransactionDefinition.PROPAGATION_REQUIRED</p><p>这是使用最多的，也是@Transaction注解默认的传播形式</p><ul><li>如果外部方法没有开启事务的话，Propagation.REQUIRED修饰的内部方法会新开启自己的事务</li><li>如果外部方法开启事务并且被Propagation.REQUIRED的话，所有 Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚</li></ul></li><li><p>TransactionDefinition.PROPAGATION_REQUIRES_NEW</p><p>创建一个新的事务，如果当前存在事务则把当前事务挂起，当前方法会新开启自己的事务</p></li><li><p>TransactionDefinition.PROPAGATION_NESTED</p><p>与PROPAGATION_REQUIRES_NEW不同，PROPAGATION_NESTED的事务和它的父事务是相依的，它的提交要和它的父事务一起。也就是说，如果父事务最后回滚，它也要回滚。如果子事务回滚或提交，不会导致父事务回滚或提交，但父事务回滚将导致子事务回滚</p></li></ol><h6 id="只读事务"><a href="#只读事务" class="headerlink" title="只读事务"></a>只读事务</h6><p>如果你一次执行多条查询语句，为了防止多条语句之间有事务提交，<code>保证读一致性</code>，可以开启只读事务。</p><h6 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h6><ol><li><p>异常捕获处理</p><p>在事务中捕获异常没有抛出，而是在catch中自己处理了。由于事务的AOP中就无法捕获到异常，会直接提交事务。</p></li><li><p>抛出检查异常</p><p>如果在方法后面加上throw 异常，那么就不会抛出RuntimeException了，而spring的事务默认只会捕获运行时异常。</p><p><code>解决方法</code>：在@Transactional注解中指定捕获的异常类</p></li><li><p>非public方法</p><p>如果使用注解的方法不是public方法，那么也会失效。</p></li><li><p>在Bean内部调用自己的事务方法</p><p>由于在内部调用自己的方法，因此没有使用代理类，导致AOP失效。</p><p><code>解决方法</code>：获取代理类，比如在方法内部注入自己，用这个类调用方法。</p></li></ol><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><h6 id="什么是Spring-Boot-Starters"><a href="#什么是Spring-Boot-Starters" class="headerlink" title="什么是Spring Boot Starters"></a>什么是Spring Boot Starters</h6><p><code>Spring Boot Starters是一系列依赖关系的集合</code>。没有这个之前，在开发web应用的时候，需要自己导入MVC、Tomcat相关依赖，而且还得确定好版本防止冲突。但是有了Spring Boot Starters，只需要引入spring-boot-starter-web就好了，它下面的子依赖已经包含了所有的web需要的依赖，并且配置好了版本。</p><h6 id="Spring-Boot的自动配置原理"><a href="#Spring-Boot的自动配置原理" class="headerlink" title="Spring Boot的自动配置原理"></a>Spring Boot的自动配置原理</h6><p>在Spring Boot启动类上有这样一个注解：@SpringBootApplication</p><p>实际上，这个注解里面包含了三个注解：</p><ul><li>@ComponentScan：扫描Bean，并加入IoC容器</li><li>@Configuration：声明该类是一个配置类，可以在里面声明Bean，导入其他配置类</li><li>@EnableAutoConfiguration：这个就是SpringBoot自动配置的注解，它通过@Import注解导入了一个AutoConfigurationImportSelector类，实现自动配置。</li></ul><h6 id="AutoConfigurationImportSelector工作流程"><a href="#AutoConfigurationImportSelector工作流程" class="headerlink" title="AutoConfigurationImportSelector工作流程"></a>AutoConfigurationImportSelector工作流程</h6><ul><li>读取META-INF&#x2F;spring.factories，获取需要自动装配的所有配置类</li><li>但并不是加载所有的自动配置类，它会通过@ConditionalOnxxx注解判断是否需要加载，满足条件后才会生效</li></ul><blockquote><p>想要相关配置生效必须引入spring-boot-starter-xxx包实现起步依赖</p></blockquote><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h4 id="MySQL-字段"><a href="#MySQL-字段" class="headerlink" title="MySQL 字段"></a>MySQL 字段</h4><h6 id="char和varchar"><a href="#char和varchar" class="headerlink" title="char和varchar"></a>char和varchar</h6><p>对于varchar来说，磁盘中只会存储实际长度的空间，但是char是声明了多大就会存储多大</p><p>对于varchar(10)和varchar(100)来说，虽然磁盘占用一样，但是实际读取到内存中的时候，varchar(100)还是会占用100个字节的空间</p><h6 id="不推荐使用TEXT和BLOB"><a href="#不推荐使用TEXT和BLOB" class="headerlink" title="不推荐使用TEXT和BLOB"></a>不推荐使用TEXT和BLOB</h6><p>这两种类型，在使用临时表的时候无法在内存中创建，只能在磁盘中创建，并且其检索效率较低</p><h6 id="NULL和’’"><a href="#NULL和’’" class="headerlink" title="NULL和’’"></a>NULL和’’</h6><p>在MySQL中，NULL需要占用额外的空间，但是’’占用空间是0</p><p>此外，在做条件判断的时候NULL只能使用IS NULL来判断，无法使用&#x3D;、&lt;这种比较运算符。</p><h4 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401181451253.png" alt="image-20240118144412169" style="zoom: 33%;" /><p>MySQL的基础架构大致可以分为两个部分：<strong>Server层</strong>和<strong>存储引擎</strong></p><h6 id="Server层基本组件"><a href="#Server层基本组件" class="headerlink" title="Server层基本组件"></a>Server层基本组件</h6><ul><li>连接器：接收客户端连接，并校验用户身份和权限。注意的是，用户登录成功后，连接器会从权限系统表中查询出权限数据并保存，即使在该连接中用户修改了系统表，次用户连接的权限仍然是登录时候的权限。</li><li>查询缓存：会记录select语句以及结果，一旦执行的select语句命中并且权限校验通过，就直接返回结果</li><li>分析器：对sql语句进行词法分析（提取sql关键字）和语法分析（语句是否正确）</li><li>优化器：按照优化方案优化语句（可能优化的方式不是最优的），比如索引的选择等</li><li>执行器：校验权限正确后，调用存储引擎接口，返回数据</li></ul><blockquote><p>MySQL 8.0 版本后删除了缓存的功能</p></blockquote><h6 id="Update语句执行过程"><a href="#Update语句执行过程" class="headerlink" title="Update语句执行过程"></a>Update语句执行过程</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update tb_student A set A.age=&#x27;19&#x27; where A.name=&#x27;张三&#x27;;<br></code></pre></td></tr></table></figure><ul><li>查询满足条件的数据，如果有缓存会使用缓存</li><li>查询后，修改相应的记录并调用InnoDB接口</li><li>在InnoDB中，会先将语句以及修改的相关数据页保存在内存中，并通过两阶段写入日志的方法写入redo log和binlog，并选择合适的时机将脏数据写入磁盘（如果没有写入就宕机了，可以通过redo log恢复）</li></ul><h4 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h4><p>要注意的是，存储引擎是基于表的而不是数据库，也就是说对于每个表都可以定制自己的存储引擎</p><p>MySQL5.5之前，MyISAM是默认引擎，之后就是InnoDB了，二者区别如下：</p><ul><li>InnoDB支持行级锁，而MyISAM只有表级锁</li><li>MyISAM不提供事务支持，InnoDB提供事务支持</li><li>MyISAM不支持MVCC，而InnoDB支持</li><li>InnoDB有redo log和undo log，因此可以支持故障恢复</li></ul><h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>无论是在InnoDb还是MyISAM中，索引的结构使用的都是B+树的结构</p><p>索引虽然可以加快查询的速度，但是增加了更新操作的开销</p><h6 id="索引底层的数据结构（B-树）"><a href="#索引底层的数据结构（B-树）" class="headerlink" title="索引底层的数据结构（B+树）"></a>索引底层的数据结构（B+树）</h6><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202404112111758.png" alt="image-20240118171104728" style="zoom:50%;" /><p>相比于B树来说：</p><ul><li>B+树只在叶子节点存放数据，每次查询必要搜索到底并且只在最后一次读取全部数据到内存，因此搜索效率更加稳定</li><li>在叶子节点使用链表的结构，因此更适用于范围查询</li></ul><blockquote><p>对于MyISAM，每个索引只存放key以及数据指针，不存放数据；而在InnoDB中，其主键索引存放数据。</p></blockquote><h6 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h6><p>聚簇索引指的是key与数据一起存放的索引，非聚簇索引只存放key和对于的指针</p><p>在InnoDB中，主键索引就是聚簇索引；InnoDB中的二级索引以及MyISAM中的所有索引都是非聚簇索引</p><ul><li>聚簇索引查询的效率更高，减少了一次IO，但是需要更大的存储空间</li><li>非聚簇索引更轻量，但是可能会造成回表查询</li></ul><h6 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h6><p>一个索引包含所有要查询的字段值，就称之为覆盖索引。（这其实是一种situation，而不是一种type）</p><h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6><p>使用表中的多个字段创建索引，它遵循最左匹配原则</p><p>最左匹配原则的原因是：联合索引简历后，只有左边的值确定了，才会根据排序进一步筛选右边的字段，否则直接筛选右边的字段是无序的</p><p>就好比你要从一个排好序的字符串数组中找第三位是’c’的所有字符串，但是你不给前两位，直接找第三位其实是无序的需要全局遍历，如果给定前两位你可以直接二分查找。</p><h6 id="对于索引的使用建议"><a href="#对于索引的使用建议" class="headerlink" title="对于索引的使用建议"></a>对于索引的使用建议</h6><ul><li>为合适的字段创建索引：比如不为NULL、频繁查询、频繁连接的字段</li><li>被频繁更新的字段应该慎重建立索引，因为添加索引后，会增加更新的开销</li><li>尽量使用联合索引，而不是单个索引</li></ul><h6 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h6><ul><li>没有使用索引覆盖，导致查询后导致回表（比如 select *）</li><li>创建了组合索引，但查询条件未遵守最左匹配原则</li><li>以%开头的LIKE查询比如LIKE ‘%abc’;</li></ul><h4 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h4><p>MySQL中有三个较为重要的日志：redo log、undo log、binlog。其中redo log和undo log是InnoDB自己的</p><h6 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h6><p><strong>redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力</strong></p><p>redo log写入磁盘的方式：</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401191956609.png" alt="image-20240119195629553" style="zoom: 33%;" /><p>redo log buffer -&gt; page cache -&gt; disk</p><p>但是刷盘的时机是可以设置的，有三种方式</p><ul><li>事务提交不立即刷盘，而是每秒将buffer写入page cache，并调用fsync刷盘</li><li>事务提交立即写入page cache并调用fsync刷盘</li><li>事务提交立即写入page cache，但每隔一秒调用fsync刷盘</li></ul><blockquote><p>page cache独立于MySQL，它是属于操作系统的部分</p></blockquote><h6 id="为什么要用redo-log，而不是每次更新直接刷数据盘"><a href="#为什么要用redo-log，而不是每次更新直接刷数据盘" class="headerlink" title="为什么要用redo log，而不是每次更新直接刷数据盘"></a>为什么要用redo log，而不是每次更新直接刷数据盘</h6><ol><li>数据页太大，一般为16KB，不能每次为了更新几十字节的数据就进行16KB的文件IO</li><li>每次更新的相关数据不一定位于同一数据页，容易发生页的换进换出，而redo log属于追加方式的顺序IO，很少发生换进换出</li></ol><h6 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h6><p>redo log它是物理日志，记录内容是“在某个数据页上做了什么修改”，而binlog是逻辑日志，记录内容是语句的原始逻辑</p><p>binlog主要用于数据备份，主从同步等操作，保证数据一致性</p><p>binlog刷盘流程如下，事务已提交就写入page cache，但是用户可以自定义：每秒fsync还是wrtie完直接fsync</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401192017585.png" alt="image-20240119201717525" style="zoom:33%;" /><h6 id="binlog为什么不能做崩溃恢复"><a href="#binlog为什么不能做崩溃恢复" class="headerlink" title="binlog为什么不能做崩溃恢复"></a>binlog为什么不能做崩溃恢复</h6><p>binlog记录了所有的操作，而redo log只记录了数据修改后的结果</p><p>因此发生故障时，直接通过redo log覆盖数据就好，但是binlog是逻辑指令，会发生数据不一致</p><p>比如binlog记录了加十次1，恢复的时候不能简单基于当前结果加十次1，因为你不知道从哪一次开始发生故障的，而redo log记录了当前记录为8，直接覆盖就行</p><h6 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h6><p>用于解决发生故障时，binlog和redo log不一致的问题</p><p>具体方法：</p><ul><li>先写入redo log，并将该记录置为prepare状态</li><li>事务提交后，会写入binlog</li><li>写完binlog后，将redo log对应记录置为commit状态</li></ul><p>若第二步失败，恢复时会发现redo log存在prepare项且binlog无对应项，<code>回滚</code></p><p>若第三步失败，恢复时会发现redo log存在prepare项但binlog有对应项，<code>提交</code></p><h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><p>用于事务的回滚操作以及MVCC，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作</p><h4 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h4><h6 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h6><p>关系型数据库事务满足ACID特性：Atomicity、Consistency、Isolation、Durability</p><blockquote><p>AID是手段，C是目的</p></blockquote><h6 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h6><ul><li>脏读：由于其他事务的更新操作，当前事务读到了其他事务修改但还未提交的记录</li><li>丢失修改：两个事务同时读，并都基于当前值修改（如A&#x3D;A-1），那么就会导致最终只修改了一次</li><li>不可重复读：在两次读之间，如果有事务的修改操作提交，会导致两次读的记录可能不一样</li><li>幻读：在两次读之间，如果有事务进行了<strong>插入&#x2F;删除操作</strong>，那么第二次读可能会莫名其妙多了一些数据</li></ul><blockquote><p>不可重复读主要针对于update操作，可以直接通过加锁来解决</p><p>但是幻读针对于insert、delete操作，你无法对原本不存在的数据加锁</p></blockquote><h6 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h6><p>read-uncommitted、read-committed、repeatable-read、serializable</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC的实现主要依靠三个部分实现：</p><ul><li>隐藏字段：事务id、回滚指针(指向undo log中上一个版本记录的指针)</li><li>读视图</li><li>undo log</li></ul><p>具体实现流程如下：</p><ul><li>根据当前事务的隔离级别，生成读视图（RC级别下，每次读都会生成；RR级别下，只有第一次读的时候会生成一次）</li><li>当需要读的时候会根据读视图的内容做以下判断：<ul><li>当前记录版本的事务id小于min_trx_id，那么说明该版本事务创建于读视图创建之前，直接使用</li><li>当前记录版本的事务id大于max_trx_id，那么说明该版本事务创建于读视图创建之后，不能使用</li><li>当前记录版本的事务id在二者之间，如果没有在读视图的活跃事务列表中（比如修改的是自己），那么可以使用，否则不能使用</li></ul></li><li>一旦发现该版本不能使用，则通过上一个版本的指针判断undo log中的旧版本是否可用，直至遍历到尾指针则返回空</li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201101170.png" alt="image-20240120110139110" style="zoom:50%;" /><h4 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h4><p>对于RR下面的一致性非锁定读（普通select语句），可以使用MVCC机制解决不可重复读和幻读问题</p><p>但是对于锁定读：</p><ul><li>select … lock in share mode</li><li>select … for update</li><li>insert、update、delete</li></ul><p>这种操作，不会使用MVCC乐观锁机制，会直接读取最新的版本，可以通过加S锁(共享锁，读锁)和X锁(排他锁，写锁)来保证可重复读，但无法解决幻读问题</p><p>解决幻读的方法是添加间隙锁，对于当前查询的范围添加锁，不允许插入满足查询条件的数据</p><h4 id="Mybatis相关问题"><a href="#Mybatis相关问题" class="headerlink" title="Mybatis相关问题"></a>Mybatis相关问题</h4><h6 id="Dao接口的工作原理"><a href="#Dao接口的工作原理" class="headerlink" title="Dao接口的工作原理"></a>Dao接口的工作原理</h6><p>xml中开头就是namespace，这个是dao接口的全限定名</p><p>然后每个MapperStatement都有一个id这个就对应的Dao接口函数名</p><p>Dao接口没有实现类，调用的时候会通过接口类的全限定名加函数名构造唯一的key，找到相应的MapperStatment，执行相应语句</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h4 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h4><h6 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h6><ul><li>Redis是基于内存的，IO速度本来就很快</li><li>Redis使用了IO多路复用技术</li><li>Redis是单线程的，不需要考虑上下文切换，而且不用考虑多线程安全问题</li></ul><h6 id="常见的缓存更新策略"><a href="#常见的缓存更新策略" class="headerlink" title="常见的缓存更新策略"></a>常见的缓存更新策略</h6><ul><li>Cache Aside Pattern：先更新DB，再删除缓存（反过来不行，因为更新DB的时间更长，容易导致不一致），但是这样也会导致不一致，没办法，redis本来就不是用来保证强一致性的</li><li>Read&#x2F;Write Through Pattern：写的时候若有cache先写到缓存，然后由cache服务<code>同步</code>更新DB</li><li>Write Behind Pattern：写的时候若cache存在，则先写到cache，然后由cache服务<code>异步</code>更新DB</li></ul><h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><h6 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h6><p>会基于当前redis的状态，生成一个快照，对所有数据进行备份</p><p>由于这种方式比较耗时，可以通过bgsave指令来另外fork一个线程用于保存快照</p><h6 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h6><p>和mysql的binlog类似，会记录每次执行的指令，并记录到buffer中，然后buffer -&gt; page cache -&gt; aof file</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201137280.png" alt="image-20240120113748242" style="zoom:50%;" /><p>每次写入一个指令到buffer中就会调用一次write，然后会根据不同策略调用fsync：</p><ul><li>一条指令一个fsync</li><li>一秒一次fsync</li><li>由操作系统自己fsync，一般30秒一次</li></ul><h6 id="为什么AOF先记录日志再执行指令"><a href="#为什么AOF先记录日志再执行指令" class="headerlink" title="为什么AOF先记录日志再执行指令"></a>为什么AOF先记录日志再执行指令</h6><blockquote><p>首先要注意的是，Redis的设计是为了满足系统的高可用性，真的要实现强一致会降低性能</p></blockquote><ul><li>避免写入日志前的语法检查</li><li>避免记录日志对当前指令执行的阻塞，但是会导致对后续指令的阻塞</li></ul><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>开启混合模式后，会将RDB的文件加到AOF文件开头，大大减小AOF文件的大小</p><p>混合模式就是为了综合二者的优点：</p><ul><li>RDB文件只是redis的快照，文件大小更小，并且还原更快</li><li>AOF的持久化速度更快，实时性更高</li></ul><h4 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h4><p>Redis的指令执行是单线程的，但是对于网络请求、持久化这方面是可以支持多线程的，为的是提高IO性能</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201202823.png" alt="image-20240120120209740" style="zoom:50%;" /><h4 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h4><h6 id="过期key的处理"><a href="#过期key的处理" class="headerlink" title="过期key的处理"></a>过期key的处理</h6><p>redis使用了两个处理方式</p><ul><li>惰性删除：当对该key进行查询操作的时候，检查该key是否过期，如果过期则直接删除</li><li>定期删除：redis每隔一段时间就会抽取<code>一部分的key</code>检查过期状态，<strong>这个线程是主线程，会阻塞指令执行</strong></li></ul><h6 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h6><p>当redis内存满了过后再添加数据就会触发内存淘汰机制</p><ol><li>noeviction：内存满了不允许写入</li><li>volatile-ttl：对设置了ttl的key，删除最快要过期的数据</li><li>allkeys-random：对全体key随机删除</li><li>volatile-random：对设置了ttl的key，随机删除</li><li>allkeys-lru：对所有的key，使用LRU算法    <code>这个是最常用的</code></li><li>volatile-lru：对设置里ttl的key，使用LRU算法</li><li>allkeys-lfu：对所有的key，使用LFU算法</li><li>volatile-lfu：对设置里ttl的key，使用LFU算法</li></ol><h4 id="事务、pipeline、Lua脚本"><a href="#事务、pipeline、Lua脚本" class="headerlink" title="事务、pipeline、Lua脚本"></a>事务、pipeline、Lua脚本</h4><p>三者都可以批量执行多个语句，但是还是存在一些区别</p><ul><li>事务：多个语句要分开做网络传递，但是批量执行期间不会被别的指令打断</li><li>pipeline：多个语句合到一次，只做一次网络交互，但是指令可能会穿插执行</li><li>Lua脚本：只做一次网络交互，并且不会被打断</li></ul><blockquote><p>这三个都无法实现<strong>原子性和一致性</strong>，无法支持出错回滚，一般使用Lua脚本来实现事务</p></blockquote><h4 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h4><ul><li>使用批量操作减少网络传输：使用mset类似的指令，对于不同指令可以使用Lua脚本、pipeline</li><li>大量key集中过期问题：定期清理中，若发现大量过期key会导致阻塞时间过长，可以设置随机TTL</li><li>bigkey问题：如果一个key大小过大，会导致网络IO阻塞、过期清理时间长，可以对其分割存储</li><li>hotkey问题：如果一个key访问频率过高，同样也会影响网络IO，可以使用主从库、集群方式减轻压力，也可以使用本地缓存减少redis访问频率</li><li>慢查询：一般redis中根据key查找都是O(1)复杂度，但是如果使用keys *这种指令，就会导致时间复杂度为O(n)，导致慢查询，我们尽量要避免这种类似指令</li></ul><h4 id="Redis内存碎片"><a href="#Redis内存碎片" class="headerlink" title="Redis内存碎片"></a>Redis内存碎片</h4><ul><li>由于Redis为一个key申请空间的时候，一般都要比其占用空间要大一点，这就会导致内部碎片</li><li>同时当我们频繁的删除key的时候，其占用的内存并不会立刻free，这就会导致外部碎片</li></ul><h4 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h4><p><strong>缓存三兄弟</strong>：缓存穿透、缓存雪崩、缓存击穿</p><h6 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h6><p>访问大量DB中不存在的key，由于redis中没有，所有请求会直接转向DB</p><ul><li>可以在redis中缓存该不存在的key，其value设置为一个约定的特殊字符，代表NULL</li><li>使用bloom filter，但是会产生误判，认为不存在的key存在，但是使用适当的bitmap长度，性能很高</li></ul><h6 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h6><p>大量key在同一时间失效，或者redis服务直接宕机，那么所有请求都会转向DB</p><ul><li>使用集群、sentinel</li><li>随机TTL</li></ul><h6 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>对于某个热点key，如果发生过期或者不在redis中，大量请求也同样会转向DB</p><ul><li>缓存预热</li><li>使用互斥锁访问、逻辑过期</li><li>设置热点数据永不过期或者过期时间比较长</li></ul><h4 id="Redis集群-哨兵模式"><a href="#Redis集群-哨兵模式" class="headerlink" title="Redis集群-哨兵模式"></a>Redis集群-哨兵模式</h4><p>哨兵模式（sentinel）用于实现主从集群的自动故障恢复</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231130174229378.png" alt="image-20231130174229378" style="zoom: 33%;" /><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><ol><li>监控master和slave是否在按照预期正常运作</li><li>如果master故障，sentinel会从slave中选取一个作为新的master（故障转移）</li><li>通知redis客户端主从发生变化，防止客户端违规的向原本的master写数据</li></ol><h6 id="服务状态监控工作原理"><a href="#服务状态监控工作原理" class="headerlink" title="服务状态监控工作原理"></a>服务状态监控工作原理</h6><p>基于心跳机制检测，一旦有一个sentinel发现ping不通某个node就会认为该node主观下线。</p><p>一旦有超过一定数量（自己配置）的sentinel都认为该node主观下线，则该node客观下线</p><p>如果认为客观下线的node是master则会通过以下方式选举新的master：</p><ul><li>根据设定的优先级选择slave作为master</li><li>如果优先级一样，选offset最大的slave</li></ul><blockquote><p>sentinel自己也是一个node，也就是说一个sentinel会ping所有的主从redis，也会ping其他的sentinel</p></blockquote><h6 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h6><p>由于网络原因，sentinel无法连接到master认为其下线从而选出新的master。但是客户端仍可以与原本的master连接，因此在主从切换的过程中，原本的matser仍然在接收写命令。</p><p>但是一旦网络恢复，原本的master会变为slave，他会清空原本写入的数据，和新的master做全量同步，这会导致在主从切换过程中写入的数据发生丢失。</p><p>可以通过设置两个参数来解决</p><ul><li><code>min-replicas-to-write</code>：表示最少的从节点个数，如果不满足则不允许执行写操作</li><li><code>min-replicas-max-lag</code>：表示数据复制时的 ACK 消息延迟的最大时间。主库做同步时，如果没有在指定时间返回ACK，则拒绝写入数据。</li></ul><h4 id="Redis集群-分片集群"><a href="#Redis集群-分片集群" class="headerlink" title="Redis集群-分片集群"></a>Redis集群-分片集群</h4><h6 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h6><ul><li><p>在分片集群中，有很多的master，每个master保存一部分数据</p></li><li><p>每个master必须至少有一个slave，但是并<strong>不会实现读写分离，slave只是做数据备份方便故障转移</strong></p></li><li><p>各个master之间互相通过心跳机制监控，不需要哨兵机制</p></li></ul><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201351902.png" alt="image-20240120135042566" style="zoom:33%;" /><blockquote><p>如果有一个master故障并且没有slave，那么整个集群都将不可用</p></blockquote><h6 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h6><p>为了实现访问任何节点都可以得到同一个数据，redis使用了一种插槽的概念</p><p>插槽的总数是16384个，对于请求的key，会根据key做hash然后对16485取模</p><p>redis给每个master都分配了插槽，如果当前访问的节点发现算出来的结果不是自己的槽就会根据值路由到其他redis节点，否则从自己的内存中查出来返回。</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/image-20231130175653818.png" alt="image-20231130175653818" style="zoom: 33%;" /><h6 id="Redis-Cluster扩容缩容期间可以提供服务吗"><a href="#Redis-Cluster扩容缩容期间可以提供服务吗" class="headerlink" title="Redis Cluster扩容缩容期间可以提供服务吗"></a>Redis Cluster扩容缩容期间可以提供服务吗</h6><p>如果进行重新分片，动态迁移哈希槽，那么可能会发生计算hash后来到指定节点，但是发现数据不存在的情况</p><p>为了保证cluster的可用性，有两个重定向包：</p><ul><li>MOVED：说明hash迁移完成，但是客户端没更新分配情况，因此会让客户端更新hash槽信息并返回真正存储该key的node</li><li>ASK：说明还正在迁移，只会发送存储该key的node，但不会让客户端更新hash槽信息</li></ul><h4 id="Redis的扩容缩容原理"><a href="#Redis的扩容缩容原理" class="headerlink" title="Redis的扩容缩容原理"></a>Redis的扩容缩容原理</h4><p>当redis的hash容量达到扩容或者缩容的阈值时，就会触发扩容缩容</p><p>此时会使用ht[1]，先申请一个足够的空间，然后将ht[0]的数据迁移过去</p><p>为保证可用性，并不是一次性迁移成功，而是每迁移一部分，就会停止，处理客户端请求</p><p>当迁移过程中，如果添加数据，就会直接插入ht[1]，查询数据会保留一个字段记录迁移到那个数据，在这个数据之前的访问ht[1]，之后的访问ht[0]</p><p>迁移完成后，ht[1]会变成ht[0]，同时释放ht[0]的空间</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401311148188.png" alt="image-20240131114846042" style="zoom: 33%;" /><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201447456.png" alt="image-20240120144703385" style="zoom:33%;" /><p>JVM的运行时数据区分为两大部分：线程共享和线程私有</p><p>其中线程共享的区域为：堆、字符串常量池、运行时常量池</p><p>线程私有的区域为：虚拟机栈、本地方法栈、程序计数器</p><h4 id="运行时区域"><a href="#运行时区域" class="headerlink" title="运行时区域"></a>运行时区域</h4><h6 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h6><p><strong>线程私有</strong>，用于记录当前线程执行到的字节码位置，方便线程的上下文切换</p><h6 id="两个栈"><a href="#两个栈" class="headerlink" title="两个栈"></a>两个栈</h6><p><strong>线程私有</strong>，都是用来保存函数调用产生的局部变量，调用一次压一次，返回后自动弹出</p><p>但是虚拟机栈保存的Java方法的方法调用，而本地方法栈保存的是native方法的方法调用</p><blockquote><ul><li>方法调用的返回分为两种形式，一种是return正常返回，一种是抛出异常</li><li>在局部变量中，对于对象而言，只保存引用变量，真正的对象实例依然是存放在堆中</li></ul></blockquote><h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><p><strong>线程共享</strong>，几乎所有的对象实例都是在堆中创建的</p><p>堆其实又分为多个区域：新生代、老年代，其中新生代又分为Eden区和Survivor区</p><p><code>要注意的是，虽说在JDK1.7之前还有个永久代，但是实际上永久代是方法区的一种实现，严格意义上说它并不属于堆的一部分</code></p><p>此外，JDK1.8过后永久代已经被元空间取代，并转移至本地内存中</p><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><p>方法区会存储已被虚拟机加载的类信息、字段信息、方法信息等数据</p><p>方法区可以看作是一个接口，JDK1.8之前其实现是永久代，之后的实现是元空间</p><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401201511592.png" alt="image-20240120151159547" style="zoom:33%;" /><blockquote><p>1.7之前是永久代；1.7的时候将字符串常量池和静态方法移至堆中存放；1.7以后，剩下的永久代中的东西移至元空间</p></blockquote><p>移至元空间的原因是永久代存在上限，无法动态调整，而本地内存取决于计算机的配置，不容易OOM</p><h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>它是方法区的一部分，用于存放字面量和符号引用的，常量池表会在类加载后存放到运行时常量池中</p><p>其中比较重要的是字符串常量池，它在JDK1.7的时候从永久代移到了堆中（静态变量也是），它是为了String类型专门开辟的常量池，为了减少相同字符串的重复创建</p><h6 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h6><p>直接内存比较特殊，它并不属于Java本身，是属于OS层面的，它方便了Java和操作系统之间的IO</p><p>一般来说，Java的IO依赖于native方法，这就会导致IO的数据会先从内核拷贝到native内存，再从native内存拷贝到Java内存</p><p>但是有了直接内存后，可以直接从内核拷贝到直接内存，然后Java直接读取直接内存，减少了一次数据拷贝</p><h4 id="JVM对象"><a href="#JVM对象" class="headerlink" title="JVM对象"></a>JVM对象</h4><h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><ul><li>首先在方法区中查找该对象对应的类有没有加载，若没有加载执行类加载逻辑</li><li>类加载完成后，就可以在堆中为该对象分配指定空间了，分配空间的方法取决于GC方法。分为空闲列表（未整理）以及指针碰撞（整理）</li><li>分配完指定空间，就将该空间的所有数据全部置为0，这样可以实现默认初始化，比如int的默认值为0</li><li>设置对象头，比如类的元数据信息、对象的哈希码、GC年龄</li><li>最后才是执行构造函数</li></ul><p>为了解决对象分配空间的并发问题，有两种方法</p><ul><li>CAS：失败重试</li><li>TLAB：为每个线程分配一点独立Eden空间，不够再CAS</li></ul><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>一个对象由三个部分组成：对象头、数据、对齐填充</p><h6 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h6><p>一个引用变量访问对象实例有两种方式</p><ul><li>句柄：引用变量指向句柄，句柄存放对象地址以及方法区中类信息地址</li><li>直接指针：引用变量直接指向实例，实例中存放方法区中类信息地址</li></ul><p>直接指针的访问速度更快，但是如果对象需要移动位置要修改所有的相关引用变量，而句柄只需要修改自己的对象指针就好</p><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><h6 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h6><ul><li><p>对象的创建基本都在Eden区，只有大对象的创建才会跳过Eden区，直接进入老年区，创建时年龄初始化为0</p></li><li><p>如果Eden区放不下了，就会触发一次GC，每次GC后所有存活的实例年龄+1，</p><blockquote><p>具体是何种GC方式取决于老年代的最大连续空闲空间是否大于等于所有新生代使用的空间（即就算所有新生代全部进入老年代也能放得下），如果大于等于就Minor GC；否则会Full GC</p><p>这其实就是<strong>空间分配担保</strong></p></blockquote></li><li><p>如果Eden区有年龄为1的对象，就会进入Survivor区</p></li><li><p>Surivior区如果有达到年龄阈值的就进入老年代</p><p>年龄的阈值有两个，一个是设置的固定阈值，一个是50%(50%也是设置的)空间所对应的年龄，二者取较小者为最后的阈值</p></li></ul><h6 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h6><ul><li>部分收集 (Partial GC)<ul><li>新生代收集（Minor GC）：只对新生代进行垃圾收集</li><li>老年代收集（Major GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li>整堆收集 (Full GC)：收集整个Java堆和方法区</li></ul><h4 id="死亡对象的判断方法"><a href="#死亡对象的判断方法" class="headerlink" title="死亡对象的判断方法"></a>死亡对象的判断方法</h4><h6 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h6><p>每有一个引用指向该对象，该对象的引用就加1，个数为0的可以被认为是垃圾对象</p><p>但是如果出现对象之间的循环引用，那么引用计数法就无法检测出来了</p><h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p>构造引用关系图，如果某个对象对任意一个GC root节点都不可达，那么就可以认为是垃圾</p><p>GC root可以是：虚拟机栈、本地方法栈中引用的对象、常量引用的对象、静态属性引用的对象</p><h6 id="如何回收方法区中的类"><a href="#如何回收方法区中的类" class="headerlink" title="如何回收方法区中的类"></a>如何回收方法区中的类</h6><p>回收该类需要满足三个条件</p><ol><li>该类所有的实例已经被回收</li><li>该类的ClassLoader已经被回收</li><li>该类的.Class对象没有地方引用，也没有地方反射调用类的方法</li></ol><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul><li><p>标记清除法：标记出所有不需要回收的对象，然后统一回收没有被标记到的对象，</p><p>会产生大量内存碎片</p></li><li><p>标记复制法：将原本的内存区域分为两块，每次清理的时候将存活的对象复制到另一块去</p><p>这会导致可用内存空间减小，并且如果碰到每次GC数量较少的内存区域（如老年代），每次为了GC几个对象而复制一堆对象，有些得不偿失</p></li><li><p>标记整理法：每次回收后，会把对象往一端移动，然后直接清理另一端脏数据区域</p><p>移动的效率不高，适合老年代这种回收频率低的区域</p></li></ul><blockquote><p>一般来说，新生代会使用标记复制，而老年代使用标记清除或者标记整理</p></blockquote><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>一共有四大类：serial、parallel、CMS、G1。其中serial和parallel都有两个版本分别针对新生代和老年代，称之为serial new + serial old以及parallel new + parallel old</p><p>其中new使用的是标记复制，old使用的是标记整理</p><p>对于serial和parallel，二者的区别在于回收的时候是单线程还是多线程，但是不管是不是多线程，回收的时候都会暂停程序的运行，即STW(“stop the world”)</p><p>在Java8及以前，JVM使用的就是parallel new + parallel old</p><p>而从Java9开始，就使用G1收集器了</p><h6 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h6><p>它使用的收集方法是标记清除算法</p><ul><li>初始标记：<code>STW</code>，找到GC root以及其直接关联的对象</li><li>并发标记：和用户线程并发，查找与GC root间接关联的对象，并且记录该过程中引用的变化情况</li><li>重新标记：<code>STW</code>，根据引用的变化情况，重新检查相关对象的可达性</li><li>并发清理：和用户线程并发，清理垃圾</li></ul><p>由于并发清理也可能会出现引用变化产生垃圾，因此会出现浮动垃圾的现象</p><p>此外使用标记清除法，会产生大量内存碎片</p><h6 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h6><p>G1收集器不再使用传统的各个区之间物理隔离，而是将整个堆分成了多个region，每个region都可以是Eden、Survivor、old</p><p>每次GC的时候其实就是将region中存活的对象拷贝到另一个新的region中，因此G1可以看成是宏观上标记整理，微观上标记复制</p><p>当eden区满的时候会触发一次STW young GC</p><p>而当老年代达到一定阈值的时候，就会触发一次mix GC</p><p>G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的 Full GC</p><h4 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401211323146.png" alt="image-20240121132314060" style="zoom: 25%;" /><ul><li>前面四字节是固定的，称之为魔数：”CAFEBABE”</li><li>minor version和major version分别是Java的大小版本号</li><li>后面的结构基本都是统一的：xxx的个数 + xxx数组，比如常量池个数+常量池数组</li><li>Constant Pool：常量池</li><li>Access Flag是访问空值，比如public、volatile、final等</li><li>This class和Super Class分别是当前类和父类的索引，这一项没有数组的原因是：Java中是单继承的，因此只会有一个父类</li><li>Interface：接口信息；Field：字段信息；Method：方法信息</li><li>Attribute：在上面三个的数组中其实包含了Access Flag、name、相关Attribute数组。除此之外，用户还可以自定义其他的属性，那么就会保存在这个地方</li></ul><h4 id="类加载过程（要区别于对象创建）"><a href="#类加载过程（要区别于对象创建）" class="headerlink" title="类加载过程（要区别于对象创建）"></a>类加载过程（要区别于对象创建）</h4><img src="https://raw.githubusercontent.com/ZenithWon/figure/master/202401211339833.png" alt="image-20240121133951788" style="zoom: 33%;" /><p>一个类的加载过程可以分为：加载-&gt;连接-&gt;初始化  三大部分</p><p>其中，连接又可以拆分为：验证-&gt;准备-&gt;解析 三个部分</p><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><p>类加载会通过类的全限定名获取二进制字节流，然后将其转换到方法区的运行时数据区中，并且会在内存中生成一个Class对象</p><p>类加载可能和连接阶段有部分重叠，比如验证中的字节码文件验证，也就是说类加载还没有完成，连接可能就开始了</p><h6 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h6><p>连接分为三个步骤</p><ul><li><p>验证：验证字节码文件、验证符号引用、验证语法语义等</p></li><li><p>准备：在准备阶段会给类分配内存空间并设置初始值</p><p>这里分配的空间是类的静态变量，而且初始值全都设置为0，除非是static final修饰的字面量，才会在这里赋值</p></li><li><p>解析：将符号引用转化为方法区中的直接引用，比如方法符号引用转化为方法表中的偏移地址</p></li></ul><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>初始化我理解的就是Class类的初始化，这里就会给类变量真正的初始化了，而不是使用0的默认值</p><p>并且只有主动使用该类才会去初始化，否则执行到连接就会停止，直到使用该类</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>Java有三个默认的类加载器：BootstrapClassLoader、ExtensionClassLoader、AppClassLoader</p><p>除了BootStrapClassLoader是用C++实现的不用被加载以外，其他只要是类就要被加载（包括这两个类加载器）</p><p>加载的时候会使用双亲委派机制，防止重复加载某个类</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位</p><p>一个进程可以拥有多个线程，在Java中多个线程共享进程的堆、方法区，但是拥有自己私有给的程序计数器、栈结构</p><p>在JDK1.2之前，Java的线程属于用户线程，之后采用的是内核线程，可以实现多核运行</p><p>在Java中，进程之间是独立的，不会互相影响，但是线程之间由于共享堆以及方法区，多个线程之间很有可能会互相影响</p><p>此外，在单核CPU下，使用多线程并不一定可以提高效率</p><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile可以保证变量的可见性，但是无法保证变量更新的过程中的原子性</p><p>因为他只会保证每次使用的时候会去主存中获取值，但是更新操作时先读后改再写回，这三步不是原子的</p><p>此外volatile可以禁用指令重排序，他不允许在他之前的写操作延迟执行，也不允许在他之后的读操作超前执行</p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><p>假设没有人来竞争，会直接执行相关操作然后试图更新，发现被抢占了就会自旋</p><p>乐观锁的实现方式有版本号机制和CAS操作</p><p>对于CAS操作，它是OS提供的一个原子指令，compare和swap两个操作是原子的不会被打断。但是CAS有ABA问题，最终解决方式还是用到了版本号机制</p><h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><p>假设有人来竞争，每次需要资源的时候会先获得锁，否则不会执行相关操作</p><p>比如synchronized、Reentrantlock、RedissonLock等都是悲观锁</p><h4 id="synchorized原理"><a href="#synchorized原理" class="headerlink" title="synchorized原理"></a>synchorized原理</h4><p>被synchronized修饰的代码块，会借助OS提供的monitorenter、monitorexit两个指令来实现</p><p>monitorenter会获取一个monitor对象锁，并且锁的计数器加一</p><p>后面monitorexit的时候就会释放锁，计数器减一</p><p>但是被synchronized修饰的方法并不是靠这个，而是有一个方法的访问属性表明它是一同步方法，然后执行相应的方法调用</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>每个Thread类都有一个ThreadLocalMap类，这是属于线程的私有资源</p><p>它是一个hashMap，key是一个ThreadLocal对象，value就是该线程保存的值</p><p>当ThreadLocal需要set的时候，会通过当前线程获取当前线程的ThreadLocal，然后用this作为key，来set一个value</p><p>此外，他和ArrayList一样也是懒加载的</p><h6 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h6><p>由于ThreadLocalMap中的key是弱引用，而value是强引用，当他的key没有外部强引用引用的时候就会被GC回收</p><p>此时value是强引用不会被回收，这就会导致内存泄漏</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>当队列为空且核心线程池不满的时候，会直接使用核心线程池中的线程执行任务</p><p>然后，如果核心线程池加满了，但是队列还没有满，那么就放到队列中阻塞</p><p>如果队列也满了，那么就会开启非核心线程池，使用非核心线程执行</p><p>再满了，就会执行饱和策略了</p><p>此外，设置的存活时间是针对于非核心线程的，如果非核心线程在设置的存活时间中一直没有任务，就会被释放</p><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>AQS是一个抽象队列同步器，用于同步使用</p><p>他将共享资源抽象为state，然后使用CAS操作来更新state，保证原子性并且表达资源的占有情况</p><p>并且它使用一个双向队列，来保存阻塞线程</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><p>四层模型分别为：应用层、传输层、网络层、网络接口层</p><ul><li><p>应用层：主要提供两个终端之间的应用数据传输，这里的应用数据格式是异构的，不同的应用层协议都是不同的</p></li><li><p>传输层：为应用多种多样的协议提供统一的数据传输服务。</p><blockquote><p>从代码角度来说，只需要调用tcp.send(msg)，而不是每个应用层协议都需要写一个send，如http.send(msg)</p></blockquote></li><li><p>网络层：传输层只负责src send to dst，但是具体怎么送到，走哪几个路由器，是网络层的任务</p></li><li><p>网络接口层：这里其实包含的是数据链路层和物理层，这负责的是每一段链路上数据的正确送达</p></li></ul><p>分层模型可以大大提高系统的灵活度，让每一层的实现都是独立的，分解原本网络传输问题成多个小问题</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h6 id="从输入URL到页面展示的过程"><a href="#从输入URL到页面展示的过程" class="headerlink" title="从输入URL到页面展示的过程"></a>从输入URL到页面展示的过程</h6><p>浏览器会根据输入的URL通过DNS协议解析出IP地址</p><p>然后主机会使用自己的随机临时端口和服务主机的80端口连接，这其中会建立一个TCP连接</p><p>服务器接收到请求后会处理请求，并返回响应结果</p><p>浏览器接收到后会渲染页面</p><h6 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h6><ul><li>HTTP的端口号是80，HTTPS的端口号是443</li><li>HTTP协议中传输的内容都是明文，没有加密，而HTTPS工作与SSL&#x2F;TLS之上，传输的内容均被加密过</li></ul><h6 id="HTTPS的加密问题"><a href="#HTTPS的加密问题" class="headerlink" title="HTTPS的加密问题"></a>HTTPS的加密问题</h6><p>HTTPS工作在SSL&#x2F;TLS之上，传输的内容使用的是对称加密，但是对称加密的密钥使用的是数字证书的非对称加密</p>]]></content>
    
    
    <categories>
      
      <category>Java八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>个人笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
